
AvrRTOSDemo.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 3d 00 	jmp	0x7a	; 0x7a <__ctors_end>
       4:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
       8:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
       c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      10:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      14:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      18:	0c 94 71 07 	jmp	0xee2	; 0xee2 <__vector_6>
      1c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      20:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      24:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      28:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      2c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      30:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      34:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      38:	0c 94 fa 22 	jmp	0x45f4	; 0x45f4 <__vector_14>
      3c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      40:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      44:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      48:	0c 94 74 05 	jmp	0xae8	; 0xae8 <__vector_18>
      4c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      50:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      54:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      58:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      5c:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      60:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>
      64:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__bad_interrupt>

00000068 <versionAPP>:
      68:	30 30 2e 30 30 2e 30 32 00                          00.00.02.

00000071 <versionRTOS>:
      71:	31 30 2e 34 2e 33 00 00 00                          10.4.3...

0000007a <__ctors_end>:
__ctors_end():
      7a:	11 24       	eor	r1, r1
      7c:	1f be       	out	0x3f, r1	; 63
      7e:	cf ef       	ldi	r28, 0xFF	; 255
      80:	d8 e0       	ldi	r29, 0x08	; 8
      82:	de bf       	out	0x3e, r29	; 62
      84:	cd bf       	out	0x3d, r28	; 61

00000086 <__do_copy_data>:
__do_copy_data():
      86:	11 e0       	ldi	r17, 0x01	; 1
      88:	a0 e0       	ldi	r26, 0x00	; 0
      8a:	b1 e0       	ldi	r27, 0x01	; 1
      8c:	ea e0       	ldi	r30, 0x0A	; 10
      8e:	f7 e4       	ldi	r31, 0x47	; 71
      90:	02 c0       	rjmp	.+4      	; 0x96 <.do_copy_data_start>

00000092 <.do_copy_data_loop>:
.do_copy_data_loop():
      92:	05 90       	lpm	r0, Z+
      94:	0d 92       	st	X+, r0

00000096 <.do_copy_data_start>:
.do_copy_data_start():
      96:	ac 36       	cpi	r26, 0x6C	; 108
      98:	b1 07       	cpc	r27, r17
      9a:	d9 f7       	brne	.-10     	; 0x92 <.do_copy_data_loop>

0000009c <__do_clear_bss>:
__do_clear_bss():
      9c:	14 e0       	ldi	r17, 0x04	; 4
      9e:	ac e6       	ldi	r26, 0x6C	; 108
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	01 c0       	rjmp	.+2      	; 0xa6 <.do_clear_bss_start>

000000a4 <.do_clear_bss_loop>:
.do_clear_bss_loop():
      a4:	1d 92       	st	X+, r1

000000a6 <.do_clear_bss_start>:
.do_clear_bss_start():
      a6:	a3 30       	cpi	r26, 0x03	; 3
      a8:	b1 07       	cpc	r27, r17
      aa:	e1 f7       	brne	.-8      	; 0xa4 <.do_clear_bss_loop>
      ac:	0e 94 84 00 	call	0x108	; 0x108 <main>
      b0:	0c 94 83 23 	jmp	0x4706	; 0x4706 <_exit>

000000b4 <__bad_interrupt>:
__vector_20():
      b4:	0c 94 58 01 	jmp	0x2b0	; 0x2b0 <__vector_default>

000000b8 <clockInit>:
clockInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/clock.c:29
// internal RC oscillator at 8MHz with CLKDIV8 = 1 resulting in 1MHz system clock

/* public functions */

/* init */
void clockInit (void) {
      b8:	df 93       	push	r29
      ba:	cf 93       	push	r28
      bc:	cd b7       	in	r28, 0x3d	; 61
      be:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/clock.c:52
	//CLKPR = CLKREG_DIV_BY_2;

	//alt version
	//clock_prescale_set(clock_div_2);

}
      c0:	cf 91       	pop	r28
      c2:	df 91       	pop	r29
      c4:	08 95       	ret

000000c6 <digitalIOInit>:
digitalIOInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:21


/*	public functions	*/

/*!	init */
void digitalIOInit (void) {
      c6:	df 93       	push	r29
      c8:	cf 93       	push	r28
      ca:	cd b7       	in	r28, 0x3d	; 61
      cc:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:22
	portsInit();
      ce:	0e 94 02 01 	call	0x204	; 0x204 <portsInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:23
}
      d2:	cf 91       	pop	r28
      d4:	df 91       	pop	r29
      d6:	08 95       	ret

000000d8 <dioToggleLED0>:
dioToggleLED0():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:25

void dioToggleLED0(void) {
      d8:	df 93       	push	r29
      da:	cf 93       	push	r28
      dc:	cd b7       	in	r28, 0x3d	; 61
      de:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:26
	PORT_TOGGLE(PORT_LED0);
      e0:	19 9a       	sbi	0x03, 1	; 3
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:27
}
      e2:	cf 91       	pop	r28
      e4:	df 91       	pop	r29
      e6:	08 95       	ret

000000e8 <dioSetLED0>:
dioSetLED0():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:29

void dioSetLED0(void) {
      e8:	df 93       	push	r29
      ea:	cf 93       	push	r28
      ec:	cd b7       	in	r28, 0x3d	; 61
      ee:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:30
	PORT_SET(PORT_LED0);
      f0:	29 9a       	sbi	0x05, 1	; 5
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:31
}
      f2:	cf 91       	pop	r28
      f4:	df 91       	pop	r29
      f6:	08 95       	ret

000000f8 <dioClearLED0>:
dioClearLED0():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:33

void dioClearLED0(void) {
      f8:	df 93       	push	r29
      fa:	cf 93       	push	r28
      fc:	cd b7       	in	r28, 0x3d	; 61
      fe:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:34
	PORT_CLR(PORT_LED0);
     100:	29 98       	cbi	0x05, 1	; 5
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/digitalIO.c:35
}
     102:	cf 91       	pop	r28
     104:	df 91       	pop	r29
     106:	08 95       	ret

00000108 <main>:
main():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:29
/*	private function interface	*/

/*	public functions	*/

/*! main entry point */
int main (void) {
     108:	df 93       	push	r29
     10a:	cf 93       	push	r28
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:33

	// disable global interrupts
	// {
	MCU_DISABLE_INTERRUPTS();
     110:	f8 94       	cli
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:39

	//xTaskCreate
	//xQueueCreate
	//xCoRoutineCreate

	systemInit();
     112:	0e 94 36 01 	call	0x26c	; 0x26c <systemInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:53

	systemExecution();

#elif (SYSCFG_TASKMODEL_THREADS)

	vTaskStartScheduler();
     116:	0e 94 40 0a 	call	0x1480	; 0x1480 <vTaskStartScheduler>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:57

#endif

	return 0;
     11a:	80 e0       	ldi	r24, 0x00	; 0
     11c:	90 e0       	ldi	r25, 0x00	; 0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:58
}
     11e:	cf 91       	pop	r28
     120:	df 91       	pop	r29
     122:	08 95       	ret

00000124 <vApplicationGetIdleTaskMemory>:
vApplicationGetIdleTaskMemory():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:69
implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
used by the Idle task. */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
                                    StackType_t **ppxIdleTaskStackBuffer,
                                    uint32_t *pulIdleTaskStackSize )
{
     124:	df 93       	push	r29
     126:	cf 93       	push	r28
     128:	00 d0       	rcall	.+0      	; 0x12a <vApplicationGetIdleTaskMemory+0x6>
     12a:	00 d0       	rcall	.+0      	; 0x12c <vApplicationGetIdleTaskMemory+0x8>
     12c:	00 d0       	rcall	.+0      	; 0x12e <vApplicationGetIdleTaskMemory+0xa>
     12e:	cd b7       	in	r28, 0x3d	; 61
     130:	de b7       	in	r29, 0x3e	; 62
     132:	9a 83       	std	Y+2, r25	; 0x02
     134:	89 83       	std	Y+1, r24	; 0x01
     136:	7c 83       	std	Y+4, r23	; 0x04
     138:	6b 83       	std	Y+3, r22	; 0x03
     13a:	5e 83       	std	Y+6, r21	; 0x06
     13c:	4d 83       	std	Y+5, r20	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:78
static StaticTask_t xIdleTaskTCB;
static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    /* Pass out a pointer to the StaticTask_t structure in which the Idle task's
    state will be stored. */
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
     13e:	e9 81       	ldd	r30, Y+1	; 0x01
     140:	fa 81       	ldd	r31, Y+2	; 0x02
     142:	8e e9       	ldi	r24, 0x9E	; 158
     144:	91 e0       	ldi	r25, 0x01	; 1
     146:	91 83       	std	Z+1, r25	; 0x01
     148:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:81

    /* Pass out the array that will be used as the Idle task's stack. */
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
     14a:	eb 81       	ldd	r30, Y+3	; 0x03
     14c:	fc 81       	ldd	r31, Y+4	; 0x04
     14e:	8c e6       	ldi	r24, 0x6C	; 108
     150:	91 e0       	ldi	r25, 0x01	; 1
     152:	91 83       	std	Z+1, r25	; 0x01
     154:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:86

    /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
    Note that, as the array is necessarily of type StackType_t,
    configMINIMAL_STACK_SIZE is specified in words, not bytes. */
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
     156:	ed 81       	ldd	r30, Y+5	; 0x05
     158:	fe 81       	ldd	r31, Y+6	; 0x06
     15a:	82 e3       	ldi	r24, 0x32	; 50
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	a0 e0       	ldi	r26, 0x00	; 0
     160:	b0 e0       	ldi	r27, 0x00	; 0
     162:	80 83       	st	Z, r24
     164:	91 83       	std	Z+1, r25	; 0x01
     166:	a2 83       	std	Z+2, r26	; 0x02
     168:	b3 83       	std	Z+3, r27	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:87
}
     16a:	26 96       	adiw	r28, 0x06	; 6
     16c:	0f b6       	in	r0, 0x3f	; 63
     16e:	f8 94       	cli
     170:	de bf       	out	0x3e, r29	; 62
     172:	0f be       	out	0x3f, r0	; 63
     174:	cd bf       	out	0x3d, r28	; 61
     176:	cf 91       	pop	r28
     178:	df 91       	pop	r29
     17a:	08 95       	ret

0000017c <vApplicationGetTimerTaskMemory>:
vApplicationGetTimerTaskMemory():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:97
application must provide an implementation of vApplicationGetTimerTaskMemory()
to provide the memory that is used by the Timer service task. */
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
                                     StackType_t **ppxTimerTaskStackBuffer,
                                     uint32_t *pulTimerTaskStackSize )
{
     17c:	df 93       	push	r29
     17e:	cf 93       	push	r28
     180:	00 d0       	rcall	.+0      	; 0x182 <vApplicationGetTimerTaskMemory+0x6>
     182:	00 d0       	rcall	.+0      	; 0x184 <vApplicationGetTimerTaskMemory+0x8>
     184:	00 d0       	rcall	.+0      	; 0x186 <vApplicationGetTimerTaskMemory+0xa>
     186:	cd b7       	in	r28, 0x3d	; 61
     188:	de b7       	in	r29, 0x3e	; 62
     18a:	9a 83       	std	Y+2, r25	; 0x02
     18c:	89 83       	std	Y+1, r24	; 0x01
     18e:	7c 83       	std	Y+4, r23	; 0x04
     190:	6b 83       	std	Y+3, r22	; 0x03
     192:	5e 83       	std	Y+6, r21	; 0x06
     194:	4d 83       	std	Y+5, r20	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:106
static StaticTask_t xTimerTaskTCB;
static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    /* Pass out a pointer to the StaticTask_t structure in which the Timer
    task's state will be stored. */
    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
     196:	e9 81       	ldd	r30, Y+1	; 0x01
     198:	fa 81       	ldd	r31, Y+2	; 0x02
     19a:	88 ef       	ldi	r24, 0xF8	; 248
     19c:	91 e0       	ldi	r25, 0x01	; 1
     19e:	91 83       	std	Z+1, r25	; 0x01
     1a0:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:109

    /* Pass out the array that will be used as the Timer task's stack. */
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
     1a2:	eb 81       	ldd	r30, Y+3	; 0x03
     1a4:	fc 81       	ldd	r31, Y+4	; 0x04
     1a6:	86 ec       	ldi	r24, 0xC6	; 198
     1a8:	91 e0       	ldi	r25, 0x01	; 1
     1aa:	91 83       	std	Z+1, r25	; 0x01
     1ac:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:114

    /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
    Note that, as the array is necessarily of type StackType_t,
    configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
     1ae:	ed 81       	ldd	r30, Y+5	; 0x05
     1b0:	fe 81       	ldd	r31, Y+6	; 0x06
     1b2:	82 e3       	ldi	r24, 0x32	; 50
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	a0 e0       	ldi	r26, 0x00	; 0
     1b8:	b0 e0       	ldi	r27, 0x00	; 0
     1ba:	80 83       	st	Z, r24
     1bc:	91 83       	std	Z+1, r25	; 0x01
     1be:	a2 83       	std	Z+2, r26	; 0x02
     1c0:	b3 83       	std	Z+3, r27	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:115
}
     1c2:	26 96       	adiw	r28, 0x06	; 6
     1c4:	0f b6       	in	r0, 0x3f	; 63
     1c6:	f8 94       	cli
     1c8:	de bf       	out	0x3e, r29	; 62
     1ca:	0f be       	out	0x3f, r0	; 63
     1cc:	cd bf       	out	0x3d, r28	; 61
     1ce:	cf 91       	pop	r28
     1d0:	df 91       	pop	r29
     1d2:	08 95       	ret

000001d4 <vApplicationStackOverflowHook>:
vApplicationStackOverflowHook():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:119

/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t xTask, char * pcTaskName ) {
     1d4:	df 93       	push	r29
     1d6:	cf 93       	push	r28
     1d8:	00 d0       	rcall	.+0      	; 0x1da <vApplicationStackOverflowHook+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <vApplicationStackOverflowHook+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	9a 83       	std	Y+2, r25	; 0x02
     1e2:	89 83       	std	Y+1, r24	; 0x01
     1e4:	7c 83       	std	Y+4, r23	; 0x04
     1e6:	6b 83       	std	Y+3, r22	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:121

}
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	0f 90       	pop	r0
     1f0:	cf 91       	pop	r28
     1f2:	df 91       	pop	r29
     1f4:	08 95       	ret

000001f6 <vApplicationIdleHook>:
vApplicationIdleHook():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:125

/*-----------------------------------------------------------*/

void vApplicationIdleHook (void){
     1f6:	df 93       	push	r29
     1f8:	cf 93       	push	r28
     1fa:	cd b7       	in	r28, 0x3d	; 61
     1fc:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/main.c:127
	/* Doesn't do anything */
}
     1fe:	cf 91       	pop	r28
     200:	df 91       	pop	r29
     202:	08 95       	ret

00000204 <portsInit>:
portsInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:15
/*	private constants	*/

/*	public functions	*/

/*!	init */
void portsInit (void) {
     204:	df 93       	push	r29
     206:	cf 93       	push	r28
     208:	cd b7       	in	r28, 0x3d	; 61
     20a:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:31
	// also don't do 1. DDR 0 PORT 1 then 3. DDR 1 PORT 0 (or vice versa)
	// put a 2. DDR 1 PORT 1 or 2a. DDR 0 PORT 0

	// PB0 was timer input capture (no longer needed)
	// PB1 is LED output
	DDRB = (PDIR_OUT << DDB1) | (PDIR_IN << DDB0);
     20c:	e4 e2       	ldi	r30, 0x24	; 36
     20e:	f0 e0       	ldi	r31, 0x00	; 0
     210:	82 e0       	ldi	r24, 0x02	; 2
     212:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:32
	PORTB = RESET;
     214:	e5 e2       	ldi	r30, 0x25	; 37
     216:	f0 e0       	ldi	r31, 0x00	; 0
     218:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:40
	//DDRC = RESET;
	//PORTC = RESET;

	// PD0 is uart rx in
	// PD1 is uart tx out
	DDRD = (PDIR_OUT << DDD1) | (PDIR_IN << DDD0);
     21a:	ea e2       	ldi	r30, 0x2A	; 42
     21c:	f0 e0       	ldi	r31, 0x00	; 0
     21e:	82 e0       	ldi	r24, 0x02	; 2
     220:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:41
	PORTD = RESET;
     222:	eb e2       	ldi	r30, 0x2B	; 43
     224:	f0 e0       	ldi	r31, 0x00	; 0
     226:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:42
}
     228:	cf 91       	pop	r28
     22a:	df 91       	pop	r29
     22c:	08 95       	ret

0000022e <portTogglePB1>:
portTogglePB1():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:45

/*	test  functions	*/
void portTogglePB1 (void) {
     22e:	df 93       	push	r29
     230:	cf 93       	push	r28
     232:	cd b7       	in	r28, 0x3d	; 61
     234:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:46
	PORT_TOGGLE(PORTB1);
     236:	19 9a       	sbi	0x03, 1	; 3
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:47
}
     238:	cf 91       	pop	r28
     23a:	df 91       	pop	r29
     23c:	08 95       	ret

0000023e <portSetPB1>:
portSetPB1():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:49

void portSetPB1 (void) {
     23e:	df 93       	push	r29
     240:	cf 93       	push	r28
     242:	cd b7       	in	r28, 0x3d	; 61
     244:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:50
	PORT_SET(PORTB1);
     246:	29 9a       	sbi	0x05, 1	; 5
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:51
}
     248:	cf 91       	pop	r28
     24a:	df 91       	pop	r29
     24c:	08 95       	ret

0000024e <portClearPB1>:
portClearPB1():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:53

void portClearPB1 (void) {
     24e:	df 93       	push	r29
     250:	cf 93       	push	r28
     252:	cd b7       	in	r28, 0x3d	; 61
     254:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:54
	PORT_CLR(PORTB1);
     256:	29 98       	cbi	0x05, 1	; 5
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/ports.c:55
}
     258:	cf 91       	pop	r28
     25a:	df 91       	pop	r29
     25c:	08 95       	ret

0000025e <powerInit>:
powerInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/power.c:19


/*	public functions	*/

/*!	init */
void powerInit (void) {
     25e:	df 93       	push	r29
     260:	cf 93       	push	r28
     262:	cd b7       	in	r28, 0x3d	; 61
     264:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/power.c:21

}
     266:	cf 91       	pop	r28
     268:	df 91       	pop	r29
     26a:	08 95       	ret

0000026c <systemInit>:
systemInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:64
static void systemConfigure (void);

/*	public functions	*/

/*!	init */
void systemInit (void) {
     26c:	df 93       	push	r29
     26e:	cf 93       	push	r28
     270:	cd b7       	in	r28, 0x3d	; 61
     272:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:65
	systemResetCheck();
     274:	0e 94 65 01 	call	0x2ca	; 0x2ca <systemResetCheck>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:66
	systemConfigure();
     278:	0e 94 7f 01 	call	0x2fe	; 0x2fe <systemConfigure>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:68

	clockInit();
     27c:	0e 94 5c 00 	call	0xb8	; 0xb8 <clockInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:69
	watchdogInit();
     280:	0e 94 03 07 	call	0xe06	; 0xe06 <watchdogInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:71

	digitalIOInit();
     284:	0e 94 63 00 	call	0xc6	; 0xc6 <digitalIOInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:75
#if (SYSCFG_TASKMODEL_POLLING)
	timer0Init(); // now called by prvSetupTimerInterrupt / OS
#endif
	timer1Init();
     288:	0e 94 ed 03 	call	0x7da	; 0x7da <timer1Init>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:77

	uartInit();
     28c:	0e 94 ad 04 	call	0x95a	; 0x95a <uartInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:83
	//terminalInit();

	//exitSystemReq = CLEAR;
	//count1sec_millisec = 0;

	testInit();
     290:	0e 94 91 01 	call	0x322	; 0x322 <testInit>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:84
}
     294:	cf 91       	pop	r28
     296:	df 91       	pop	r29
     298:	08 95       	ret

0000029a <systemExecution>:
systemExecution():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:87

/*!	periodic task */
void systemExecution (void) {
     29a:	df 93       	push	r29
     29c:	cf 93       	push	r28
     29e:	cd b7       	in	r28, 0x3d	; 61
     2a0:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:89

	while(CLEAR == exitSystemReq) {
     2a2:	80 91 20 02 	lds	r24, 0x0220
     2a6:	88 23       	and	r24, r24
     2a8:	e1 f3       	breq	.-8      	; 0x2a2 <systemExecution+0x8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:109
				count1sec_millisec = RESET;
			}
		}
#endif
	}
}
     2aa:	cf 91       	pop	r28
     2ac:	df 91       	pop	r29
     2ae:	08 95       	ret

000002b0 <__vector_default>:
__vector_default():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:119
//void BADISR_vect (void)
ISR(BADISR_vect, ISR_NAKED) __attribute__ ((noreturn));
ISR(BADISR_vect) {
    // record info about error, like which ISR
	// load contents of stack pointer current location into X
	__asm__ __volatile__ ("in r28, __SP_L__" ::);
     2b0:	cd b7       	in	r28, 0x3d	; 61
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:120
	__asm__ __volatile__ ("in r29, __SP_H__" ::);
     2b2:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:121
	__asm__ __volatile__ ("ld r26, Y+" ::);
     2b4:	a9 91       	ld	r26, Y+
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:122
	__asm__ __volatile__ ("ld r27, Y" ::);
     2b6:	b8 81       	ld	r27, Y
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:124
	
	__asm__ __volatile__ ("add r26, r26" ::);
     2b8:	aa 0f       	add	r26, r26
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:125
	__asm__ __volatile__ ("adc r27, r27" ::);
     2ba:	bb 1f       	adc	r27, r27
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:127
	// store that at sysBadCallerAddr_u
	__asm__ __volatile__ ("sts sysBadCallerAddr_u, r26" ::);
     2bc:	a0 93 23 02 	sts	0x0223, r26
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:128
	__asm__ __volatile__ ("sts sysBadCallerAddr_u + 1, r27" ::);
     2c0:	b0 93 24 02 	sts	0x0224, r27
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:134

	// PC is 14 bits wide, instructions are 4 bytes each, so this returns exact address
//	sysBadCallerAddr_u.addr_w <<= 1;

	// then restart
	__asm__ __volatile__ ("jmp __vectors" ::);
     2c4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     2c8:	ff cf       	rjmp	.-2      	; 0x2c8 <__vector_default+0x18>

000002ca <systemResetCheck>:
systemResetCheck():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:143
#endif

/*	private functions	*/

/*!	check cause of last reset, log for feedback/reporting */
static void systemResetCheck (void) {
     2ca:	df 93       	push	r29
     2cc:	cf 93       	push	r28
     2ce:	00 d0       	rcall	.+0      	; 0x2d0 <systemResetCheck+0x6>
     2d0:	00 d0       	rcall	.+0      	; 0x2d2 <systemResetCheck+0x8>
     2d2:	0f 92       	push	r0
     2d4:	cd b7       	in	r28, 0x3d	; 61
     2d6:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:144
	registerByte_t mcuResetStatus = MCUSR;
     2d8:	e4 e5       	ldi	r30, 0x54	; 84
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:146
	// check for cause of reset
	if (mcuResetStatus & (SET << WDRF)) {
     2e0:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:149
		// watchdog reset happened, but why? do something to send some fault info
	}
	if (mcuResetStatus & (SET << BORF)) {
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:152
		// brown out event
	}
	if (mcuResetStatus & (SET << EXTRF)) {
     2e4:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:155
		// external reset
	}
	if (mcuResetStatus & (SET << PORF)) {
     2e6:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:158
		// normal
	}
	MCUSR = 0;
     2e8:	e4 e5       	ldi	r30, 0x54	; 84
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:159
}
     2ee:	0f 90       	pop	r0
     2f0:	0f 90       	pop	r0
     2f2:	0f 90       	pop	r0
     2f4:	0f 90       	pop	r0
     2f6:	0f 90       	pop	r0
     2f8:	cf 91       	pop	r28
     2fa:	df 91       	pop	r29
     2fc:	08 95       	ret

000002fe <systemConfigure>:
systemConfigure():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:162

/*!	configure low level system wide settings */
static void systemConfigure (void) {
     2fe:	df 93       	push	r29
     300:	cf 93       	push	r28
     302:	cd b7       	in	r28, 0x3d	; 61
     304:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:168
	// todo: make modules for sleep/power control
	// SMCR, MCUCR (BODS, BODSE), PRR

	// MCUCR mcu control reg
	// no bootloader vector relocation (see pg 77 megaAVR datasheet)
	MCUCR = (SET << IVCE);
     306:	e5 e5       	ldi	r30, 0x55	; 85
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	81 e0       	ldi	r24, 0x01	; 1
     30c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:169
	MCUCR &= ~((SET << IVSEL) | (SET << IVCE));
     30e:	a5 e5       	ldi	r26, 0x55	; 85
     310:	b0 e0       	ldi	r27, 0x00	; 0
     312:	e5 e5       	ldi	r30, 0x55	; 85
     314:	f0 e0       	ldi	r31, 0x00	; 0
     316:	80 81       	ld	r24, Z
     318:	8c 7f       	andi	r24, 0xFC	; 252
     31a:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/system.c:173

	// interrupt vector start address is affected by IVSEL in MCUCR

}
     31c:	cf 91       	pop	r28
     31e:	df 91       	pop	r29
     320:	08 95       	ret

00000322 <testInit>:
testInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:101


/*	public functions	*/

/*!	init */
void testInit (void) {
     322:	af 92       	push	r10
     324:	bf 92       	push	r11
     326:	cf 92       	push	r12
     328:	df 92       	push	r13
     32a:	ef 92       	push	r14
     32c:	0f 93       	push	r16
     32e:	1f 93       	push	r17
     330:	df 93       	push	r29
     332:	cf 93       	push	r28
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:107

#if (SYSCFG_TASKMODEL_THREADS)
	//taskStack_ptr = (osStackThing_t *)
	//		&uctestTaskStack[((TEST_OS_STACK_SIZE) - sizeof(osStackThing_t))];

	xTaskCreateStatic( testOsTask, "TEST", TEST_OS_STACK_SIZE, NULL,
     338:	8d eb       	ldi	r24, 0xBD	; 189
     33a:	91 e0       	ldi	r25, 0x01	; 1
     33c:	21 e4       	ldi	r18, 0x41	; 65
     33e:	31 e0       	ldi	r19, 0x01	; 1
     340:	e2 e5       	ldi	r30, 0x52	; 82
     342:	f2 e0       	ldi	r31, 0x02	; 2
     344:	ad ea       	ldi	r26, 0xAD	; 173
     346:	b2 e0       	ldi	r27, 0x02	; 2
     348:	b9 01       	movw	r22, r18
     34a:	2b e5       	ldi	r18, 0x5B	; 91
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	40 e0       	ldi	r20, 0x00	; 0
     350:	50 e0       	ldi	r21, 0x00	; 0
     352:	00 e0       	ldi	r16, 0x00	; 0
     354:	10 e0       	ldi	r17, 0x00	; 0
     356:	0f 2e       	mov	r0, r31
     358:	f3 e0       	ldi	r31, 0x03	; 3
     35a:	ef 2e       	mov	r14, r31
     35c:	f0 2d       	mov	r31, r0
     35e:	6f 01       	movw	r12, r30
     360:	5d 01       	movw	r10, r26
     362:	0e 94 86 07 	call	0xf0c	; 0xf0c <xTaskCreateStatic>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:111
		TEST_TASK_PRIORITY, uctestTaskStack, &xtestTCBBuffer );
#endif

}
     366:	cf 91       	pop	r28
     368:	df 91       	pop	r29
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	ef 90       	pop	r14
     370:	df 90       	pop	r13
     372:	cf 90       	pop	r12
     374:	bf 90       	pop	r11
     376:	af 90       	pop	r10
     378:	08 95       	ret

0000037a <testOsTask>:
testOsTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:115

/*! OS task */
#if (SYSCFG_TASKMODEL_THREADS)
portTASK_FUNCTION( testOsTask, pvParameters ) {
     37a:	df 93       	push	r29
     37c:	cf 93       	push	r28
     37e:	00 d0       	rcall	.+0      	; 0x380 <testOsTask+0x6>
     380:	cd b7       	in	r28, 0x3d	; 61
     382:	de b7       	in	r29, 0x3e	; 62
     384:	9a 83       	std	Y+2, r25	; 0x02
     386:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:118

	for (;;) {
		testTimePeriod = timer1MeasureTimeElapsed(T1ID_SYS);
     388:	80 e0       	ldi	r24, 0x00	; 0
     38a:	0e 94 04 04 	call	0x808	; 0x808 <timer1MeasureTimeElapsed>
     38e:	90 93 2c 02 	sts	0x022C, r25
     392:	80 93 2b 02 	sts	0x022B, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:120
		//testPeriodicTask();
		testThread();
     396:	0e 94 63 02 	call	0x4c6	; 0x4c6 <testThread>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:121
		testStackLeft = uxTaskGetStackHighWaterMark(NULL);
     39a:	80 e0       	ldi	r24, 0x00	; 0
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxTaskGetStackHighWaterMark>
     3a2:	80 93 d5 02 	sts	0x02D5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:122
		vTaskDelay(TEST_PERIOD_TKS);
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	0e 94 1e 0a 	call	0x143c	; 0x143c <vTaskDelay>
     3ae:	ec cf       	rjmp	.-40     	; 0x388 <testOsTask+0xe>

000003b0 <testPeriodicTask>:
testPeriodicTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:129
}

#endif

/*!	periodic task */
void testPeriodicTask (void) {
     3b0:	df 93       	push	r29
     3b2:	cf 93       	push	r28
     3b4:	00 d0       	rcall	.+0      	; 0x3b6 <testPeriodicTask+0x6>
     3b6:	cd b7       	in	r28, 0x3d	; 61
     3b8:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:132

	//(void)timer1MeasureTime2Elapsed();
	timer1MeasureTime2Start(); // measure time a task takes {
     3ba:	0e 94 49 04 	call	0x892	; 0x892 <timer1MeasureTime2Start>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:134

	switch (testControl) {
     3be:	80 91 2e 02 	lds	r24, 0x022E
     3c2:	90 91 2f 02 	lds	r25, 0x022F
     3c6:	9a 83       	std	Y+2, r25	; 0x02
     3c8:	89 83       	std	Y+1, r24	; 0x01
     3ca:	89 81       	ldd	r24, Y+1	; 0x01
     3cc:	9a 81       	ldd	r25, Y+2	; 0x02
     3ce:	81 30       	cpi	r24, 0x01	; 1
     3d0:	91 05       	cpc	r25, r1
     3d2:	81 f0       	breq	.+32     	; 0x3f4 <testPeriodicTask+0x44>
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	9a 81       	ldd	r25, Y+2	; 0x02
     3d8:	82 30       	cpi	r24, 0x02	; 2
     3da:	91 05       	cpc	r25, r1
     3dc:	6c f1       	brlt	.+90     	; 0x438 <testPeriodicTask+0x88>
     3de:	89 81       	ldd	r24, Y+1	; 0x01
     3e0:	9a 81       	ldd	r25, Y+2	; 0x02
     3e2:	82 30       	cpi	r24, 0x02	; 2
     3e4:	91 05       	cpc	r25, r1
     3e6:	b1 f0       	breq	.+44     	; 0x414 <testPeriodicTask+0x64>
     3e8:	89 81       	ldd	r24, Y+1	; 0x01
     3ea:	9a 81       	ldd	r25, Y+2	; 0x02
     3ec:	83 30       	cpi	r24, 0x03	; 3
     3ee:	91 05       	cpc	r25, r1
     3f0:	09 f1       	breq	.+66     	; 0x434 <testPeriodicTask+0x84>
     3f2:	22 c0       	rjmp	.+68     	; 0x438 <testPeriodicTask+0x88>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:140
	case TEST_NONE :
		// do nothing
		break;
	case TEST_UART_RECEIVE:
		#if SYSCFG_TASKMODEL_THREADS
		dioSetLED0(); // test running
     3f4:	0e 94 74 00 	call	0xe8	; 0xe8 <dioSetLED0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:142
		#endif
		testCallStatus = uartRxRead(testUartString, &testStringSize);
     3f8:	81 e2       	ldi	r24, 0x21	; 33
     3fa:	91 e0       	ldi	r25, 0x01	; 1
     3fc:	2d e2       	ldi	r18, 0x2D	; 45
     3fe:	32 e0       	ldi	r19, 0x02	; 2
     400:	b9 01       	movw	r22, r18
     402:	0e 94 c6 05 	call	0xb8c	; 0xb8c <uartRxRead>
     406:	88 2f       	mov	r24, r24
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	90 93 31 02 	sts	0x0231, r25
     40e:	80 93 30 02 	sts	0x0230, r24
     412:	12 c0       	rjmp	.+36     	; 0x438 <testPeriodicTask+0x88>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:146
		break;
	case TEST_UART_SEND:
		#if SYSCFG_TASKMODEL_THREADS
		dioSetLED0(); // test running
     414:	0e 94 74 00 	call	0xe8	; 0xe8 <dioSetLED0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:148
		#endif
		testCallStatus = uartTxWrite(testUartString, &testStringSize);
     418:	81 e2       	ldi	r24, 0x21	; 33
     41a:	91 e0       	ldi	r25, 0x01	; 1
     41c:	2d e2       	ldi	r18, 0x2D	; 45
     41e:	32 e0       	ldi	r19, 0x02	; 2
     420:	b9 01       	movw	r22, r18
     422:	0e 94 54 06 	call	0xca8	; 0xca8 <uartTxWrite>
     426:	88 2f       	mov	r24, r24
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	90 93 31 02 	sts	0x0231, r25
     42e:	80 93 30 02 	sts	0x0230, r24
     432:	02 c0       	rjmp	.+4      	; 0x438 <testPeriodicTask+0x88>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:151
		break;
	case TEST_COMMAND:
		testCommandPeriodic();
     434:	0e 94 9f 02 	call	0x53e	; 0x53e <testCommandPeriodic>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:155
		break;
	}

	testTime = timer1MeasureTime2Elapsed_uS(); // }
     438:	0e 94 81 04 	call	0x902	; 0x902 <timer1MeasureTime2Elapsed_uS>
     43c:	dc 01       	movw	r26, r24
     43e:	cb 01       	movw	r24, r22
     440:	80 93 27 02 	sts	0x0227, r24
     444:	90 93 28 02 	sts	0x0228, r25
     448:	a0 93 29 02 	sts	0x0229, r26
     44c:	b0 93 2a 02 	sts	0x022A, r27
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:157
	
	if (TEST_NONE != testControl) {
     450:	80 91 2e 02 	lds	r24, 0x022E
     454:	90 91 2f 02 	lds	r25, 0x022F
     458:	00 97       	sbiw	r24, 0x00	; 0
     45a:	19 f1       	breq	.+70     	; 0x4a2 <testPeriodicTask+0xf2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:158
		if (CALL_OK == testCallStatus) {
     45c:	80 91 30 02 	lds	r24, 0x0230
     460:	90 91 31 02 	lds	r25, 0x0231
     464:	00 97       	sbiw	r24, 0x00	; 0
     466:	19 f4       	brne	.+6      	; 0x46e <testPeriodicTask+0xbe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:160
			#if SYSCFG_TASKMODEL_THREADS
			dioClearLED0();
     468:	0e 94 7c 00 	call	0xf8	; 0xf8 <dioClearLED0>
     46c:	1a c0       	rjmp	.+52     	; 0x4a2 <testPeriodicTask+0xf2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:166
			//testControl++;
			#else // SYSCFG_TASKMODEL_POLLING
			dioSetLED0(); // test running
			#endif
		}
		else if (CALL_PROCCESS_COMPLETE == testCallStatus) {
     46e:	80 91 30 02 	lds	r24, 0x0230
     472:	90 91 31 02 	lds	r25, 0x0231
     476:	83 30       	cpi	r24, 0x03	; 3
     478:	91 05       	cpc	r25, r1
     47a:	19 f4       	brne	.+6      	; 0x482 <testPeriodicTask+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:172
			#if SYSCFG_TASKMODEL_THREADS
			//testControl = 0; // error ?
			#else // SYSCFG_TASKMODEL_POLLING
			//testControl++;
			#endif
			dioClearLED0();
     47c:	0e 94 7c 00 	call	0xf8	; 0xf8 <dioClearLED0>
     480:	10 c0       	rjmp	.+32     	; 0x4a2 <testPeriodicTask+0xf2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:174
		}
		else if (CALL_BUSY == testCallStatus) {
     482:	80 91 30 02 	lds	r24, 0x0230
     486:	90 91 31 02 	lds	r25, 0x0231
     48a:	82 30       	cpi	r24, 0x02	; 2
     48c:	91 05       	cpc	r25, r1
     48e:	19 f4       	brne	.+6      	; 0x496 <testPeriodicTask+0xe6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:177
			#if SYSCFG_TASKMODEL_THREADS
			//testControl = 0; // error ?
			dioClearLED0();
     490:	0e 94 7c 00 	call	0xf8	; 0xf8 <dioClearLED0>
     494:	06 c0       	rjmp	.+12     	; 0x4a2 <testPeriodicTask+0xf2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:183
			#else // SYSCFG_TASKMODEL_POLLING
			dioSetLED0(); // still polling
			#endif
		}
		else {
			testControl = 0; // error ?
     496:	10 92 2f 02 	sts	0x022F, r1
     49a:	10 92 2e 02 	sts	0x022E, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:184
			dioClearLED0();
     49e:	0e 94 7c 00 	call	0xf8	; 0xf8 <dioClearLED0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:188
		}
	}

	if (testControl >=  TEST_MAX) {
     4a2:	80 91 2e 02 	lds	r24, 0x022E
     4a6:	90 91 2f 02 	lds	r25, 0x022F
     4aa:	84 30       	cpi	r24, 0x04	; 4
     4ac:	91 05       	cpc	r25, r1
     4ae:	34 f0       	brlt	.+12     	; 0x4bc <testPeriodicTask+0x10c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:189
		dioClearLED0(); // no test running
     4b0:	0e 94 7c 00 	call	0xf8	; 0xf8 <dioClearLED0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:190
		testControl = 0;
     4b4:	10 92 2f 02 	sts	0x022F, r1
     4b8:	10 92 2e 02 	sts	0x022E, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:192
	}
}
     4bc:	0f 90       	pop	r0
     4be:	0f 90       	pop	r0
     4c0:	cf 91       	pop	r28
     4c2:	df 91       	pop	r29
     4c4:	08 95       	ret

000004c6 <testThread>:
testThread():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:197


/*!	run a test according to character received over UART. Shows how to use rx
	and tx in practice (thread model) */
static void testThread (void) {
     4c6:	df 93       	push	r29
     4c8:	cf 93       	push	r28
     4ca:	00 d0       	rcall	.+0      	; 0x4cc <testThread+0x6>
     4cc:	cd b7       	in	r28, 0x3d	; 61
     4ce:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:198
	unsigned char command_rx_size = 1;
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:202
	callStatus_t call_result;

	// waiting for new command
	call_result = uartRxRead(&testInCommand, &command_rx_size);
     4d4:	85 e2       	ldi	r24, 0x25	; 37
     4d6:	92 e0       	ldi	r25, 0x02	; 2
     4d8:	9e 01       	movw	r18, r28
     4da:	2e 5f       	subi	r18, 0xFE	; 254
     4dc:	3f 4f       	sbci	r19, 0xFF	; 255
     4de:	b9 01       	movw	r22, r18
     4e0:	0e 94 c6 05 	call	0xb8c	; 0xb8c <uartRxRead>
     4e4:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:204

	if (CALL_OK != call_result) {
     4e6:	89 81       	ldd	r24, Y+1	; 0x01
     4e8:	88 23       	and	r24, r24
     4ea:	71 f0       	breq	.+28     	; 0x508 <testThread+0x42>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:206
		//give error feedback over serial
		strncpy(testOutDataBuffer, "error: ", 7);
     4ec:	82 e3       	ldi	r24, 0x32	; 50
     4ee:	92 e0       	ldi	r25, 0x02	; 2
     4f0:	26 e4       	ldi	r18, 0x46	; 70
     4f2:	31 e0       	ldi	r19, 0x01	; 1
     4f4:	b9 01       	movw	r22, r18
     4f6:	47 e0       	ldi	r20, 0x07	; 7
     4f8:	50 e0       	ldi	r21, 0x00	; 0
     4fa:	0e 94 1f 23 	call	0x463e	; 0x463e <memcpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:207
		testOutDataBuffer[7] = (call_result + 0x30);
     4fe:	89 81       	ldd	r24, Y+1	; 0x01
     500:	80 5d       	subi	r24, 0xD0	; 208
     502:	80 93 39 02 	sts	0x0239, r24
     506:	09 c0       	rjmp	.+18     	; 0x51a <testThread+0x54>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:210
	}
	else {
		testOutDataSize = testDataGet(testInCommand, testOutDataBuffer);
     508:	80 91 25 02 	lds	r24, 0x0225
     50c:	22 e3       	ldi	r18, 0x32	; 50
     50e:	32 e0       	ldi	r19, 0x02	; 2
     510:	b9 01       	movw	r22, r18
     512:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <testDataGet>
     516:	80 93 26 02 	sts	0x0226, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:213
	}

	call_result = uartTxWrite(testOutDataBuffer, &testOutDataSize);
     51a:	82 e3       	ldi	r24, 0x32	; 50
     51c:	92 e0       	ldi	r25, 0x02	; 2
     51e:	26 e2       	ldi	r18, 0x26	; 38
     520:	32 e0       	ldi	r19, 0x02	; 2
     522:	b9 01       	movw	r22, r18
     524:	0e 94 54 06 	call	0xca8	; 0xca8 <uartTxWrite>
     528:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:215

	if (CALL_OK != call_result) {
     52a:	89 81       	ldd	r24, Y+1	; 0x01
     52c:	88 23       	and	r24, r24
     52e:	11 f0       	breq	.+4      	; 0x534 <testThread+0x6e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:217
		//give error feedback, can't even communicate
		dioSetLED0();
     530:	0e 94 74 00 	call	0xe8	; 0xe8 <dioSetLED0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:221
	}

	return;
}
     534:	0f 90       	pop	r0
     536:	0f 90       	pop	r0
     538:	cf 91       	pop	r28
     53a:	df 91       	pop	r29
     53c:	08 95       	ret

0000053e <testCommandPeriodic>:
testCommandPeriodic():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:225

/*!	run a test according to character received over UART. Shows how to use rx
	and tx in practice (polling model) */
static void testCommandPeriodic(void) {
     53e:	df 93       	push	r29
     540:	cf 93       	push	r28
     542:	00 d0       	rcall	.+0      	; 0x544 <testCommandPeriodic+0x6>
     544:	cd b7       	in	r28, 0x3d	; 61
     546:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:226
	unsigned char command_rx_size = 1;
     548:	81 e0       	ldi	r24, 0x01	; 1
     54a:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:227
	callStatus_t call_result = 0;
     54c:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:229

	if (0 == testInCommand)
     54e:	80 91 25 02 	lds	r24, 0x0225
     552:	88 23       	and	r24, r24
     554:	51 f4       	brne	.+20     	; 0x56a <testCommandPeriodic+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:232
	{
		// waiting for new command
		call_result = uartRxRead(&testInCommand, &command_rx_size);
     556:	85 e2       	ldi	r24, 0x25	; 37
     558:	92 e0       	ldi	r25, 0x02	; 2
     55a:	9e 01       	movw	r18, r28
     55c:	2e 5f       	subi	r18, 0xFE	; 254
     55e:	3f 4f       	sbci	r19, 0xFF	; 255
     560:	b9 01       	movw	r22, r18
     562:	0e 94 c6 05 	call	0xb8c	; 0xb8c <uartRxRead>
     566:	89 83       	std	Y+1, r24	; 0x01
     568:	0a c0       	rjmp	.+20     	; 0x57e <testCommandPeriodic+0x40>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:235
	}
	else {
		call_result = uartTxWrite(testOutDataBuffer, &testOutDataSize);
     56a:	82 e3       	ldi	r24, 0x32	; 50
     56c:	92 e0       	ldi	r25, 0x02	; 2
     56e:	26 e2       	ldi	r18, 0x26	; 38
     570:	32 e0       	ldi	r19, 0x02	; 2
     572:	b9 01       	movw	r22, r18
     574:	0e 94 54 06 	call	0xca8	; 0xca8 <uartTxWrite>
     578:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:236
		testInCommand = 0;
     57a:	10 92 25 02 	sts	0x0225, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:239
	}

	switch (call_result) {
     57e:	89 81       	ldd	r24, Y+1	; 0x01
     580:	88 2f       	mov	r24, r24
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	00 97       	sbiw	r24, 0x00	; 0
     586:	81 f4       	brne	.+32     	; 0x5a8 <testCommandPeriodic+0x6a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:249
#if SYSCFG_TASKMODEL_POLLING
		//wait till CALL_PROCCESS_COMPLETE
		break;
	case CALL_PROCCESS_COMPLETE:
#endif
		if (0 == testOutDataSize) {
     588:	80 91 26 02 	lds	r24, 0x0226
     58c:	88 23       	and	r24, r24
     58e:	51 f4       	brne	.+20     	; 0x5a4 <testCommandPeriodic+0x66>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:252
			// command received, prepare data to transmit
			//now we can read back the command received
			testOutDataSize = testDataGet(testInCommand, testOutDataBuffer);
     590:	80 91 25 02 	lds	r24, 0x0225
     594:	22 e3       	ldi	r18, 0x32	; 50
     596:	32 e0       	ldi	r19, 0x02	; 2
     598:	b9 01       	movw	r22, r18
     59a:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <testDataGet>
     59e:	80 93 26 02 	sts	0x0226, r24
     5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <testCommandPeriodic+0x6a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:256
		}
		else {
			// data transmit done
			testOutDataSize = 0;
     5a4:	10 92 26 02 	sts	0x0226, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:265
		//error
		break;
	}

	return;
}
     5a8:	0f 90       	pop	r0
     5aa:	0f 90       	pop	r0
     5ac:	cf 91       	pop	r28
     5ae:	df 91       	pop	r29
     5b0:	08 95       	ret

000005b2 <testDataGet>:
testDataGet():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:268

static unsigned char testDataGet
(uartDataFrame_t const test_command, uartDataFrame_t * const buffer_ptr) {
     5b2:	df 93       	push	r29
     5b4:	cf 93       	push	r28
     5b6:	cd b7       	in	r28, 0x3d	; 61
     5b8:	de b7       	in	r29, 0x3e	; 62
     5ba:	27 97       	sbiw	r28, 0x07	; 7
     5bc:	0f b6       	in	r0, 0x3f	; 63
     5be:	f8 94       	cli
     5c0:	de bf       	out	0x3e, r29	; 62
     5c2:	0f be       	out	0x3f, r0	; 63
     5c4:	cd bf       	out	0x3d, r28	; 61
     5c6:	8b 83       	std	Y+3, r24	; 0x03
     5c8:	7d 83       	std	Y+5, r23	; 0x05
     5ca:	6c 83       	std	Y+4, r22	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:269
	unsigned char buffer_size_ret = 0;
     5cc:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:272
	char idx;

	switch (test_command) {
     5ce:	8b 81       	ldd	r24, Y+3	; 0x03
     5d0:	28 2f       	mov	r18, r24
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	3f 83       	std	Y+7, r19	; 0x07
     5d6:	2e 83       	std	Y+6, r18	; 0x06
     5d8:	8e 81       	ldd	r24, Y+6	; 0x06
     5da:	9f 81       	ldd	r25, Y+7	; 0x07
     5dc:	83 36       	cpi	r24, 0x63	; 99
     5de:	91 05       	cpc	r25, r1
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <testDataGet+0x32>
     5e2:	43 c0       	rjmp	.+134    	; 0x66a <testDataGet+0xb8>
     5e4:	2e 81       	ldd	r18, Y+6	; 0x06
     5e6:	3f 81       	ldd	r19, Y+7	; 0x07
     5e8:	24 36       	cpi	r18, 0x64	; 100
     5ea:	31 05       	cpc	r19, r1
     5ec:	5c f4       	brge	.+22     	; 0x604 <testDataGet+0x52>
     5ee:	8e 81       	ldd	r24, Y+6	; 0x06
     5f0:	9f 81       	ldd	r25, Y+7	; 0x07
     5f2:	81 36       	cpi	r24, 0x61	; 97
     5f4:	91 05       	cpc	r25, r1
     5f6:	91 f0       	breq	.+36     	; 0x61c <testDataGet+0x6a>
     5f8:	2e 81       	ldd	r18, Y+6	; 0x06
     5fa:	3f 81       	ldd	r19, Y+7	; 0x07
     5fc:	22 36       	cpi	r18, 0x62	; 98
     5fe:	31 05       	cpc	r19, r1
     600:	c9 f0       	breq	.+50     	; 0x634 <testDataGet+0x82>
     602:	56 c0       	rjmp	.+172    	; 0x6b0 <testDataGet+0xfe>
     604:	8e 81       	ldd	r24, Y+6	; 0x06
     606:	9f 81       	ldd	r25, Y+7	; 0x07
     608:	84 36       	cpi	r24, 0x64	; 100
     60a:	91 05       	cpc	r25, r1
     60c:	d1 f1       	breq	.+116    	; 0x682 <testDataGet+0xd0>
     60e:	2e 81       	ldd	r18, Y+6	; 0x06
     610:	3f 81       	ldd	r19, Y+7	; 0x07
     612:	25 36       	cpi	r18, 0x65	; 101
     614:	31 05       	cpc	r19, r1
     616:	09 f4       	brne	.+2      	; 0x61a <testDataGet+0x68>
     618:	40 c0       	rjmp	.+128    	; 0x69a <testDataGet+0xe8>
     61a:	4a c0       	rjmp	.+148    	; 0x6b0 <testDataGet+0xfe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:275
	case 'a':
		// just to test this setup works
		memcpy((void*) buffer_ptr, (void*)testUartString, TEST_STRING_SIZE_MAX);
     61c:	8c 81       	ldd	r24, Y+4	; 0x04
     61e:	9d 81       	ldd	r25, Y+5	; 0x05
     620:	21 e2       	ldi	r18, 0x21	; 33
     622:	31 e0       	ldi	r19, 0x01	; 1
     624:	b9 01       	movw	r22, r18
     626:	40 e2       	ldi	r20, 0x20	; 32
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	0e 94 1f 23 	call	0x463e	; 0x463e <memcpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:276
		buffer_size_ret = TEST_STRING_SIZE_MAX;
     62e:	80 e2       	ldi	r24, 0x20	; 32
     630:	8a 83       	std	Y+2, r24	; 0x02
     632:	3e c0       	rjmp	.+124    	; 0x6b0 <testDataGet+0xfe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:280
		break;
	case 'b':
		// rule out memcpy? use debug to set buffer_size_ret to 32
		for (idx = 0; idx < TEST_STRING_SIZE_MAX; idx++)
     634:	19 82       	std	Y+1, r1	; 0x01
     636:	13 c0       	rjmp	.+38     	; 0x65e <testDataGet+0xac>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:281
			buffer_ptr[idx] = testUartString[idx];
     638:	89 81       	ldd	r24, Y+1	; 0x01
     63a:	28 2f       	mov	r18, r24
     63c:	30 e0       	ldi	r19, 0x00	; 0
     63e:	8c 81       	ldd	r24, Y+4	; 0x04
     640:	9d 81       	ldd	r25, Y+5	; 0x05
     642:	dc 01       	movw	r26, r24
     644:	a2 0f       	add	r26, r18
     646:	b3 1f       	adc	r27, r19
     648:	89 81       	ldd	r24, Y+1	; 0x01
     64a:	88 2f       	mov	r24, r24
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	fc 01       	movw	r30, r24
     650:	ef 5d       	subi	r30, 0xDF	; 223
     652:	fe 4f       	sbci	r31, 0xFE	; 254
     654:	80 81       	ld	r24, Z
     656:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:280
		memcpy((void*) buffer_ptr, (void*)testUartString, TEST_STRING_SIZE_MAX);
		buffer_size_ret = TEST_STRING_SIZE_MAX;
		break;
	case 'b':
		// rule out memcpy? use debug to set buffer_size_ret to 32
		for (idx = 0; idx < TEST_STRING_SIZE_MAX; idx++)
     658:	89 81       	ldd	r24, Y+1	; 0x01
     65a:	8f 5f       	subi	r24, 0xFF	; 255
     65c:	89 83       	std	Y+1, r24	; 0x01
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	80 32       	cpi	r24, 0x20	; 32
     662:	50 f3       	brcs	.-44     	; 0x638 <testDataGet+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:282
			buffer_ptr[idx] = testUartString[idx];
		buffer_size_ret = idx;
     664:	89 81       	ldd	r24, Y+1	; 0x01
     666:	8a 83       	std	Y+2, r24	; 0x02
     668:	23 c0       	rjmp	.+70     	; 0x6b0 <testDataGet+0xfe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:286
		break;
	case 'c':
		//
		strncpy(buffer_ptr, versionAPP,  VERSION_STRING_SIZE);
     66a:	8c 81       	ldd	r24, Y+4	; 0x04
     66c:	9d 81       	ldd	r25, Y+5	; 0x05
     66e:	28 e6       	ldi	r18, 0x68	; 104
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	b9 01       	movw	r22, r18
     674:	49 e0       	ldi	r20, 0x09	; 9
     676:	50 e0       	ldi	r21, 0x00	; 0
     678:	0e 94 2f 23 	call	0x465e	; 0x465e <strncpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:287
		buffer_size_ret = VERSION_STRING_SIZE;
     67c:	89 e0       	ldi	r24, 0x09	; 9
     67e:	8a 83       	std	Y+2, r24	; 0x02
     680:	17 c0       	rjmp	.+46     	; 0x6b0 <testDataGet+0xfe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:291
		break;
	case 'd':
		//
		strncpy(buffer_ptr, versionRTOS,  VERSION_STRING_SIZE);
     682:	8c 81       	ldd	r24, Y+4	; 0x04
     684:	9d 81       	ldd	r25, Y+5	; 0x05
     686:	21 e7       	ldi	r18, 0x71	; 113
     688:	30 e0       	ldi	r19, 0x00	; 0
     68a:	b9 01       	movw	r22, r18
     68c:	49 e0       	ldi	r20, 0x09	; 9
     68e:	50 e0       	ldi	r21, 0x00	; 0
     690:	0e 94 2f 23 	call	0x465e	; 0x465e <strncpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:292
		buffer_size_ret = VERSION_STRING_SIZE;
     694:	89 e0       	ldi	r24, 0x09	; 9
     696:	8a 83       	std	Y+2, r24	; 0x02
     698:	0b c0       	rjmp	.+22     	; 0x6b0 <testDataGet+0xfe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:296
		break;
	case 'e':
		//testTimePeriod
		itoa(testTimePeriod, buffer_ptr);
     69a:	80 91 2b 02 	lds	r24, 0x022B
     69e:	90 91 2c 02 	lds	r25, 0x022C
     6a2:	2c 81       	ldd	r18, Y+4	; 0x04
     6a4:	3d 81       	ldd	r19, Y+5	; 0x05
     6a6:	b9 01       	movw	r22, r18
     6a8:	0e 94 3e 23 	call	0x467c	; 0x467c <itoa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:297
		buffer_size_ret = TEST_STRING_SIZE_MAX;
     6ac:	80 e2       	ldi	r24, 0x20	; 32
     6ae:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:304
	default:
		//do nothing for now
		break;
	}

	return buffer_size_ret;
     6b0:	8a 81       	ldd	r24, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/test.c:305
}
     6b2:	27 96       	adiw	r28, 0x07	; 7
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	f8 94       	cli
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	cd bf       	out	0x3d, r28	; 61
     6be:	cf 91       	pop	r28
     6c0:	df 91       	pop	r29
     6c2:	08 95       	ret

000006c4 <timer0Init>:
timer0Init():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:61
#endif

/*	public functions	*/

/*!	init */
void timer0Init (void) {
     6c4:	df 93       	push	r29
     6c6:	cf 93       	push	r28
     6c8:	cd b7       	in	r28, 0x3d	; 61
     6ca:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:64
	// no OC0A out, no OC0B out,

	TCCR0A = T0REG_CLEAR_ON_COMPARE;
     6cc:	e4 e4       	ldi	r30, 0x44	; 68
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
     6d0:	82 e0       	ldi	r24, 0x02	; 2
     6d2:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:66

	TCCR0B = T0REG_CLK_DIV_1024;
     6d4:	e5 e4       	ldi	r30, 0x45	; 69
     6d6:	f0 e0       	ldi	r31, 0x00	; 0
     6d8:	85 e0       	ldi	r24, 0x05	; 5
     6da:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:68

	OCR0A = T0REG_COUNT_8ms;
     6dc:	e7 e4       	ldi	r30, 0x47	; 71
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	8d e7       	ldi	r24, 0x7D	; 125
     6e2:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:70

	OCR0B = 0U;
     6e4:	e8 e4       	ldi	r30, 0x48	; 72
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:72

	TIMSK0 = T0REG_ENABLE_COMPARE_A_ISR; // SYSCFG_LL_CONTAINED_ISR en or SYSCFG_TASKMODEL_THREADS, do we need the ISR?
     6ea:	ee e6       	ldi	r30, 0x6E	; 110
     6ec:	f0 e0       	ldi	r31, 0x00	; 0
     6ee:	82 e0       	ldi	r24, 0x02	; 2
     6f0:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:74

	TIFR0 = T0REG_CLEAR_ISR;
     6f2:	e5 e3       	ldi	r30, 0x35	; 53
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	83 e0       	ldi	r24, 0x03	; 3
     6f8:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:76

	TCNT0 = 0U;
     6fa:	e6 e4       	ldi	r30, 0x46	; 70
     6fc:	f0 e0       	ldi	r31, 0x00	; 0
     6fe:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:77
}
     700:	cf 91       	pop	r28
     702:	df 91       	pop	r29
     704:	08 95       	ret

00000706 <timer0SetHz>:
timer0SetHz():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:81

/*	getters/setters	*/

callStatus_t const timer0SetHz (unsigned int hertz) {
     706:	df 93       	push	r29
     708:	cf 93       	push	r28
     70a:	cd b7       	in	r28, 0x3d	; 61
     70c:	de b7       	in	r29, 0x3e	; 62
     70e:	28 97       	sbiw	r28, 0x08	; 8
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	de bf       	out	0x3e, r29	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	cd bf       	out	0x3d, r28	; 61
     71a:	98 87       	std	Y+8, r25	; 0x08
     71c:	8f 83       	std	Y+7, r24	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:82
	callStatus_t return_result = CALL_BAD_ARG;
     71e:	81 e0       	ldi	r24, 0x01	; 1
     720:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:84
	unsigned char setting_idx;
	unsigned int clock_counts = 0;
     722:	1a 82       	std	Y+2, r1	; 0x02
     724:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:85
	registerByte_t tccr0b_reg = 0;
     726:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:86
	registerByte_t ocr0a_reg = 0;
     728:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:88

	if (0 < hertz) {
     72a:	8f 81       	ldd	r24, Y+7	; 0x07
     72c:	98 85       	ldd	r25, Y+8	; 0x08
     72e:	00 97       	sbiw	r24, 0x00	; 0
     730:	09 f4       	brne	.+2      	; 0x734 <timer0SetHz+0x2e>
     732:	41 c0       	rjmp	.+130    	; 0x7b6 <timer0SetHz+0xb0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:89
		clock_counts = CLK_FREQ_HZ()/hertz;
     734:	8f 81       	ldd	r24, Y+7	; 0x07
     736:	98 85       	ldd	r25, Y+8	; 0x08
     738:	9c 01       	movw	r18, r24
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	80 e0       	ldi	r24, 0x00	; 0
     740:	94 e2       	ldi	r25, 0x24	; 36
     742:	a4 ef       	ldi	r26, 0xF4	; 244
     744:	b0 e0       	ldi	r27, 0x00	; 0
     746:	bc 01       	movw	r22, r24
     748:	cd 01       	movw	r24, r26
     74a:	0e 94 fd 22 	call	0x45fa	; 0x45fa <__udivmodsi4>
     74e:	da 01       	movw	r26, r20
     750:	c9 01       	movw	r24, r18
     752:	9a 83       	std	Y+2, r25	; 0x02
     754:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:91

		setting_idx = 1;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:93
		do {
			if (clock_counts <= T0REG_COUNT_SIZE) {
     75a:	89 81       	ldd	r24, Y+1	; 0x01
     75c:	9a 81       	ldd	r25, Y+2	; 0x02
     75e:	21 e0       	ldi	r18, 0x01	; 1
     760:	81 30       	cpi	r24, 0x01	; 1
     762:	92 07       	cpc	r25, r18
     764:	c8 f0       	brcs	.+50     	; 0x798 <timer0SetHz+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:96
				break;
			}
			clock_counts >>= T0_CLK_SHIFT[setting_idx];
     766:	8b 81       	ldd	r24, Y+3	; 0x03
     768:	88 2f       	mov	r24, r24
     76a:	90 e0       	ldi	r25, 0x00	; 0
     76c:	fc 01       	movw	r30, r24
     76e:	ec 5a       	subi	r30, 0xAC	; 172
     770:	fe 4f       	sbci	r31, 0xFE	; 254
     772:	80 81       	ld	r24, Z
     774:	28 2f       	mov	r18, r24
     776:	30 e0       	ldi	r19, 0x00	; 0
     778:	89 81       	ldd	r24, Y+1	; 0x01
     77a:	9a 81       	ldd	r25, Y+2	; 0x02
     77c:	02 2e       	mov	r0, r18
     77e:	02 c0       	rjmp	.+4      	; 0x784 <timer0SetHz+0x7e>
     780:	96 95       	lsr	r25
     782:	87 95       	ror	r24
     784:	0a 94       	dec	r0
     786:	e2 f7       	brpl	.-8      	; 0x780 <timer0SetHz+0x7a>
     788:	9a 83       	std	Y+2, r25	; 0x02
     78a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:97
			setting_idx++;
     78c:	8b 81       	ldd	r24, Y+3	; 0x03
     78e:	8f 5f       	subi	r24, 0xFF	; 255
     790:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:98
		} while (setting_idx < T0_CLK_SETTINGS);
     792:	8b 81       	ldd	r24, Y+3	; 0x03
     794:	86 30       	cpi	r24, 0x06	; 6
     796:	08 f3       	brcs	.-62     	; 0x75a <timer0SetHz+0x54>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:100

		if (setting_idx != T0_CLK_SETTINGS) {
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	86 30       	cpi	r24, 0x06	; 6
     79c:	61 f0       	breq	.+24     	; 0x7b6 <timer0SetHz+0xb0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:101
			tccr0b_reg = T0REG_CLK_DIV[setting_idx];
     79e:	8b 81       	ldd	r24, Y+3	; 0x03
     7a0:	88 2f       	mov	r24, r24
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	fc 01       	movw	r30, r24
     7a6:	e2 5b       	subi	r30, 0xB2	; 178
     7a8:	fe 4f       	sbci	r31, 0xFE	; 254
     7aa:	80 81       	ld	r24, Z
     7ac:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:102
			ocr0a_reg = (clock_counts - 1);
     7ae:	89 81       	ldd	r24, Y+1	; 0x01
     7b0:	81 50       	subi	r24, 0x01	; 1
     7b2:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:104

			return_result = CALL_OK;
     7b4:	1c 82       	std	Y+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:108
		}
	}

	TCCR0B = tccr0b_reg;
     7b6:	e5 e4       	ldi	r30, 0x45	; 69
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	8d 81       	ldd	r24, Y+5	; 0x05
     7bc:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:109
	OCR0A = ocr0a_reg;
     7be:	e7 e4       	ldi	r30, 0x47	; 71
     7c0:	f0 e0       	ldi	r31, 0x00	; 0
     7c2:	8e 81       	ldd	r24, Y+6	; 0x06
     7c4:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:111

	return (return_result);
     7c6:	8c 81       	ldd	r24, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer0.c:112
}
     7c8:	28 96       	adiw	r28, 0x08	; 8
     7ca:	0f b6       	in	r0, 0x3f	; 63
     7cc:	f8 94       	cli
     7ce:	de bf       	out	0x3e, r29	; 62
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	cd bf       	out	0x3d, r28	; 61
     7d4:	cf 91       	pop	r28
     7d6:	df 91       	pop	r29
     7d8:	08 95       	ret

000007da <timer1Init>:
timer1Init():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:56
static uint16_t captureTime2;

/*	public functions	*/

/*!	init */
void timer1Init (void) {
     7da:	df 93       	push	r29
     7dc:	cf 93       	push	r28
     7de:	cd b7       	in	r28, 0x3d	; 61
     7e0:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:58
	// normal timer/counter operation with 0xFFFF as max
	TCCR1A = 0; // COM1A#/COM1B# normal port operation
     7e2:	e0 e8       	ldi	r30, 0x80	; 128
     7e4:	f0 e0       	ldi	r31, 0x00	; 0
     7e6:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:60

	TCCR1B = (0 << ICES1) // trigger on down edge
     7e8:	e1 e8       	ldi	r30, 0x81	; 129
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	81 e0       	ldi	r24, 0x01	; 1
     7ee:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:63
		| (0x01 << CS10); // main clock, no prescaler, so 16MHz
	
	TCCR1C = 0;
     7f0:	e2 e8       	ldi	r30, 0x82	; 130
     7f2:	f0 e0       	ldi	r31, 0x00	; 0
     7f4:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:65

	TCNT1H = 0;
     7f6:	e5 e8       	ldi	r30, 0x85	; 133
     7f8:	f0 e0       	ldi	r31, 0x00	; 0
     7fa:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:66
	TCNT1L = 0;
     7fc:	e4 e8       	ldi	r30, 0x84	; 132
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:72

	// OCR1AH OCR1AL OCR1BH OCR1BL

	// no timer1 interrupt
	//TIMSK1 = (1 << ICIE1); // timer 1 input capture interrupt enable
}
     802:	cf 91       	pop	r28
     804:	df 91       	pop	r29
     806:	08 95       	ret

00000808 <timer1MeasureTimeElapsed>:
timer1MeasureTimeElapsed():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:76

/*	getters/setters	*/

uint16_t timer1MeasureTimeElapsed (t1MeasureleId_t id) {
     808:	df 93       	push	r29
     80a:	cf 93       	push	r28
     80c:	00 d0       	rcall	.+0      	; 0x80e <timer1MeasureTimeElapsed+0x6>
     80e:	00 d0       	rcall	.+0      	; 0x810 <timer1MeasureTimeElapsed+0x8>
     810:	0f 92       	push	r0
     812:	cd b7       	in	r28, 0x3d	; 61
     814:	de b7       	in	r29, 0x3e	; 62
     816:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:78
	registerWord_t prev_capture_time;
	uint16_t time_passed = 0xFFFFu;
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	9f ef       	ldi	r25, 0xFF	; 255
     81c:	9a 83       	std	Y+2, r25	; 0x02
     81e:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:80

	if (T1ID_MAX > id) {
     820:	8d 81       	ldd	r24, Y+5	; 0x05
     822:	82 30       	cpi	r24, 0x02	; 2
     824:	60 f5       	brcc	.+88     	; 0x87e <timer1MeasureTimeElapsed+0x76>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:81
		prev_capture_time = captureTime[id];
     826:	8d 81       	ldd	r24, Y+5	; 0x05
     828:	88 2f       	mov	r24, r24
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	fc 01       	movw	r30, r24
     832:	ea 52       	subi	r30, 0x2A	; 42
     834:	fd 4f       	sbci	r31, 0xFD	; 253
     836:	80 81       	ld	r24, Z
     838:	91 81       	ldd	r25, Z+1	; 0x01
     83a:	9c 83       	std	Y+4, r25	; 0x04
     83c:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:83

		captureTime[id] = TCNT1;
     83e:	8d 81       	ldd	r24, Y+5	; 0x05
     840:	88 2f       	mov	r24, r24
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	e4 e8       	ldi	r30, 0x84	; 132
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	20 81       	ld	r18, Z
     84a:	31 81       	ldd	r19, Z+1	; 0x01
     84c:	88 0f       	add	r24, r24
     84e:	99 1f       	adc	r25, r25
     850:	fc 01       	movw	r30, r24
     852:	ea 52       	subi	r30, 0x2A	; 42
     854:	fd 4f       	sbci	r31, 0xFD	; 253
     856:	31 83       	std	Z+1, r19	; 0x01
     858:	20 83       	st	Z, r18
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:85

		time_passed = captureTime[id] - prev_capture_time;
     85a:	8d 81       	ldd	r24, Y+5	; 0x05
     85c:	88 2f       	mov	r24, r24
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	88 0f       	add	r24, r24
     862:	99 1f       	adc	r25, r25
     864:	fc 01       	movw	r30, r24
     866:	ea 52       	subi	r30, 0x2A	; 42
     868:	fd 4f       	sbci	r31, 0xFD	; 253
     86a:	20 81       	ld	r18, Z
     86c:	31 81       	ldd	r19, Z+1	; 0x01
     86e:	8b 81       	ldd	r24, Y+3	; 0x03
     870:	9c 81       	ldd	r25, Y+4	; 0x04
     872:	a9 01       	movw	r20, r18
     874:	48 1b       	sub	r20, r24
     876:	59 0b       	sbc	r21, r25
     878:	ca 01       	movw	r24, r20
     87a:	9a 83       	std	Y+2, r25	; 0x02
     87c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:88
	}

	return (time_passed);
     87e:	89 81       	ldd	r24, Y+1	; 0x01
     880:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:89
}
     882:	0f 90       	pop	r0
     884:	0f 90       	pop	r0
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	0f 90       	pop	r0
     88c:	cf 91       	pop	r28
     88e:	df 91       	pop	r29
     890:	08 95       	ret

00000892 <timer1MeasureTime2Start>:
timer1MeasureTime2Start():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:91

void timer1MeasureTime2Start (void) {
     892:	df 93       	push	r29
     894:	cf 93       	push	r28
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:92
	captureTime2 = TCNT1;
     89a:	e4 e8       	ldi	r30, 0x84	; 132
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	80 81       	ld	r24, Z
     8a0:	91 81       	ldd	r25, Z+1	; 0x01
     8a2:	90 93 db 02 	sts	0x02DB, r25
     8a6:	80 93 da 02 	sts	0x02DA, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:93
}
     8aa:	cf 91       	pop	r28
     8ac:	df 91       	pop	r29
     8ae:	08 95       	ret

000008b0 <timer1MeasureTime2Elapsed>:
timer1MeasureTime2Elapsed():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:94
uint16_t timer1MeasureTime2Elapsed (void) {
     8b0:	df 93       	push	r29
     8b2:	cf 93       	push	r28
     8b4:	00 d0       	rcall	.+0      	; 0x8b6 <timer1MeasureTime2Elapsed+0x6>
     8b6:	00 d0       	rcall	.+0      	; 0x8b8 <timer1MeasureTime2Elapsed+0x8>
     8b8:	cd b7       	in	r28, 0x3d	; 61
     8ba:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:99
	//static uint16_t captureTime2;
	registerWord_t prev_capture_time;
	uint16_t time_passed;

	prev_capture_time = captureTime2;
     8bc:	80 91 da 02 	lds	r24, 0x02DA
     8c0:	90 91 db 02 	lds	r25, 0x02DB
     8c4:	9c 83       	std	Y+4, r25	; 0x04
     8c6:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:101

	captureTime2 = TCNT1;
     8c8:	e4 e8       	ldi	r30, 0x84	; 132
     8ca:	f0 e0       	ldi	r31, 0x00	; 0
     8cc:	80 81       	ld	r24, Z
     8ce:	91 81       	ldd	r25, Z+1	; 0x01
     8d0:	90 93 db 02 	sts	0x02DB, r25
     8d4:	80 93 da 02 	sts	0x02DA, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:103

	time_passed = captureTime2 - prev_capture_time;
     8d8:	20 91 da 02 	lds	r18, 0x02DA
     8dc:	30 91 db 02 	lds	r19, 0x02DB
     8e0:	8b 81       	ldd	r24, Y+3	; 0x03
     8e2:	9c 81       	ldd	r25, Y+4	; 0x04
     8e4:	a9 01       	movw	r20, r18
     8e6:	48 1b       	sub	r20, r24
     8e8:	59 0b       	sbc	r21, r25
     8ea:	ca 01       	movw	r24, r20
     8ec:	9a 83       	std	Y+2, r25	; 0x02
     8ee:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:105

	return (time_passed);
     8f0:	89 81       	ldd	r24, Y+1	; 0x01
     8f2:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:106
}
     8f4:	0f 90       	pop	r0
     8f6:	0f 90       	pop	r0
     8f8:	0f 90       	pop	r0
     8fa:	0f 90       	pop	r0
     8fc:	cf 91       	pop	r28
     8fe:	df 91       	pop	r29
     900:	08 95       	ret

00000902 <timer1MeasureTime2Elapsed_uS>:
timer1MeasureTime2Elapsed_uS():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:108

uint32_t timer1MeasureTime2Elapsed_uS (void) {
     902:	df 93       	push	r29
     904:	cf 93       	push	r28
     906:	00 d0       	rcall	.+0      	; 0x908 <timer1MeasureTime2Elapsed_uS+0x6>
     908:	00 d0       	rcall	.+0      	; 0x90a <timer1MeasureTime2Elapsed_uS+0x8>
     90a:	cd b7       	in	r28, 0x3d	; 61
     90c:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:109
	uint32_t counts = (uint32_t)timer1MeasureTime2Elapsed();
     90e:	0e 94 58 04 	call	0x8b0	; 0x8b0 <timer1MeasureTime2Elapsed>
     912:	cc 01       	movw	r24, r24
     914:	a0 e0       	ldi	r26, 0x00	; 0
     916:	b0 e0       	ldi	r27, 0x00	; 0
     918:	89 83       	std	Y+1, r24	; 0x01
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	ab 83       	std	Y+3, r26	; 0x03
     91e:	bc 83       	std	Y+4, r27	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:111

	counts = counts * (uint32_t)COUNT_uS;
     920:	89 81       	ldd	r24, Y+1	; 0x01
     922:	9a 81       	ldd	r25, Y+2	; 0x02
     924:	ab 81       	ldd	r26, Y+3	; 0x03
     926:	bc 81       	ldd	r27, Y+4	; 0x04
     928:	88 0f       	add	r24, r24
     92a:	99 1f       	adc	r25, r25
     92c:	aa 1f       	adc	r26, r26
     92e:	bb 1f       	adc	r27, r27
     930:	88 0f       	add	r24, r24
     932:	99 1f       	adc	r25, r25
     934:	aa 1f       	adc	r26, r26
     936:	bb 1f       	adc	r27, r27
     938:	89 83       	std	Y+1, r24	; 0x01
     93a:	9a 83       	std	Y+2, r25	; 0x02
     93c:	ab 83       	std	Y+3, r26	; 0x03
     93e:	bc 83       	std	Y+4, r27	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:113

	return (counts);
     940:	89 81       	ldd	r24, Y+1	; 0x01
     942:	9a 81       	ldd	r25, Y+2	; 0x02
     944:	ab 81       	ldd	r26, Y+3	; 0x03
     946:	bc 81       	ldd	r27, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/timer1.c:114
}
     948:	bc 01       	movw	r22, r24
     94a:	cd 01       	movw	r24, r26
     94c:	0f 90       	pop	r0
     94e:	0f 90       	pop	r0
     950:	0f 90       	pop	r0
     952:	0f 90       	pop	r0
     954:	cf 91       	pop	r28
     956:	df 91       	pop	r29
     958:	08 95       	ret

0000095a <uartInit>:
uartInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:137

/******************************************************************************/
/*	public functions	*/

/*!	initialize UART hardware	*/
void uartInit (void) {
     95a:	af 92       	push	r10
     95c:	bf 92       	push	r11
     95e:	cf 92       	push	r12
     960:	df 92       	push	r13
     962:	ef 92       	push	r14
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	df 93       	push	r29
     96a:	cf 93       	push	r28
     96c:	cd b7       	in	r28, 0x3d	; 61
     96e:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:139
	/* set baud rate */
	UBRR0H = UART_BAUD_UBRRH;
     970:	e5 ec       	ldi	r30, 0xC5	; 197
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:140
	UBRR0L = UART_BAUD_UBRRL;
     976:	e4 ec       	ldi	r30, 0xC4	; 196
     978:	f0 e0       	ldi	r31, 0x00	; 0
     97a:	87 e6       	ldi	r24, 0x67	; 103
     97c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:142

	UCSR0A = 0;
     97e:	e0 ec       	ldi	r30, 0xC0	; 192
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:144

	UCSR0B =
     984:	e1 ec       	ldi	r30, 0xC1	; 193
     986:	f0 e0       	ldi	r31, 0x00	; 0
     988:	88 e1       	ldi	r24, 0x18	; 24
     98a:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:150
			//EN_RX_ISR_F |
			//EN_TX_ISR_F |
			//EN_DREGEMPTY_ISR_F |
			EN_TX_F | EN_RX_F;

	UCSR0C = FRAME_STOP_BITS_1 | FRAME_SIZE_8;
     98c:	e2 ec       	ldi	r30, 0xC2	; 194
     98e:	f0 e0       	ldi	r31, 0x00	; 0
     990:	86 e0       	ldi	r24, 0x06	; 6
     992:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:153

#if (SYSCFG_TASKMODEL_THREADS)
	xTaskCreateStatic( uartOsTask, "UART", UART_OS_STACK_SIZE, NULL,
     994:	8a ee       	ldi	r24, 0xEA	; 234
     996:	94 e0       	ldi	r25, 0x04	; 4
     998:	2a e5       	ldi	r18, 0x5A	; 90
     99a:	31 e0       	ldi	r19, 0x01	; 1
     99c:	e7 ee       	ldi	r30, 0xE7	; 231
     99e:	f2 e0       	ldi	r31, 0x02	; 2
     9a0:	ad e1       	ldi	r26, 0x1D	; 29
     9a2:	b3 e0       	ldi	r27, 0x03	; 3
     9a4:	b9 01       	movw	r22, r18
     9a6:	26 e3       	ldi	r18, 0x36	; 54
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	40 e0       	ldi	r20, 0x00	; 0
     9ac:	50 e0       	ldi	r21, 0x00	; 0
     9ae:	00 e0       	ldi	r16, 0x00	; 0
     9b0:	10 e0       	ldi	r17, 0x00	; 0
     9b2:	ee 24       	eor	r14, r14
     9b4:	68 94       	set
     9b6:	e1 f8       	bld	r14, 1
     9b8:	6f 01       	movw	r12, r30
     9ba:	5d 01       	movw	r10, r26
     9bc:	0e 94 86 07 	call	0xf0c	; 0xf0c <xTaskCreateStatic>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:156
		UART_TASK_PRIORITY,  ucuartTaskStack, &xuartTCBBuffer  );
#endif
}
     9c0:	cf 91       	pop	r28
     9c2:	df 91       	pop	r29
     9c4:	1f 91       	pop	r17
     9c6:	0f 91       	pop	r16
     9c8:	ef 90       	pop	r14
     9ca:	df 90       	pop	r13
     9cc:	cf 90       	pop	r12
     9ce:	bf 90       	pop	r11
     9d0:	af 90       	pop	r10
     9d2:	08 95       	ret

000009d4 <uartOsTask>:
uartOsTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:160

#if (SYSCFG_TASKMODEL_THREADS)
/*!	uart base OS task */
portTASK_FUNCTION( uartOsTask, pvParameters ) {
     9d4:	df 93       	push	r29
     9d6:	cf 93       	push	r28
     9d8:	00 d0       	rcall	.+0      	; 0x9da <uartOsTask+0x6>
     9da:	cd b7       	in	r28, 0x3d	; 61
     9dc:	de b7       	in	r29, 0x3e	; 62
     9de:	9a 83       	std	Y+2, r25	; 0x02
     9e0:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:164
	(void)pvParameters;

	for (;;) {
		uartPeriodicTask();
     9e2:	0e 94 fe 04 	call	0x9fc	; 0x9fc <uartPeriodicTask>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:165
		uartStackLeft = uxTaskGetStackHighWaterMark(NULL);
     9e6:	80 e0       	ldi	r24, 0x00	; 0
     9e8:	90 e0       	ldi	r25, 0x00	; 0
     9ea:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxTaskGetStackHighWaterMark>
     9ee:	80 93 e6 02 	sts	0x02E6, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:166
		vTaskDelay(UART_TASK_PAUSE_TKS);
     9f2:	8a e0       	ldi	r24, 0x0A	; 10
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	0e 94 1e 0a 	call	0x143c	; 0x143c <vTaskDelay>
     9fa:	f3 cf       	rjmp	.-26     	; 0x9e2 <uartOsTask+0xe>

000009fc <uartPeriodicTask>:
uartPeriodicTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:172
	}
}
#endif

/*!	uart periodic task	*/
void uartPeriodicTask (void) {
     9fc:	df 93       	push	r29
     9fe:	cf 93       	push	r28
     a00:	cd b7       	in	r28, 0x3d	; 61
     a02:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:182
#endif
#if (!UARTCFG_USE_TX_ISR)
	uartTxPollingTask();
#endif
#endif
	uartStatusCheck();
     a04:	0e 94 07 05 	call	0xa0e	; 0xa0e <uartStatusCheck>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:183
}
     a08:	cf 91       	pop	r28
     a0a:	df 91       	pop	r29
     a0c:	08 95       	ret

00000a0e <uartStatusCheck>:
uartStatusCheck():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:186

/*!	uart internal error checking and logging	*/
static void uartStatusCheck (void) {
     a0e:	df 93       	push	r29
     a10:	cf 93       	push	r28
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
     a16:	2a 97       	sbiw	r28, 0x0a	; 10
     a18:	0f b6       	in	r0, 0x3f	; 63
     a1a:	f8 94       	cli
     a1c:	de bf       	out	0x3e, r29	; 62
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	cd bf       	out	0x3d, r28	; 61
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:187
	MCU_ENTER_CRITICAL();
     a22:	0f b6       	in	r0, 0x3f	; 63
     a24:	f8 94       	cli
     a26:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:188
	registerByte_t const stat_reg_copy = rxStatusRegCopy_Async;
     a28:	80 91 dc 02 	lds	r24, 0x02DC
     a2c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:189
	uartControl_st const rx_async_copy = rxData_Async;
     a2e:	80 91 dd 02 	lds	r24, 0x02DD
     a32:	90 91 de 02 	lds	r25, 0x02DE
     a36:	a0 91 df 02 	lds	r26, 0x02DF
     a3a:	b0 91 e0 02 	lds	r27, 0x02E0
     a3e:	8a 83       	std	Y+2, r24	; 0x02
     a40:	9b 83       	std	Y+3, r25	; 0x03
     a42:	ac 83       	std	Y+4, r26	; 0x04
     a44:	bd 83       	std	Y+5, r27	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:190
	uartControl_st const tx_async_copy = txData_Async;
     a46:	80 91 e1 02 	lds	r24, 0x02E1
     a4a:	90 91 e2 02 	lds	r25, 0x02E2
     a4e:	a0 91 e3 02 	lds	r26, 0x02E3
     a52:	b0 91 e4 02 	lds	r27, 0x02E4
     a56:	8e 83       	std	Y+6, r24	; 0x06
     a58:	9f 83       	std	Y+7, r25	; 0x07
     a5a:	a8 87       	std	Y+8, r26	; 0x08
     a5c:	b9 87       	std	Y+9, r27	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:191
	registerByte_t const isr_reg_copy = UCSR0B;
     a5e:	e1 ec       	ldi	r30, 0xC1	; 193
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	80 81       	ld	r24, Z
     a64:	8a 87       	std	Y+10, r24	; 0x0a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:192
	MCU_EXIT_CRITICAL();
     a66:	0f 90       	pop	r0
     a68:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:194

	if (stat_reg_copy & (1 << FE0)) {
     a6a:	89 81       	ldd	r24, Y+1	; 0x01
     a6c:	88 2f       	mov	r24, r24
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	80 71       	andi	r24, 0x10	; 16
     a72:	90 70       	andi	r25, 0x00	; 0
     a74:	00 97       	sbiw	r24, 0x00	; 0
     a76:	29 f0       	breq	.+10     	; 0xa82 <uartStatusCheck+0x74>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:195
		uartErrorNo.errb.framing = 1;
     a78:	80 91 e5 02 	lds	r24, 0x02E5
     a7c:	84 60       	ori	r24, 0x04	; 4
     a7e:	80 93 e5 02 	sts	0x02E5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:197
	}
	if (stat_reg_copy & (1 << DOR0)) {
     a82:	89 81       	ldd	r24, Y+1	; 0x01
     a84:	88 2f       	mov	r24, r24
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	88 70       	andi	r24, 0x08	; 8
     a8a:	90 70       	andi	r25, 0x00	; 0
     a8c:	00 97       	sbiw	r24, 0x00	; 0
     a8e:	29 f0       	breq	.+10     	; 0xa9a <uartStatusCheck+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:198
		uartErrorNo.errb.dataOverrun = 1;
     a90:	80 91 e5 02 	lds	r24, 0x02E5
     a94:	82 60       	ori	r24, 0x02	; 2
     a96:	80 93 e5 02 	sts	0x02E5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:200
	}
	if (stat_reg_copy & (1 << UPE0)) {
     a9a:	89 81       	ldd	r24, Y+1	; 0x01
     a9c:	88 2f       	mov	r24, r24
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	84 70       	andi	r24, 0x04	; 4
     aa2:	90 70       	andi	r25, 0x00	; 0
     aa4:	00 97       	sbiw	r24, 0x00	; 0
     aa6:	29 f0       	breq	.+10     	; 0xab2 <uartStatusCheck+0xa4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:201
		uartErrorNo.errb.parity = 1;
     aa8:	80 91 e5 02 	lds	r24, 0x02E5
     aac:	81 60       	ori	r24, 0x01	; 1
     aae:	80 93 e5 02 	sts	0x02E5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:205
	}

#if (UARTCFG_USE_RX_ISR)
	if ( (isr_reg_copy & EN_RX_ISR_F) && (RESET == rx_async_copy.length) ) {
     ab2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ab4:	88 23       	and	r24, r24
     ab6:	7c f4       	brge	.+30     	; 0xad6 <uartStatusCheck+0xc8>
     ab8:	8d 81       	ldd	r24, Y+5	; 0x05
     aba:	88 23       	and	r24, r24
     abc:	61 f4       	brne	.+24     	; 0xad6 <uartStatusCheck+0xc8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:208
		// interrupt enabled when there's no room left in buffer
		// this shouldn't happen if call status behaves as it should
		uartErrorNo.errb.rxBadState = 1;
     abe:	80 91 e5 02 	lds	r24, 0x02E5
     ac2:	88 60       	ori	r24, 0x08	; 8
     ac4:	80 93 e5 02 	sts	0x02E5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:210
		/*** ISR DISABLED ***/
		DISABLE_RX_ISR();
     ac8:	a1 ec       	ldi	r26, 0xC1	; 193
     aca:	b0 e0       	ldi	r27, 0x00	; 0
     acc:	e1 ec       	ldi	r30, 0xC1	; 193
     ace:	f0 e0       	ldi	r31, 0x00	; 0
     ad0:	80 81       	ld	r24, Z
     ad2:	8f 77       	andi	r24, 0x7F	; 127
     ad4:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:223
		/*** ISR DISABLED ***/
		TX_DREGEMPTY_DISABLE_ISR();
		/********************/
	}
#endif
}
     ad6:	2a 96       	adiw	r28, 0x0a	; 10
     ad8:	0f b6       	in	r0, 0x3f	; 63
     ada:	f8 94       	cli
     adc:	de bf       	out	0x3e, r29	; 62
     ade:	0f be       	out	0x3f, r0	; 63
     ae0:	cd bf       	out	0x3d, r28	; 61
     ae2:	cf 91       	pop	r28
     ae4:	df 91       	pop	r29
     ae6:	08 95       	ret

00000ae8 <__vector_18>:
__vector_18():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:258
static inline void uartRxFrameIsr (void) {
	if ( (NULL != rxData_Async.buffer_ptr) && (RESET != rxData_Async.length) ) {
		uartRxFrameCommon();
	}
}
ISR(USART_RX_vect) {
     ae8:	1f 92       	push	r1
     aea:	0f 92       	push	r0
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	0f 92       	push	r0
     af0:	11 24       	eor	r1, r1
     af2:	2f 93       	push	r18
     af4:	3f 93       	push	r19
     af6:	8f 93       	push	r24
     af8:	9f 93       	push	r25
     afa:	af 93       	push	r26
     afc:	bf 93       	push	r27
     afe:	ef 93       	push	r30
     b00:	ff 93       	push	r31
     b02:	df 93       	push	r29
     b04:	cf 93       	push	r28
     b06:	cd b7       	in	r28, 0x3d	; 61
     b08:	de b7       	in	r29, 0x3e	; 62
uartRxFrameIsr():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:254
#if UARTCFG_USE_RX_ISR
/*!	ISR rx triggers when frame is received and puts frame data into rx buffer,
	disables itself when its reached the max frames for the buffer	*/
static inline void uartRxFrameIsr (void) __attribute__((always_inline));
static inline void uartRxFrameIsr (void) {
	if ( (NULL != rxData_Async.buffer_ptr) && (RESET != rxData_Async.length) ) {
     b0a:	80 91 dd 02 	lds	r24, 0x02DD
     b0e:	90 91 de 02 	lds	r25, 0x02DE
     b12:	00 97       	sbiw	r24, 0x00	; 0
     b14:	61 f1       	breq	.+88     	; 0xb6e <__vector_18+0x86>
     b16:	80 91 e0 02 	lds	r24, 0x02E0
     b1a:	88 23       	and	r24, r24
     b1c:	41 f1       	breq	.+80     	; 0xb6e <__vector_18+0x86>
uartRxFrameCommon():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:231

/*!	common code used to copy data from the rx register to the buffer. it knows
	it self disables when the buffer is full. \note MUST CHECK
	(NULL != rx_Async.buffer_ptr) && (RESET != rx_Async.length) WHEN USED	*/
static inline void uartRxFrameCommon (void) {
	rxStatusRegCopy_Async = UCSR0A;
     b1e:	e0 ec       	ldi	r30, 0xC0	; 192
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	80 81       	ld	r24, Z
     b24:	80 93 dc 02 	sts	0x02DC, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:236
#if (9 == UART_DATA_SIZE)
	rxData_Async.buffer_ptr[rxData_Async.index] = ((UCSR0B << RX_FRAME_DATA_HIGH_SHIFT) & DATA_HIGH_MASK);
	rxData_Async.buffer_ptr[rxData_Async.index] |= UDR0;
#else
	rxData_Async.buffer_ptr[rxData_Async.index]  = UDR0;
     b28:	20 91 dd 02 	lds	r18, 0x02DD
     b2c:	30 91 de 02 	lds	r19, 0x02DE
     b30:	80 91 df 02 	lds	r24, 0x02DF
     b34:	88 2f       	mov	r24, r24
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	d9 01       	movw	r26, r18
     b3a:	a8 0f       	add	r26, r24
     b3c:	b9 1f       	adc	r27, r25
     b3e:	e6 ec       	ldi	r30, 0xC6	; 198
     b40:	f0 e0       	ldi	r31, 0x00	; 0
     b42:	80 81       	ld	r24, Z
     b44:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:238
#endif
	rxData_Async.index++;
     b46:	80 91 df 02 	lds	r24, 0x02DF
     b4a:	8f 5f       	subi	r24, 0xFF	; 255
     b4c:	80 93 df 02 	sts	0x02DF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:239
	if (rxData_Async.length <= rxData_Async.index) {
     b50:	90 91 e0 02 	lds	r25, 0x02E0
     b54:	80 91 df 02 	lds	r24, 0x02DF
     b58:	89 17       	cp	r24, r25
     b5a:	48 f0       	brcs	.+18     	; 0xb6e <__vector_18+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:240
		rxData_Async.length = RESET;
     b5c:	10 92 e0 02 	sts	0x02E0, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:243
#if UARTCFG_USE_RX_ISR
		/*** ISR DISABLED ***/
		DISABLE_RX_ISR();
     b60:	a1 ec       	ldi	r26, 0xC1	; 193
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	e1 ec       	ldi	r30, 0xC1	; 193
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	80 81       	ld	r24, Z
     b6a:	8f 77       	andi	r24, 0x7F	; 127
     b6c:	8c 93       	st	X, r24
__vector_18():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:260
		uartRxFrameCommon();
	}
}
ISR(USART_RX_vect) {
	uartRxFrameIsr();
}
     b6e:	cf 91       	pop	r28
     b70:	df 91       	pop	r29
     b72:	ff 91       	pop	r31
     b74:	ef 91       	pop	r30
     b76:	bf 91       	pop	r27
     b78:	af 91       	pop	r26
     b7a:	9f 91       	pop	r25
     b7c:	8f 91       	pop	r24
     b7e:	3f 91       	pop	r19
     b80:	2f 91       	pop	r18
     b82:	0f 90       	pop	r0
     b84:	0f be       	out	0x3f, r0	; 63
     b86:	0f 90       	pop	r0
     b88:	1f 90       	pop	r1
     b8a:	18 95       	reti

00000b8c <uartRxRead>:
uartRxRead():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:270
	the result. Works a little different when using polling, need to call again
	with same buffer pointer to collect data (otherwise it assumes the data
	will go to the wrong buffer if there are multiple callers. only one can
	user rx at a time, indicated by .buffer_ptr != NULL) */
callStatus_t uartRxRead
(uartDataFrame_t const * const data_out_ptr, unsigned char * const num_frames_ptr) {
     b8c:	df 93       	push	r29
     b8e:	cf 93       	push	r28
     b90:	cd b7       	in	r28, 0x3d	; 61
     b92:	de b7       	in	r29, 0x3e	; 62
     b94:	2a 97       	sbiw	r28, 0x0a	; 10
     b96:	0f b6       	in	r0, 0x3f	; 63
     b98:	f8 94       	cli
     b9a:	de bf       	out	0x3e, r29	; 62
     b9c:	0f be       	out	0x3f, r0	; 63
     b9e:	cd bf       	out	0x3d, r28	; 61
     ba0:	98 87       	std	Y+8, r25	; 0x08
     ba2:	8f 83       	std	Y+7, r24	; 0x07
     ba4:	7a 87       	std	Y+10, r23	; 0x0a
     ba6:	69 87       	std	Y+9, r22	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:272

	registerByte_t stat_reg_copy = 0;
     ba8:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:273
	callStatus_t call_result = CALL_OK;
     baa:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:275

	MCU_ENTER_CRITICAL();
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	f8 94       	cli
     bb0:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:276
	uartControl_st rx_async_copy = rxData_Async;
     bb2:	80 91 dd 02 	lds	r24, 0x02DD
     bb6:	90 91 de 02 	lds	r25, 0x02DE
     bba:	a0 91 df 02 	lds	r26, 0x02DF
     bbe:	b0 91 e0 02 	lds	r27, 0x02E0
     bc2:	8b 83       	std	Y+3, r24	; 0x03
     bc4:	9c 83       	std	Y+4, r25	; 0x04
     bc6:	ad 83       	std	Y+5, r26	; 0x05
     bc8:	be 83       	std	Y+6, r27	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:277
	MCU_EXIT_CRITICAL();
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:280

	// first make sure another string isn't currently still receiving
	if ((NULL == data_out_ptr) || (NULL == num_frames_ptr)
     bce:	8f 81       	ldd	r24, Y+7	; 0x07
     bd0:	98 85       	ldd	r25, Y+8	; 0x08
     bd2:	00 97       	sbiw	r24, 0x00	; 0
     bd4:	49 f0       	breq	.+18     	; 0xbe8 <uartRxRead+0x5c>
     bd6:	89 85       	ldd	r24, Y+9	; 0x09
     bd8:	9a 85       	ldd	r25, Y+10	; 0x0a
     bda:	00 97       	sbiw	r24, 0x00	; 0
     bdc:	29 f0       	breq	.+10     	; 0xbe8 <uartRxRead+0x5c>
     bde:	e9 85       	ldd	r30, Y+9	; 0x09
     be0:	fa 85       	ldd	r31, Y+10	; 0x0a
     be2:	80 81       	ld	r24, Z
     be4:	88 23       	and	r24, r24
     be6:	19 f4       	brne	.+6      	; 0xbee <uartRxRead+0x62>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:282
			|| (0 == *num_frames_ptr)) {
		call_result = CALL_BAD_ARG;
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	89 83       	std	Y+1, r24	; 0x01
     bec:	4a c0       	rjmp	.+148    	; 0xc82 <uartRxRead+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:284
	}
	else if (RESET != rx_async_copy.length) {
     bee:	8e 81       	ldd	r24, Y+6	; 0x06
     bf0:	88 23       	and	r24, r24
     bf2:	19 f0       	breq	.+6      	; 0xbfa <uartRxRead+0x6e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:285
		call_result = CALL_BUSY;
     bf4:	82 e0       	ldi	r24, 0x02	; 2
     bf6:	89 83       	std	Y+1, r24	; 0x01
     bf8:	44 c0       	rjmp	.+136    	; 0xc82 <uartRxRead+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:313
		 	 could be that they're non null non matching and we're still midprocess */

		// RESET == rx_async_copy.length, NULL == rx_async_copy.buffer_ptr
		// new rx stream
		// rx state: idle -> busy
		if (RX_DATA_BUFFER_SIZE < *num_frames_ptr) {
     bfa:	e9 85       	ldd	r30, Y+9	; 0x09
     bfc:	fa 85       	ldd	r31, Y+10	; 0x0a
     bfe:	80 81       	ld	r24, Z
     c00:	81 34       	cpi	r24, 0x41	; 65
     c02:	20 f0       	brcs	.+8      	; 0xc0c <uartRxRead+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:315
			// limit how long anyone can hog the rx
			*num_frames_ptr = RX_DATA_BUFFER_SIZE;
     c04:	e9 85       	ldd	r30, Y+9	; 0x09
     c06:	fa 85       	ldd	r31, Y+10	; 0x0a
     c08:	80 e4       	ldi	r24, 0x40	; 64
     c0a:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:318
		}
		// TODO: test protection {
		MCU_ENTER_CRITICAL();
     c0c:	0f b6       	in	r0, 0x3f	; 63
     c0e:	f8 94       	cli
     c10:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:319
		rxData_Async.buffer_ptr = (uartDataFrame_t *)data_out_ptr;
     c12:	8f 81       	ldd	r24, Y+7	; 0x07
     c14:	98 85       	ldd	r25, Y+8	; 0x08
     c16:	90 93 de 02 	sts	0x02DE, r25
     c1a:	80 93 dd 02 	sts	0x02DD, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:320
		rxData_Async.index = RESET;
     c1e:	10 92 df 02 	sts	0x02DF, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:321
		rxData_Async.length = *num_frames_ptr;
     c22:	e9 85       	ldd	r30, Y+9	; 0x09
     c24:	fa 85       	ldd	r31, Y+10	; 0x0a
     c26:	80 81       	ld	r24, Z
     c28:	80 93 e0 02 	sts	0x02E0, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:322
		MCU_EXIT_CRITICAL();
     c2c:	0f 90       	pop	r0
     c2e:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:328
		// }

#if SYSCFG_TASKMODEL_THREADS // {
#if UARTCFG_USE_RX_ISR
		/*** ISR ENABLED ****/
		ENABLE_RX_ISR();
     c30:	a1 ec       	ldi	r26, 0xC1	; 193
     c32:	b0 e0       	ldi	r27, 0x00	; 0
     c34:	e1 ec       	ldi	r30, 0xC1	; 193
     c36:	f0 e0       	ldi	r31, 0x00	; 0
     c38:	80 81       	ld	r24, Z
     c3a:	80 68       	ori	r24, 0x80	; 128
     c3c:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:331
		/********************/
		do {
			MCU_ENTER_CRITICAL();
     c3e:	0f b6       	in	r0, 0x3f	; 63
     c40:	f8 94       	cli
     c42:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:332
			rx_async_copy.length = rxData_Async.length;
     c44:	80 91 e0 02 	lds	r24, 0x02E0
     c48:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:333
			MCU_EXIT_CRITICAL();
     c4a:	0f 90       	pop	r0
     c4c:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:334
		} while (RESET != rx_async_copy.length);
     c4e:	8e 81       	ldd	r24, Y+6	; 0x06
     c50:	88 23       	and	r24, r24
     c52:	a9 f7       	brne	.-22     	; 0xc3e <uartRxRead+0xb2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:340
#else
		/*** rx wait ***/
		uartRxThread();
		/***************/
#endif
		stat_reg_copy = rxStatusRegCopy_Async;
     c54:	80 91 dc 02 	lds	r24, 0x02DC
     c58:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:341
		rx_async_copy = rxData_Async;
     c5a:	80 91 dd 02 	lds	r24, 0x02DD
     c5e:	90 91 de 02 	lds	r25, 0x02DE
     c62:	a0 91 df 02 	lds	r26, 0x02DF
     c66:	b0 91 e0 02 	lds	r27, 0x02E0
     c6a:	8b 83       	std	Y+3, r24	; 0x03
     c6c:	9c 83       	std	Y+4, r25	; 0x04
     c6e:	ad 83       	std	Y+5, r26	; 0x05
     c70:	be 83       	std	Y+6, r27	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:342
		*num_frames_ptr = rx_async_copy.index;
     c72:	8d 81       	ldd	r24, Y+5	; 0x05
     c74:	e9 85       	ldd	r30, Y+9	; 0x09
     c76:	fa 85       	ldd	r31, Y+10	; 0x0a
     c78:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:343
		rxData_Async.buffer_ptr = NULL;
     c7a:	10 92 de 02 	sts	0x02DE, r1
     c7e:	10 92 dd 02 	sts	0x02DD, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:360
		// uartRxPollingTask called by uartPeriodicTask which is called by system loop
#endif
#endif
	}

	if (stat_reg_copy & ((1 << FE0) | (1 << DOR0) | (1 << UPE0))) {
     c82:	8a 81       	ldd	r24, Y+2	; 0x02
     c84:	88 2f       	mov	r24, r24
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	8c 71       	andi	r24, 0x1C	; 28
     c8a:	90 70       	andi	r25, 0x00	; 0
     c8c:	00 97       	sbiw	r24, 0x00	; 0
     c8e:	11 f0       	breq	.+4      	; 0xc94 <uartRxRead+0x108>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:361
		call_result = CALL_ERROR;
     c90:	84 e0       	ldi	r24, 0x04	; 4
     c92:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:364
	}

	return (call_result);
     c94:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:365
}
     c96:	2a 96       	adiw	r28, 0x0a	; 10
     c98:	0f b6       	in	r0, 0x3f	; 63
     c9a:	f8 94       	cli
     c9c:	de bf       	out	0x3e, r29	; 62
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	cd bf       	out	0x3d, r28	; 61
     ca2:	cf 91       	pop	r28
     ca4:	df 91       	pop	r29
     ca6:	08 95       	ret

00000ca8 <uartTxWrite>:
uartTxWrite():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:426
	}
}

/*!	tx cstring */
callStatus_t uartTxWrite
(uartDataFrame_t const * const data_ptr,  unsigned char * const num_frames_ptr) {
     ca8:	df 93       	push	r29
     caa:	cf 93       	push	r28
     cac:	cd b7       	in	r28, 0x3d	; 61
     cae:	de b7       	in	r29, 0x3e	; 62
     cb0:	29 97       	sbiw	r28, 0x09	; 9
     cb2:	0f b6       	in	r0, 0x3f	; 63
     cb4:	f8 94       	cli
     cb6:	de bf       	out	0x3e, r29	; 62
     cb8:	0f be       	out	0x3f, r0	; 63
     cba:	cd bf       	out	0x3d, r28	; 61
     cbc:	9f 83       	std	Y+7, r25	; 0x07
     cbe:	8e 83       	std	Y+6, r24	; 0x06
     cc0:	79 87       	std	Y+9, r23	; 0x09
     cc2:	68 87       	std	Y+8, r22	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:427
	callStatus_t call_result = CALL_OK;
     cc4:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:429
	
	MCU_ENTER_CRITICAL();
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:430
	uartControl_st tx_async_copy = txData_Async;
     ccc:	80 91 e1 02 	lds	r24, 0x02E1
     cd0:	90 91 e2 02 	lds	r25, 0x02E2
     cd4:	a0 91 e3 02 	lds	r26, 0x02E3
     cd8:	b0 91 e4 02 	lds	r27, 0x02E4
     cdc:	8a 83       	std	Y+2, r24	; 0x02
     cde:	9b 83       	std	Y+3, r25	; 0x03
     ce0:	ac 83       	std	Y+4, r26	; 0x04
     ce2:	bd 83       	std	Y+5, r27	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:431
	MCU_EXIT_CRITICAL();
     ce4:	0f 90       	pop	r0
     ce6:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:433
	
	if ((NULL == data_ptr) || (NULL == num_frames_ptr)
     ce8:	8e 81       	ldd	r24, Y+6	; 0x06
     cea:	9f 81       	ldd	r25, Y+7	; 0x07
     cec:	00 97       	sbiw	r24, 0x00	; 0
     cee:	49 f0       	breq	.+18     	; 0xd02 <uartTxWrite+0x5a>
     cf0:	88 85       	ldd	r24, Y+8	; 0x08
     cf2:	99 85       	ldd	r25, Y+9	; 0x09
     cf4:	00 97       	sbiw	r24, 0x00	; 0
     cf6:	29 f0       	breq	.+10     	; 0xd02 <uartTxWrite+0x5a>
     cf8:	e8 85       	ldd	r30, Y+8	; 0x08
     cfa:	f9 85       	ldd	r31, Y+9	; 0x09
     cfc:	80 81       	ld	r24, Z
     cfe:	88 23       	and	r24, r24
     d00:	19 f4       	brne	.+6      	; 0xd08 <uartTxWrite+0x60>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:435
			|| (0 == *num_frames_ptr)) {
		call_result = CALL_BAD_ARG;
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	89 83       	std	Y+1, r24	; 0x01
     d06:	3e c0       	rjmp	.+124    	; 0xd84 <uartTxWrite+0xdc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:437
	}
	else if (RESET != tx_async_copy.length) {
     d08:	8d 81       	ldd	r24, Y+5	; 0x05
     d0a:	88 23       	and	r24, r24
     d0c:	19 f0       	breq	.+6      	; 0xd14 <uartTxWrite+0x6c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:438
		call_result = CALL_BUSY;
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	89 83       	std	Y+1, r24	; 0x01
     d12:	38 c0       	rjmp	.+112    	; 0xd84 <uartTxWrite+0xdc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:456
	else if (NULL != tx_async_copy.buffer_ptr) {
		call_result = CALL_BUSY;
	}
#endif
	else {
		if (data_ptr != tx_async_copy.buffer_ptr) {
     d14:	2a 81       	ldd	r18, Y+2	; 0x02
     d16:	3b 81       	ldd	r19, Y+3	; 0x03
     d18:	8e 81       	ldd	r24, Y+6	; 0x06
     d1a:	9f 81       	ldd	r25, Y+7	; 0x07
     d1c:	28 17       	cp	r18, r24
     d1e:	39 07       	cpc	r19, r25
     d20:	89 f1       	breq	.+98     	; 0xd84 <uartTxWrite+0xdc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:458
			// tx state: idle -> busy
			if (TX_DATA_BUFFER_SIZE < *num_frames_ptr) {
     d22:	e8 85       	ldd	r30, Y+8	; 0x08
     d24:	f9 85       	ldd	r31, Y+9	; 0x09
     d26:	80 81       	ld	r24, Z
     d28:	81 34       	cpi	r24, 0x41	; 65
     d2a:	20 f0       	brcs	.+8      	; 0xd34 <uartTxWrite+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:462
				//note: if @ 9600 it would take rougly 133ms to finish a stream that
				// large, even at the fastest (38400) it takes 33ms
				//STREAM TOO LONG
				*num_frames_ptr = TX_DATA_BUFFER_SIZE;
     d2c:	e8 85       	ldd	r30, Y+8	; 0x08
     d2e:	f9 85       	ldd	r31, Y+9	; 0x09
     d30:	80 e4       	ldi	r24, 0x40	; 64
     d32:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:465
			}
			//TODO: test protection
			MCU_ENTER_CRITICAL();
     d34:	0f b6       	in	r0, 0x3f	; 63
     d36:	f8 94       	cli
     d38:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:466
			txData_Async.buffer_ptr = (uartDataFrame_t *)data_ptr;
     d3a:	8e 81       	ldd	r24, Y+6	; 0x06
     d3c:	9f 81       	ldd	r25, Y+7	; 0x07
     d3e:	90 93 e2 02 	sts	0x02E2, r25
     d42:	80 93 e1 02 	sts	0x02E1, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:467
			txData_Async.index = RESET;
     d46:	10 92 e3 02 	sts	0x02E3, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:468
			txData_Async.length = *num_frames_ptr;
     d4a:	e8 85       	ldd	r30, Y+8	; 0x08
     d4c:	f9 85       	ldd	r31, Y+9	; 0x09
     d4e:	80 81       	ld	r24, Z
     d50:	80 93 e4 02 	sts	0x02E4, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:469
			MCU_EXIT_CRITICAL();
     d54:	0f 90       	pop	r0
     d56:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:482
				tx_async_copy.length = txData_Async.length;
				MCU_EXIT_CRITICAL();
			} while (RESET != tx_async_copy.length)
#else
			/*** tx thread ***/
			uartTxThread();
     d58:	0e 94 cc 06 	call	0xd98	; 0xd98 <uartTxThread>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:485
			/*****************/
#endif
			tx_async_copy = txData_Async;
     d5c:	80 91 e1 02 	lds	r24, 0x02E1
     d60:	90 91 e2 02 	lds	r25, 0x02E2
     d64:	a0 91 e3 02 	lds	r26, 0x02E3
     d68:	b0 91 e4 02 	lds	r27, 0x02E4
     d6c:	8a 83       	std	Y+2, r24	; 0x02
     d6e:	9b 83       	std	Y+3, r25	; 0x03
     d70:	ac 83       	std	Y+4, r26	; 0x04
     d72:	bd 83       	std	Y+5, r27	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:486
			*num_frames_ptr = tx_async_copy.index;
     d74:	8c 81       	ldd	r24, Y+4	; 0x04
     d76:	e8 85       	ldd	r30, Y+8	; 0x08
     d78:	f9 85       	ldd	r31, Y+9	; 0x09
     d7a:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:487
			txData_Async.buffer_ptr = NULL;
     d7c:	10 92 e2 02 	sts	0x02E2, r1
     d80:	10 92 e1 02 	sts	0x02E1, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:492
#endif // otherwise the uart polling task completes the send of repeat frames
		}
	}

	return (call_result);
     d84:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:493
}
     d86:	29 96       	adiw	r28, 0x09	; 9
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	cf 91       	pop	r28
     d94:	df 91       	pop	r29
     d96:	08 95       	ret

00000d98 <uartTxThread>:
uartTxThread():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:515
#endif

#if SYSCFG_TASKMODEL_THREADS
#if (!UARTCFG_USE_TX_ISR)
/*!	TODO desc	*/
static void uartTxThread (void) {
     d98:	df 93       	push	r29
     d9a:	cf 93       	push	r28
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	25 c0       	rjmp	.+74     	; 0xdec <uartTxThread+0x54>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:518

	while ( (NULL != txData_Async.buffer_ptr) && (RESET != txData_Async.length) ) {
		while (!(TX_FRAME_READY())) {
     da2:	e0 ec       	ldi	r30, 0xC0	; 192
     da4:	f0 e0       	ldi	r31, 0x00	; 0
     da6:	80 81       	ld	r24, Z
     da8:	88 2f       	mov	r24, r24
     daa:	90 e0       	ldi	r25, 0x00	; 0
     dac:	80 72       	andi	r24, 0x20	; 32
     dae:	90 70       	andi	r25, 0x00	; 0
     db0:	00 97       	sbiw	r24, 0x00	; 0
     db2:	b9 f3       	breq	.-18     	; 0xda2 <uartTxThread+0xa>
uartTxFrameCommon():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:411
	// this clears UDRE0
#if (9 == UART_DATA_SIZE)
	UCSR0B = (txData_Async.buffer_ptr[txData_Async.index] & DATA_HIGH_MASK) >> TX_FRAME_DATA_HIGH_SHIFT;
	UDR0 = (txData_Async.buffer_ptr[txData_Async.index] & DATA_LOW_MASK);
#else
	UDR0 = txData_Async.buffer_ptr[txData_Async.index];
     db4:	a6 ec       	ldi	r26, 0xC6	; 198
     db6:	b0 e0       	ldi	r27, 0x00	; 0
     db8:	20 91 e1 02 	lds	r18, 0x02E1
     dbc:	30 91 e2 02 	lds	r19, 0x02E2
     dc0:	80 91 e3 02 	lds	r24, 0x02E3
     dc4:	88 2f       	mov	r24, r24
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	f9 01       	movw	r30, r18
     dca:	e8 0f       	add	r30, r24
     dcc:	f9 1f       	adc	r31, r25
     dce:	80 81       	ld	r24, Z
     dd0:	8c 93       	st	X, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:413
#endif
	txData_Async.index++;
     dd2:	80 91 e3 02 	lds	r24, 0x02E3
     dd6:	8f 5f       	subi	r24, 0xFF	; 255
     dd8:	80 93 e3 02 	sts	0x02E3, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:414
	if (txData_Async.length <= txData_Async.index) {
     ddc:	90 91 e4 02 	lds	r25, 0x02E4
     de0:	80 91 e3 02 	lds	r24, 0x02E3
     de4:	89 17       	cp	r24, r25
     de6:	10 f0       	brcs	.+4      	; 0xdec <uartTxThread+0x54>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:415
		txData_Async.length = RESET;
     de8:	10 92 e4 02 	sts	0x02E4, r1
uartTxThread():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:517
#if SYSCFG_TASKMODEL_THREADS
#if (!UARTCFG_USE_TX_ISR)
/*!	TODO desc	*/
static void uartTxThread (void) {

	while ( (NULL != txData_Async.buffer_ptr) && (RESET != txData_Async.length) ) {
     dec:	80 91 e1 02 	lds	r24, 0x02E1
     df0:	90 91 e2 02 	lds	r25, 0x02E2
     df4:	00 97       	sbiw	r24, 0x00	; 0
     df6:	21 f0       	breq	.+8      	; 0xe00 <uartTxThread+0x68>
     df8:	80 91 e4 02 	lds	r24, 0x02E4
     dfc:	88 23       	and	r24, r24
     dfe:	89 f6       	brne	.-94     	; 0xda2 <uartTxThread+0xa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/uart.c:523
		while (!(TX_FRAME_READY())) {
			// wait for previous tx frame to finish sending
		}
		uartTxFrameCommon();
	}
}
     e00:	cf 91       	pop	r28
     e02:	df 91       	pop	r29
     e04:	08 95       	ret

00000e06 <watchdogInit>:
watchdogInit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:191


/*	public functions	*/

/*!	init */
void watchdogInit (void) {
     e06:	af 92       	push	r10
     e08:	bf 92       	push	r11
     e0a:	cf 92       	push	r12
     e0c:	df 92       	push	r13
     e0e:	ef 92       	push	r14
     e10:	0f 93       	push	r16
     e12:	1f 93       	push	r17
     e14:	df 93       	push	r29
     e16:	cf 93       	push	r28
     e18:	cd b7       	in	r28, 0x3d	; 61
     e1a:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:196
	/*	This bit is used in timed sequences for changing WDE and prescaler bits.
	 	To clear the WDE bit, and/or change the prescaler bits, WDCE must be
	 	set. Once written to one, hardware will clear WDCE after four clock
	 	cycles.*/
	DBG_COND(debugControl) {
     e1c:	80 91 5f 01 	lds	r24, 0x015F
     e20:	90 91 60 01 	lds	r25, 0x0160
     e24:	00 97       	sbiw	r24, 0x00	; 0
     e26:	59 f0       	breq	.+22     	; 0xe3e <watchdogInit+0x38>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:197
	WD_ENABLE( (WD_CLEAR_IF | WD_MODE_SETTING | WD_TIMEOUT_SETTING) );
     e28:	88 e1       	ldi	r24, 0x18	; 24
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	26 ec       	ldi	r18, 0xC6	; 198
     e2e:	0f b6       	in	r0, 0x3f	; 63
     e30:	f8 94       	cli
     e32:	a8 95       	wdr
     e34:	80 93 60 00 	sts	0x0060, r24
     e38:	0f be       	out	0x3f, r0	; 63
     e3a:	20 93 60 00 	sts	0x0060, r18
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:202
	} // DBG_COND


#if (SYSCFG_TASKMODEL_THREADS)
	xTaskCreateStatic( watchdogOsTask, "WTD", WD_OS_STACK_SIZE, NULL,
     e3e:	8e e3       	ldi	r24, 0x3E	; 62
     e40:	97 e0       	ldi	r25, 0x07	; 7
     e42:	21 e6       	ldi	r18, 0x61	; 97
     e44:	31 e0       	ldi	r19, 0x01	; 1
     e46:	e7 e4       	ldi	r30, 0x47	; 71
     e48:	f3 e0       	ldi	r31, 0x03	; 3
     e4a:	ad e7       	ldi	r26, 0x7D	; 125
     e4c:	b3 e0       	ldi	r27, 0x03	; 3
     e4e:	b9 01       	movw	r22, r18
     e50:	26 e3       	ldi	r18, 0x36	; 54
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	40 e0       	ldi	r20, 0x00	; 0
     e56:	50 e0       	ldi	r21, 0x00	; 0
     e58:	00 e0       	ldi	r16, 0x00	; 0
     e5a:	10 e0       	ldi	r17, 0x00	; 0
     e5c:	ee 24       	eor	r14, r14
     e5e:	e3 94       	inc	r14
     e60:	6f 01       	movw	r12, r30
     e62:	5d 01       	movw	r10, r26
     e64:	0e 94 86 07 	call	0xf0c	; 0xf0c <xTaskCreateStatic>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:205
		WD_TASK_PRIORITY, ucwatchdogTaskStack, &xwatchdogTCBBuffer );
#endif
}
     e68:	cf 91       	pop	r28
     e6a:	df 91       	pop	r29
     e6c:	1f 91       	pop	r17
     e6e:	0f 91       	pop	r16
     e70:	ef 90       	pop	r14
     e72:	df 90       	pop	r13
     e74:	cf 90       	pop	r12
     e76:	bf 90       	pop	r11
     e78:	af 90       	pop	r10
     e7a:	08 95       	ret

00000e7c <watchdogOsTask>:
watchdogOsTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:209


#if (SYSCFG_TASKMODEL_THREADS)
portTASK_FUNCTION( watchdogOsTask, pvParameters ) {
     e7c:	df 93       	push	r29
     e7e:	cf 93       	push	r28
     e80:	00 d0       	rcall	.+0      	; 0xe82 <watchdogOsTask+0x6>
     e82:	cd b7       	in	r28, 0x3d	; 61
     e84:	de b7       	in	r29, 0x3e	; 62
     e86:	9a 83       	std	Y+2, r25	; 0x02
     e88:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:214
	/* The parameters are not used. */
	(void)pvParameters;

	for (;;) {
		watchdogPeriodicTask();
     e8a:	0e 94 52 07 	call	0xea4	; 0xea4 <watchdogPeriodicTask>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:215
		watchdogStackLeft = uxTaskGetStackHighWaterMark(NULL);
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <uxTaskGetStackHighWaterMark>
     e96:	80 93 46 03 	sts	0x0346, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:216
		vTaskDelay(WD_KEEP_ALIVE_TKS);
     e9a:	8b e3       	ldi	r24, 0x3B	; 59
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	0e 94 1e 0a 	call	0x143c	; 0x143c <vTaskDelay>
     ea2:	f3 cf       	rjmp	.-26     	; 0xe8a <watchdogOsTask+0xe>

00000ea4 <watchdogPeriodicTask>:
watchdogPeriodicTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:222
	}
}
#endif

/*!	(can be a) periodic task */
void watchdogPeriodicTask (void) {
     ea4:	df 93       	push	r29
     ea6:	cf 93       	push	r28
     ea8:	0f 92       	push	r0
     eaa:	cd b7       	in	r28, 0x3d	; 61
     eac:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:223
	registerByte_t wdStatusPrev = WDTCSR;
     eae:	e0 e6       	ldi	r30, 0x60	; 96
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	80 81       	ld	r24, Z
     eb4:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:226
	// check if MCUSR is overriding (SET << WDE);

	DBG_COND(debugControl) {
     eb6:	80 91 5f 01 	lds	r24, 0x015F
     eba:	90 91 60 01 	lds	r25, 0x0160
     ebe:	00 97       	sbiw	r24, 0x00	; 0
     ec0:	19 f0       	breq	.+6      	; 0xec8 <watchdogPeriodicTask+0x24>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:227
	WD_RESET();
     ec2:	a8 95       	wdr
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:228
	watchdogStatus = WD_CLEAR;
     ec4:	10 92 45 03 	sts	0x0345, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:244
			watchdogStatus = WD_PENDING_RESET;
		}
	}

#endif
}
     ec8:	0f 90       	pop	r0
     eca:	cf 91       	pop	r28
     ecc:	df 91       	pop	r29
     ece:	08 95       	ret

00000ed0 <watchdogStatusGet>:
watchdogStatusGet():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:249


/*	getters/setters	*/

watchdogStatus_t watchdogStatusGet (void) {
     ed0:	df 93       	push	r29
     ed2:	cf 93       	push	r28
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:250
	return (watchdogStatus);
     ed8:	80 91 45 03 	lds	r24, 0x0345
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:251
}
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <__vector_6>:
__vector_6():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:265
	//system will reset (because the assumption is that something is locked up
	//and needs to reset

	watchdogStatus = WD_PENDING_CLEAR;
}
ISR(WDT_vect) {
     ee2:	1f 92       	push	r1
     ee4:	0f 92       	push	r0
     ee6:	0f b6       	in	r0, 0x3f	; 63
     ee8:	0f 92       	push	r0
     eea:	11 24       	eor	r1, r1
     eec:	8f 93       	push	r24
     eee:	df 93       	push	r29
     ef0:	cf 93       	push	r28
     ef2:	cd b7       	in	r28, 0x3d	; 61
     ef4:	de b7       	in	r29, 0x3e	; 62
watchdogTimeoutIsr():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:263

	//WDIE should be set outside of ISR so that if it's not re-enabled
	//system will reset (because the assumption is that something is locked up
	//and needs to reset

	watchdogStatus = WD_PENDING_CLEAR;
     ef6:	81 e0       	ldi	r24, 0x01	; 1
     ef8:	80 93 45 03 	sts	0x0345, r24
__vector_6():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../src/watchdog.c:267
}
ISR(WDT_vect) {
	watchdogTimeoutIsr();
}
     efc:	cf 91       	pop	r28
     efe:	df 91       	pop	r29
     f00:	8f 91       	pop	r24
     f02:	0f 90       	pop	r0
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	0f 90       	pop	r0
     f08:	1f 90       	pop	r1
     f0a:	18 95       	reti

00000f0c <xTaskCreateStatic>:
xTaskCreateStatic():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:580
                                    const uint32_t ulStackDepth,
                                    void * const pvParameters,
                                    UBaseType_t uxPriority,
                                    StackType_t * const puxStackBuffer,
                                    StaticTask_t * const pxTaskBuffer )
    {
     f0c:	8f 92       	push	r8
     f0e:	9f 92       	push	r9
     f10:	af 92       	push	r10
     f12:	bf 92       	push	r11
     f14:	cf 92       	push	r12
     f16:	df 92       	push	r13
     f18:	ef 92       	push	r14
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	df 93       	push	r29
     f20:	cf 93       	push	r28
     f22:	cd b7       	in	r28, 0x3d	; 61
     f24:	de b7       	in	r29, 0x3e	; 62
     f26:	63 97       	sbiw	r28, 0x13	; 19
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	cd bf       	out	0x3d, r28	; 61
     f32:	9e 83       	std	Y+6, r25	; 0x06
     f34:	8d 83       	std	Y+5, r24	; 0x05
     f36:	78 87       	std	Y+8, r23	; 0x08
     f38:	6f 83       	std	Y+7, r22	; 0x07
     f3a:	29 87       	std	Y+9, r18	; 0x09
     f3c:	3a 87       	std	Y+10, r19	; 0x0a
     f3e:	4b 87       	std	Y+11, r20	; 0x0b
     f40:	5c 87       	std	Y+12, r21	; 0x0c
     f42:	1e 87       	std	Y+14, r17	; 0x0e
     f44:	0d 87       	std	Y+13, r16	; 0x0d
     f46:	ef 86       	std	Y+15, r14	; 0x0f
     f48:	d9 8a       	std	Y+17, r13	; 0x11
     f4a:	c8 8a       	std	Y+16, r12	; 0x10
     f4c:	bb 8a       	std	Y+19, r11	; 0x13
     f4e:	aa 8a       	std	Y+18, r10	; 0x12
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:598
                configASSERT( xSize == sizeof( TCB_t ) );
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
            }
        #endif /* configASSERT_DEFINED */

        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
     f50:	8a 89       	ldd	r24, Y+18	; 0x12
     f52:	9b 89       	ldd	r25, Y+19	; 0x13
     f54:	00 97       	sbiw	r24, 0x00	; 0
     f56:	41 f1       	breq	.+80     	; 0xfa8 <xTaskCreateStatic+0x9c>
     f58:	88 89       	ldd	r24, Y+16	; 0x10
     f5a:	99 89       	ldd	r25, Y+17	; 0x11
     f5c:	00 97       	sbiw	r24, 0x00	; 0
     f5e:	21 f1       	breq	.+72     	; 0xfa8 <xTaskCreateStatic+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:602
        {
            /* The memory used for the task's TCB and stack are passed into this
             * function - use them. */
            pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
     f60:	8a 89       	ldd	r24, Y+18	; 0x12
     f62:	9b 89       	ldd	r25, Y+19	; 0x13
     f64:	9a 83       	std	Y+2, r25	; 0x02
     f66:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:603
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
     f68:	e9 81       	ldd	r30, Y+1	; 0x01
     f6a:	fa 81       	ldd	r31, Y+2	; 0x02
     f6c:	88 89       	ldd	r24, Y+16	; 0x10
     f6e:	99 89       	ldd	r25, Y+17	; 0x11
     f70:	90 8f       	std	Z+24, r25	; 0x18
     f72:	87 8b       	std	Z+23, r24	; 0x17
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:613
                     * task was created statically in case the task is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
     f74:	8d 81       	ldd	r24, Y+5	; 0x05
     f76:	9e 81       	ldd	r25, Y+6	; 0x06
     f78:	6f 81       	ldd	r22, Y+7	; 0x07
     f7a:	78 85       	ldd	r23, Y+8	; 0x08
     f7c:	29 85       	ldd	r18, Y+9	; 0x09
     f7e:	3a 85       	ldd	r19, Y+10	; 0x0a
     f80:	4b 85       	ldd	r20, Y+11	; 0x0b
     f82:	5c 85       	ldd	r21, Y+12	; 0x0c
     f84:	ed 85       	ldd	r30, Y+13	; 0x0d
     f86:	fe 85       	ldd	r31, Y+14	; 0x0e
     f88:	de 01       	movw	r26, r28
     f8a:	13 96       	adiw	r26, 0x03	; 3
     f8c:	a9 80       	ldd	r10, Y+1	; 0x01
     f8e:	ba 80       	ldd	r11, Y+2	; 0x02
     f90:	8f 01       	movw	r16, r30
     f92:	ef 84       	ldd	r14, Y+15	; 0x0f
     f94:	6d 01       	movw	r12, r26
     f96:	88 24       	eor	r8, r8
     f98:	99 24       	eor	r9, r9
     f9a:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <prvInitialiseNewTask>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:614
            prvAddNewTaskToReadyList( pxNewTCB );
     f9e:	89 81       	ldd	r24, Y+1	; 0x01
     fa0:	9a 81       	ldd	r25, Y+2	; 0x02
     fa2:	0e 94 c1 08 	call	0x1182	; 0x1182 <prvAddNewTaskToReadyList>
     fa6:	02 c0       	rjmp	.+4      	; 0xfac <xTaskCreateStatic+0xa0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:618
        }
        else
        {
            xReturn = NULL;
     fa8:	1c 82       	std	Y+4, r1	; 0x04
     faa:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:621
        }

        return xReturn;
     fac:	8b 81       	ldd	r24, Y+3	; 0x03
     fae:	9c 81       	ldd	r25, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:622
    }
     fb0:	63 96       	adiw	r28, 0x13	; 19
     fb2:	0f b6       	in	r0, 0x3f	; 63
     fb4:	f8 94       	cli
     fb6:	de bf       	out	0x3e, r29	; 62
     fb8:	0f be       	out	0x3f, r0	; 63
     fba:	cd bf       	out	0x3d, r28	; 61
     fbc:	cf 91       	pop	r28
     fbe:	df 91       	pop	r29
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	ef 90       	pop	r14
     fc6:	df 90       	pop	r13
     fc8:	cf 90       	pop	r12
     fca:	bf 90       	pop	r11
     fcc:	af 90       	pop	r10
     fce:	9f 90       	pop	r9
     fd0:	8f 90       	pop	r8
     fd2:	08 95       	ret

00000fd4 <prvInitialiseNewTask>:
prvInitialiseNewTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:825
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
     fd4:	8f 92       	push	r8
     fd6:	9f 92       	push	r9
     fd8:	af 92       	push	r10
     fda:	bf 92       	push	r11
     fdc:	cf 92       	push	r12
     fde:	df 92       	push	r13
     fe0:	ef 92       	push	r14
     fe2:	0f 93       	push	r16
     fe4:	1f 93       	push	r17
     fe6:	df 93       	push	r29
     fe8:	cf 93       	push	r28
     fea:	cd b7       	in	r28, 0x3d	; 61
     fec:	de b7       	in	r29, 0x3e	; 62
     fee:	64 97       	sbiw	r28, 0x14	; 20
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	f8 94       	cli
     ff4:	de bf       	out	0x3e, r29	; 62
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	cd bf       	out	0x3d, r28	; 61
     ffa:	9d 83       	std	Y+5, r25	; 0x05
     ffc:	8c 83       	std	Y+4, r24	; 0x04
     ffe:	7f 83       	std	Y+7, r23	; 0x07
    1000:	6e 83       	std	Y+6, r22	; 0x06
    1002:	28 87       	std	Y+8, r18	; 0x08
    1004:	39 87       	std	Y+9, r19	; 0x09
    1006:	4a 87       	std	Y+10, r20	; 0x0a
    1008:	5b 87       	std	Y+11, r21	; 0x0b
    100a:	1d 87       	std	Y+13, r17	; 0x0d
    100c:	0c 87       	std	Y+12, r16	; 0x0c
    100e:	ee 86       	std	Y+14, r14	; 0x0e
    1010:	d8 8a       	std	Y+16, r13	; 0x10
    1012:	cf 86       	std	Y+15, r12	; 0x0f
    1014:	ba 8a       	std	Y+18, r11	; 0x12
    1016:	a9 8a       	std	Y+17, r10	; 0x11
    1018:	9c 8a       	std	Y+20, r9	; 0x14
    101a:	8b 8a       	std	Y+19, r8	; 0x13
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:848

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    101c:	e9 89       	ldd	r30, Y+17	; 0x11
    101e:	fa 89       	ldd	r31, Y+18	; 0x12
    1020:	87 89       	ldd	r24, Z+23	; 0x17
    1022:	90 8d       	ldd	r25, Z+24	; 0x18
    1024:	28 85       	ldd	r18, Y+8	; 0x08
    1026:	39 85       	ldd	r19, Y+9	; 0x09
    1028:	65 ea       	ldi	r22, 0xA5	; 165
    102a:	70 e0       	ldi	r23, 0x00	; 0
    102c:	a9 01       	movw	r20, r18
    102e:	0e 94 28 23 	call	0x4650	; 0x4650 <memset>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:858
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    1032:	e9 89       	ldd	r30, Y+17	; 0x11
    1034:	fa 89       	ldd	r31, Y+18	; 0x12
    1036:	27 89       	ldd	r18, Z+23	; 0x17
    1038:	30 8d       	ldd	r19, Z+24	; 0x18
    103a:	88 85       	ldd	r24, Y+8	; 0x08
    103c:	99 85       	ldd	r25, Y+9	; 0x09
    103e:	01 97       	sbiw	r24, 0x01	; 1
    1040:	82 0f       	add	r24, r18
    1042:	93 1f       	adc	r25, r19
    1044:	9b 83       	std	Y+3, r25	; 0x03
    1046:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:886
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    1048:	8e 81       	ldd	r24, Y+6	; 0x06
    104a:	9f 81       	ldd	r25, Y+7	; 0x07
    104c:	00 97       	sbiw	r24, 0x00	; 0
    104e:	51 f1       	breq	.+84     	; 0x10a4 <prvInitialiseNewTask+0xd0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:888
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1050:	19 82       	std	Y+1, r1	; 0x01
    1052:	21 c0       	rjmp	.+66     	; 0x1096 <prvInitialiseNewTask+0xc2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:890
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1054:	89 81       	ldd	r24, Y+1	; 0x01
    1056:	48 2f       	mov	r20, r24
    1058:	50 e0       	ldi	r21, 0x00	; 0
    105a:	89 81       	ldd	r24, Y+1	; 0x01
    105c:	28 2f       	mov	r18, r24
    105e:	30 e0       	ldi	r19, 0x00	; 0
    1060:	8e 81       	ldd	r24, Y+6	; 0x06
    1062:	9f 81       	ldd	r25, Y+7	; 0x07
    1064:	fc 01       	movw	r30, r24
    1066:	e2 0f       	add	r30, r18
    1068:	f3 1f       	adc	r31, r19
    106a:	20 81       	ld	r18, Z
    106c:	89 89       	ldd	r24, Y+17	; 0x11
    106e:	9a 89       	ldd	r25, Y+18	; 0x12
    1070:	84 0f       	add	r24, r20
    1072:	95 1f       	adc	r25, r21
    1074:	fc 01       	movw	r30, r24
    1076:	79 96       	adiw	r30, 0x19	; 25
    1078:	20 83       	st	Z, r18
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:895

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    107a:	89 81       	ldd	r24, Y+1	; 0x01
    107c:	28 2f       	mov	r18, r24
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	8e 81       	ldd	r24, Y+6	; 0x06
    1082:	9f 81       	ldd	r25, Y+7	; 0x07
    1084:	fc 01       	movw	r30, r24
    1086:	e2 0f       	add	r30, r18
    1088:	f3 1f       	adc	r31, r19
    108a:	80 81       	ld	r24, Z
    108c:	88 23       	and	r24, r24
    108e:	31 f0       	breq	.+12     	; 0x109c <prvInitialiseNewTask+0xc8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:888
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	8f 5f       	subi	r24, 0xFF	; 255
    1094:	89 83       	std	Y+1, r24	; 0x01
    1096:	89 81       	ldd	r24, Y+1	; 0x01
    1098:	88 30       	cpi	r24, 0x08	; 8
    109a:	e0 f2       	brcs	.-72     	; 0x1054 <prvInitialiseNewTask+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:907
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    109c:	e9 89       	ldd	r30, Y+17	; 0x11
    109e:	fa 89       	ldd	r31, Y+18	; 0x12
    10a0:	10 a2       	std	Z+32, r1	; 0x20
    10a2:	03 c0       	rjmp	.+6      	; 0x10aa <prvInitialiseNewTask+0xd6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:913
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    10a4:	e9 89       	ldd	r30, Y+17	; 0x11
    10a6:	fa 89       	ldd	r31, Y+18	; 0x12
    10a8:	11 8e       	std	Z+25, r1	; 0x19
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:918
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    10aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    10ac:	84 30       	cpi	r24, 0x04	; 4
    10ae:	10 f0       	brcs	.+4      	; 0x10b4 <prvInitialiseNewTask+0xe0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:920
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    10b0:	83 e0       	ldi	r24, 0x03	; 3
    10b2:	8e 87       	std	Y+14, r24	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:927
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    10b4:	e9 89       	ldd	r30, Y+17	; 0x11
    10b6:	fa 89       	ldd	r31, Y+18	; 0x12
    10b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    10ba:	86 8b       	std	Z+22, r24	; 0x16
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:930
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
    10bc:	e9 89       	ldd	r30, Y+17	; 0x11
    10be:	fa 89       	ldd	r31, Y+18	; 0x12
    10c0:	8e 85       	ldd	r24, Y+14	; 0x0e
    10c2:	81 a3       	std	Z+33, r24	; 0x21
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:931
            pxNewTCB->uxMutexesHeld = 0;
    10c4:	e9 89       	ldd	r30, Y+17	; 0x11
    10c6:	fa 89       	ldd	r31, Y+18	; 0x12
    10c8:	12 a2       	std	Z+34, r1	; 0x22
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:935
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    10ca:	89 89       	ldd	r24, Y+17	; 0x11
    10cc:	9a 89       	ldd	r25, Y+18	; 0x12
    10ce:	02 96       	adiw	r24, 0x02	; 2
    10d0:	0e 94 2e 20 	call	0x405c	; 0x405c <vListInitialiseItem>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:936
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    10d4:	89 89       	ldd	r24, Y+17	; 0x11
    10d6:	9a 89       	ldd	r25, Y+18	; 0x12
    10d8:	0c 96       	adiw	r24, 0x0c	; 12
    10da:	0e 94 2e 20 	call	0x405c	; 0x405c <vListInitialiseItem>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:940

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    10de:	e9 89       	ldd	r30, Y+17	; 0x11
    10e0:	fa 89       	ldd	r31, Y+18	; 0x12
    10e2:	89 89       	ldd	r24, Y+17	; 0x11
    10e4:	9a 89       	ldd	r25, Y+18	; 0x12
    10e6:	91 87       	std	Z+9, r25	; 0x09
    10e8:	80 87       	std	Z+8, r24	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:943

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    10ec:	28 2f       	mov	r18, r24
    10ee:	30 e0       	ldi	r19, 0x00	; 0
    10f0:	84 e0       	ldi	r24, 0x04	; 4
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	82 1b       	sub	r24, r18
    10f6:	93 0b       	sbc	r25, r19
    10f8:	e9 89       	ldd	r30, Y+17	; 0x11
    10fa:	fa 89       	ldd	r31, Y+18	; 0x12
    10fc:	95 87       	std	Z+13, r25	; 0x0d
    10fe:	84 87       	std	Z+12, r24	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:944
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1100:	e9 89       	ldd	r30, Y+17	; 0x11
    1102:	fa 89       	ldd	r31, Y+18	; 0x12
    1104:	89 89       	ldd	r24, Y+17	; 0x11
    1106:	9a 89       	ldd	r25, Y+18	; 0x12
    1108:	93 8b       	std	Z+19, r25	; 0x13
    110a:	82 8b       	std	Z+18, r24	; 0x12
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:983
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    110c:	89 89       	ldd	r24, Y+17	; 0x11
    110e:	9a 89       	ldd	r25, Y+18	; 0x12
    1110:	83 96       	adiw	r24, 0x23	; 35
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	70 e0       	ldi	r23, 0x00	; 0
    1116:	44 e0       	ldi	r20, 0x04	; 4
    1118:	50 e0       	ldi	r21, 0x00	; 0
    111a:	0e 94 28 23 	call	0x4650	; 0x4650 <memset>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:984
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    111e:	89 89       	ldd	r24, Y+17	; 0x11
    1120:	9a 89       	ldd	r25, Y+18	; 0x12
    1122:	87 96       	adiw	r24, 0x27	; 39
    1124:	60 e0       	ldi	r22, 0x00	; 0
    1126:	70 e0       	ldi	r23, 0x00	; 0
    1128:	41 e0       	ldi	r20, 0x01	; 1
    112a:	50 e0       	ldi	r21, 0x00	; 0
    112c:	0e 94 28 23 	call	0x4650	; 0x4650 <memset>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1049
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1130:	8a 81       	ldd	r24, Y+2	; 0x02
    1132:	9b 81       	ldd	r25, Y+3	; 0x03
    1134:	2c 81       	ldd	r18, Y+4	; 0x04
    1136:	3d 81       	ldd	r19, Y+5	; 0x05
    1138:	4c 85       	ldd	r20, Y+12	; 0x0c
    113a:	5d 85       	ldd	r21, Y+13	; 0x0d
    113c:	b9 01       	movw	r22, r18
    113e:	0e 94 3a 21 	call	0x4274	; 0x4274 <pxPortInitialiseStack>
    1142:	e9 89       	ldd	r30, Y+17	; 0x11
    1144:	fa 89       	ldd	r31, Y+18	; 0x12
    1146:	91 83       	std	Z+1, r25	; 0x01
    1148:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1055
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    114a:	8f 85       	ldd	r24, Y+15	; 0x0f
    114c:	98 89       	ldd	r25, Y+16	; 0x10
    114e:	00 97       	sbiw	r24, 0x00	; 0
    1150:	31 f0       	breq	.+12     	; 0x115e <prvInitialiseNewTask+0x18a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1059
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1152:	ef 85       	ldd	r30, Y+15	; 0x0f
    1154:	f8 89       	ldd	r31, Y+16	; 0x10
    1156:	89 89       	ldd	r24, Y+17	; 0x11
    1158:	9a 89       	ldd	r25, Y+18	; 0x12
    115a:	91 83       	std	Z+1, r25	; 0x01
    115c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1065
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    115e:	64 96       	adiw	r28, 0x14	; 20
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	de bf       	out	0x3e, r29	; 62
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	cd bf       	out	0x3d, r28	; 61
    116a:	cf 91       	pop	r28
    116c:	df 91       	pop	r29
    116e:	1f 91       	pop	r17
    1170:	0f 91       	pop	r16
    1172:	ef 90       	pop	r14
    1174:	df 90       	pop	r13
    1176:	cf 90       	pop	r12
    1178:	bf 90       	pop	r11
    117a:	af 90       	pop	r10
    117c:	9f 90       	pop	r9
    117e:	8f 90       	pop	r8
    1180:	08 95       	ret

00001182 <prvAddNewTaskToReadyList>:
prvAddNewTaskToReadyList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1069
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    1182:	df 93       	push	r29
    1184:	cf 93       	push	r28
    1186:	00 d0       	rcall	.+0      	; 0x1188 <prvAddNewTaskToReadyList+0x6>
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	9a 83       	std	Y+2, r25	; 0x02
    118e:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1072
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1074
    {
        uxCurrentNumberOfTasks++;
    1196:	80 91 a8 03 	lds	r24, 0x03A8
    119a:	8f 5f       	subi	r24, 0xFF	; 255
    119c:	80 93 a8 03 	sts	0x03A8, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1076

        if( pxCurrentTCB == NULL )
    11a0:	80 91 a5 03 	lds	r24, 0x03A5
    11a4:	90 91 a6 03 	lds	r25, 0x03A6
    11a8:	00 97       	sbiw	r24, 0x00	; 0
    11aa:	69 f4       	brne	.+26     	; 0x11c6 <prvAddNewTaskToReadyList+0x44>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1080
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    11ac:	89 81       	ldd	r24, Y+1	; 0x01
    11ae:	9a 81       	ldd	r25, Y+2	; 0x02
    11b0:	90 93 a6 03 	sts	0x03A6, r25
    11b4:	80 93 a5 03 	sts	0x03A5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1082

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    11b8:	80 91 a8 03 	lds	r24, 0x03A8
    11bc:	81 30       	cpi	r24, 0x01	; 1
    11be:	b9 f4       	brne	.+46     	; 0x11ee <prvAddNewTaskToReadyList+0x6c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1087
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    11c0:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <prvInitialiseTaskLists>
    11c4:	14 c0       	rjmp	.+40     	; 0x11ee <prvAddNewTaskToReadyList+0x6c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1099
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    11c6:	80 91 ac 03 	lds	r24, 0x03AC
    11ca:	88 23       	and	r24, r24
    11cc:	81 f4       	brne	.+32     	; 0x11ee <prvAddNewTaskToReadyList+0x6c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1101
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    11ce:	e0 91 a5 03 	lds	r30, 0x03A5
    11d2:	f0 91 a6 03 	lds	r31, 0x03A6
    11d6:	96 89       	ldd	r25, Z+22	; 0x16
    11d8:	e9 81       	ldd	r30, Y+1	; 0x01
    11da:	fa 81       	ldd	r31, Y+2	; 0x02
    11dc:	86 89       	ldd	r24, Z+22	; 0x16
    11de:	89 17       	cp	r24, r25
    11e0:	30 f0       	brcs	.+12     	; 0x11ee <prvAddNewTaskToReadyList+0x6c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1103
                {
                    pxCurrentTCB = pxNewTCB;
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
    11e6:	90 93 a6 03 	sts	0x03A6, r25
    11ea:	80 93 a5 03 	sts	0x03A5, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1116
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    11ee:	80 91 b1 03 	lds	r24, 0x03B1
    11f2:	8f 5f       	subi	r24, 0xFF	; 255
    11f4:	80 93 b1 03 	sts	0x03B1, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1126
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    11f8:	e9 81       	ldd	r30, Y+1	; 0x01
    11fa:	fa 81       	ldd	r31, Y+2	; 0x02
    11fc:	96 89       	ldd	r25, Z+22	; 0x16
    11fe:	80 91 ab 03 	lds	r24, 0x03AB
    1202:	89 17       	cp	r24, r25
    1204:	28 f4       	brcc	.+10     	; 0x1210 <prvAddNewTaskToReadyList+0x8e>
    1206:	e9 81       	ldd	r30, Y+1	; 0x01
    1208:	fa 81       	ldd	r31, Y+2	; 0x02
    120a:	86 89       	ldd	r24, Z+22	; 0x16
    120c:	80 93 ab 03 	sts	0x03AB, r24
    1210:	e9 81       	ldd	r30, Y+1	; 0x01
    1212:	fa 81       	ldd	r31, Y+2	; 0x02
    1214:	86 89       	ldd	r24, Z+22	; 0x16
    1216:	28 2f       	mov	r18, r24
    1218:	30 e0       	ldi	r19, 0x00	; 0
    121a:	c9 01       	movw	r24, r18
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	88 0f       	add	r24, r24
    1226:	99 1f       	adc	r25, r25
    1228:	82 0f       	add	r24, r18
    122a:	93 1f       	adc	r25, r19
    122c:	ac 01       	movw	r20, r24
    122e:	49 54       	subi	r20, 0x49	; 73
    1230:	5c 4f       	sbci	r21, 0xFC	; 252
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	9a 81       	ldd	r25, Y+2	; 0x02
    1236:	9c 01       	movw	r18, r24
    1238:	2e 5f       	subi	r18, 0xFE	; 254
    123a:	3f 4f       	sbci	r19, 0xFF	; 255
    123c:	ca 01       	movw	r24, r20
    123e:	b9 01       	movw	r22, r18
    1240:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1130

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1132

    if( xSchedulerRunning != pdFALSE )
    1248:	80 91 ac 03 	lds	r24, 0x03AC
    124c:	88 23       	and	r24, r24
    124e:	61 f0       	breq	.+24     	; 0x1268 <prvAddNewTaskToReadyList+0xe6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1136
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1250:	e0 91 a5 03 	lds	r30, 0x03A5
    1254:	f0 91 a6 03 	lds	r31, 0x03A6
    1258:	96 89       	ldd	r25, Z+22	; 0x16
    125a:	e9 81       	ldd	r30, Y+1	; 0x01
    125c:	fa 81       	ldd	r31, Y+2	; 0x02
    125e:	86 89       	ldd	r24, Z+22	; 0x16
    1260:	98 17       	cp	r25, r24
    1262:	10 f4       	brcc	.+4      	; 0x1268 <prvAddNewTaskToReadyList+0xe6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1138
        {
            taskYIELD_IF_USING_PREEMPTION();
    1264:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1149
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    1268:	0f 90       	pop	r0
    126a:	0f 90       	pop	r0
    126c:	cf 91       	pop	r28
    126e:	df 91       	pop	r29
    1270:	08 95       	ret

00001272 <vTaskDelete>:
vTaskDelete():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1155
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    1272:	df 93       	push	r29
    1274:	cf 93       	push	r28
    1276:	00 d0       	rcall	.+0      	; 0x1278 <vTaskDelete+0x6>
    1278:	00 d0       	rcall	.+0      	; 0x127a <vTaskDelete+0x8>
    127a:	00 d0       	rcall	.+0      	; 0x127c <vTaskDelete+0xa>
    127c:	cd b7       	in	r28, 0x3d	; 61
    127e:	de b7       	in	r29, 0x3e	; 62
    1280:	9c 83       	std	Y+4, r25	; 0x04
    1282:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1158
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    1284:	0f b6       	in	r0, 0x3f	; 63
    1286:	f8 94       	cli
    1288:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1162
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    128a:	8b 81       	ldd	r24, Y+3	; 0x03
    128c:	9c 81       	ldd	r25, Y+4	; 0x04
    128e:	00 97       	sbiw	r24, 0x00	; 0
    1290:	39 f4       	brne	.+14     	; 0x12a0 <vTaskDelete+0x2e>
    1292:	80 91 a5 03 	lds	r24, 0x03A5
    1296:	90 91 a6 03 	lds	r25, 0x03A6
    129a:	9e 83       	std	Y+6, r25	; 0x06
    129c:	8d 83       	std	Y+5, r24	; 0x05
    129e:	04 c0       	rjmp	.+8      	; 0x12a8 <vTaskDelete+0x36>
    12a0:	8b 81       	ldd	r24, Y+3	; 0x03
    12a2:	9c 81       	ldd	r25, Y+4	; 0x04
    12a4:	9e 83       	std	Y+6, r25	; 0x06
    12a6:	8d 83       	std	Y+5, r24	; 0x05
    12a8:	8d 81       	ldd	r24, Y+5	; 0x05
    12aa:	9e 81       	ldd	r25, Y+6	; 0x06
    12ac:	9a 83       	std	Y+2, r25	; 0x02
    12ae:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1165

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    12b0:	89 81       	ldd	r24, Y+1	; 0x01
    12b2:	9a 81       	ldd	r25, Y+2	; 0x02
    12b4:	02 96       	adiw	r24, 0x02	; 2
    12b6:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1175
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    12ba:	e9 81       	ldd	r30, Y+1	; 0x01
    12bc:	fa 81       	ldd	r31, Y+2	; 0x02
    12be:	84 89       	ldd	r24, Z+20	; 0x14
    12c0:	95 89       	ldd	r25, Z+21	; 0x15
    12c2:	00 97       	sbiw	r24, 0x00	; 0
    12c4:	29 f0       	breq	.+10     	; 0x12d0 <vTaskDelete+0x5e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1177
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    12c6:	89 81       	ldd	r24, Y+1	; 0x01
    12c8:	9a 81       	ldd	r25, Y+2	; 0x02
    12ca:	0c 96       	adiw	r24, 0x0c	; 12
    12cc:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1188

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    12d0:	80 91 b1 03 	lds	r24, 0x03B1
    12d4:	8f 5f       	subi	r24, 0xFF	; 255
    12d6:	80 93 b1 03 	sts	0x03B1, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1190

            if( pxTCB == pxCurrentTCB )
    12da:	20 91 a5 03 	lds	r18, 0x03A5
    12de:	30 91 a6 03 	lds	r19, 0x03A6
    12e2:	89 81       	ldd	r24, Y+1	; 0x01
    12e4:	9a 81       	ldd	r25, Y+2	; 0x02
    12e6:	82 17       	cp	r24, r18
    12e8:	93 07       	cpc	r25, r19
    12ea:	81 f4       	brne	.+32     	; 0x130c <vTaskDelete+0x9a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1197
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    12ec:	89 81       	ldd	r24, Y+1	; 0x01
    12ee:	9a 81       	ldd	r25, Y+2	; 0x02
    12f0:	9c 01       	movw	r18, r24
    12f2:	2e 5f       	subi	r18, 0xFE	; 254
    12f4:	3f 4f       	sbci	r19, 0xFF	; 255
    12f6:	8a ef       	ldi	r24, 0xFA	; 250
    12f8:	93 e0       	ldi	r25, 0x03	; 3
    12fa:	b9 01       	movw	r22, r18
    12fc:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1202

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    1300:	80 91 a7 03 	lds	r24, 0x03A7
    1304:	8f 5f       	subi	r24, 0xFF	; 255
    1306:	80 93 a7 03 	sts	0x03A7, r24
    130a:	0b c0       	rjmp	.+22     	; 0x1322 <vTaskDelete+0xb0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1217
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    130c:	80 91 a8 03 	lds	r24, 0x03A8
    1310:	81 50       	subi	r24, 0x01	; 1
    1312:	80 93 a8 03 	sts	0x03A8, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1219
                traceTASK_DELETE( pxTCB );
                prvDeleteTCB( pxTCB );
    1316:	89 81       	ldd	r24, Y+1	; 0x01
    1318:	9a 81       	ldd	r25, Y+2	; 0x02
    131a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <prvDeleteTCB>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1223

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    131e:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <prvResetNextTaskUnblockTime>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1226
            }
        }
        taskEXIT_CRITICAL();
    1322:	0f 90       	pop	r0
    1324:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1230

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    1326:	80 91 ac 03 	lds	r24, 0x03AC
    132a:	88 23       	and	r24, r24
    132c:	59 f0       	breq	.+22     	; 0x1344 <vTaskDelete+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1232
        {
            if( pxTCB == pxCurrentTCB )
    132e:	20 91 a5 03 	lds	r18, 0x03A5
    1332:	30 91 a6 03 	lds	r19, 0x03A6
    1336:	89 81       	ldd	r24, Y+1	; 0x01
    1338:	9a 81       	ldd	r25, Y+2	; 0x02
    133a:	82 17       	cp	r24, r18
    133c:	93 07       	cpc	r25, r19
    133e:	11 f4       	brne	.+4      	; 0x1344 <vTaskDelete+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1235
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    1340:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1242
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    1344:	26 96       	adiw	r28, 0x06	; 6
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	de bf       	out	0x3e, r29	; 62
    134c:	0f be       	out	0x3f, r0	; 63
    134e:	cd bf       	out	0x3d, r28	; 61
    1350:	cf 91       	pop	r28
    1352:	df 91       	pop	r29
    1354:	08 95       	ret

00001356 <xTaskDelayUntil>:
xTaskDelayUntil():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1251

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    1356:	df 93       	push	r29
    1358:	cf 93       	push	r28
    135a:	cd b7       	in	r28, 0x3d	; 61
    135c:	de b7       	in	r29, 0x3e	; 62
    135e:	2a 97       	sbiw	r28, 0x0a	; 10
    1360:	0f b6       	in	r0, 0x3f	; 63
    1362:	f8 94       	cli
    1364:	de bf       	out	0x3e, r29	; 62
    1366:	0f be       	out	0x3f, r0	; 63
    1368:	cd bf       	out	0x3d, r28	; 61
    136a:	98 87       	std	Y+8, r25	; 0x08
    136c:	8f 83       	std	Y+7, r24	; 0x07
    136e:	7a 87       	std	Y+10, r23	; 0x0a
    1370:	69 87       	std	Y+9, r22	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1253
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1372:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1259

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    1374:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1263
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    1378:	80 91 a9 03 	lds	r24, 0x03A9
    137c:	90 91 aa 03 	lds	r25, 0x03AA
    1380:	9a 83       	std	Y+2, r25	; 0x02
    1382:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1266

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1384:	ef 81       	ldd	r30, Y+7	; 0x07
    1386:	f8 85       	ldd	r31, Y+8	; 0x08
    1388:	20 81       	ld	r18, Z
    138a:	31 81       	ldd	r19, Z+1	; 0x01
    138c:	89 85       	ldd	r24, Y+9	; 0x09
    138e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1390:	82 0f       	add	r24, r18
    1392:	93 1f       	adc	r25, r19
    1394:	9e 83       	std	Y+6, r25	; 0x06
    1396:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1268

            if( xConstTickCount < *pxPreviousWakeTime )
    1398:	ef 81       	ldd	r30, Y+7	; 0x07
    139a:	f8 85       	ldd	r31, Y+8	; 0x08
    139c:	20 81       	ld	r18, Z
    139e:	31 81       	ldd	r19, Z+1	; 0x01
    13a0:	89 81       	ldd	r24, Y+1	; 0x01
    13a2:	9a 81       	ldd	r25, Y+2	; 0x02
    13a4:	82 17       	cp	r24, r18
    13a6:	93 07       	cpc	r25, r19
    13a8:	98 f4       	brcc	.+38     	; 0x13d0 <xTaskDelayUntil+0x7a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1275
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    13aa:	ef 81       	ldd	r30, Y+7	; 0x07
    13ac:	f8 85       	ldd	r31, Y+8	; 0x08
    13ae:	20 81       	ld	r18, Z
    13b0:	31 81       	ldd	r19, Z+1	; 0x01
    13b2:	8d 81       	ldd	r24, Y+5	; 0x05
    13b4:	9e 81       	ldd	r25, Y+6	; 0x06
    13b6:	82 17       	cp	r24, r18
    13b8:	93 07       	cpc	r25, r19
    13ba:	e0 f4       	brcc	.+56     	; 0x13f4 <xTaskDelayUntil+0x9e>
    13bc:	2d 81       	ldd	r18, Y+5	; 0x05
    13be:	3e 81       	ldd	r19, Y+6	; 0x06
    13c0:	89 81       	ldd	r24, Y+1	; 0x01
    13c2:	9a 81       	ldd	r25, Y+2	; 0x02
    13c4:	82 17       	cp	r24, r18
    13c6:	93 07       	cpc	r25, r19
    13c8:	a8 f4       	brcc	.+42     	; 0x13f4 <xTaskDelayUntil+0x9e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1277
                {
                    xShouldDelay = pdTRUE;
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	8b 83       	std	Y+3, r24	; 0x03
    13ce:	12 c0       	rjmp	.+36     	; 0x13f4 <xTaskDelayUntil+0x9e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1289
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    13d0:	ef 81       	ldd	r30, Y+7	; 0x07
    13d2:	f8 85       	ldd	r31, Y+8	; 0x08
    13d4:	20 81       	ld	r18, Z
    13d6:	31 81       	ldd	r19, Z+1	; 0x01
    13d8:	8d 81       	ldd	r24, Y+5	; 0x05
    13da:	9e 81       	ldd	r25, Y+6	; 0x06
    13dc:	82 17       	cp	r24, r18
    13de:	93 07       	cpc	r25, r19
    13e0:	38 f0       	brcs	.+14     	; 0x13f0 <xTaskDelayUntil+0x9a>
    13e2:	2d 81       	ldd	r18, Y+5	; 0x05
    13e4:	3e 81       	ldd	r19, Y+6	; 0x06
    13e6:	89 81       	ldd	r24, Y+1	; 0x01
    13e8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ea:	82 17       	cp	r24, r18
    13ec:	93 07       	cpc	r25, r19
    13ee:	10 f4       	brcc	.+4      	; 0x13f4 <xTaskDelayUntil+0x9e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1291
                {
                    xShouldDelay = pdTRUE;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1300
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    13f4:	ef 81       	ldd	r30, Y+7	; 0x07
    13f6:	f8 85       	ldd	r31, Y+8	; 0x08
    13f8:	8d 81       	ldd	r24, Y+5	; 0x05
    13fa:	9e 81       	ldd	r25, Y+6	; 0x06
    13fc:	91 83       	std	Z+1, r25	; 0x01
    13fe:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1302

            if( xShouldDelay != pdFALSE )
    1400:	8b 81       	ldd	r24, Y+3	; 0x03
    1402:	88 23       	and	r24, r24
    1404:	49 f0       	breq	.+18     	; 0x1418 <xTaskDelayUntil+0xc2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1308
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1406:	8d 81       	ldd	r24, Y+5	; 0x05
    1408:	9e 81       	ldd	r25, Y+6	; 0x06
    140a:	29 81       	ldd	r18, Y+1	; 0x01
    140c:	3a 81       	ldd	r19, Y+2	; 0x02
    140e:	82 1b       	sub	r24, r18
    1410:	93 0b       	sbc	r25, r19
    1412:	60 e0       	ldi	r22, 0x00	; 0
    1414:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1315
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    1418:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    141c:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1319

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    141e:	8c 81       	ldd	r24, Y+4	; 0x04
    1420:	88 23       	and	r24, r24
    1422:	11 f4       	brne	.+4      	; 0x1428 <xTaskDelayUntil+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1321
        {
            portYIELD_WITHIN_API();
    1424:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1328
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    1428:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1329
    }
    142a:	2a 96       	adiw	r28, 0x0a	; 10
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	cf 91       	pop	r28
    1438:	df 91       	pop	r29
    143a:	08 95       	ret

0000143c <vTaskDelay>:
vTaskDelay():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1337
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    143c:	df 93       	push	r29
    143e:	cf 93       	push	r28
    1440:	00 d0       	rcall	.+0      	; 0x1442 <vTaskDelay+0x6>
    1442:	0f 92       	push	r0
    1444:	cd b7       	in	r28, 0x3d	; 61
    1446:	de b7       	in	r29, 0x3e	; 62
    1448:	9b 83       	std	Y+3, r25	; 0x03
    144a:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1338
        BaseType_t xAlreadyYielded = pdFALSE;
    144c:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1341

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    144e:	8a 81       	ldd	r24, Y+2	; 0x02
    1450:	9b 81       	ldd	r25, Y+3	; 0x03
    1452:	00 97       	sbiw	r24, 0x00	; 0
    1454:	51 f0       	breq	.+20     	; 0x146a <vTaskDelay+0x2e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1344
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    1456:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1355
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    145a:	8a 81       	ldd	r24, Y+2	; 0x02
    145c:	9b 81       	ldd	r25, Y+3	; 0x03
    145e:	60 e0       	ldi	r22, 0x00	; 0
    1460:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1357
            }
            xAlreadyYielded = xTaskResumeAll();
    1464:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    1468:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1366
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    146a:	89 81       	ldd	r24, Y+1	; 0x01
    146c:	88 23       	and	r24, r24
    146e:	11 f4       	brne	.+4      	; 0x1474 <vTaskDelay+0x38>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1368
        {
            portYIELD_WITHIN_API();
    1470:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1374
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    1474:	0f 90       	pop	r0
    1476:	0f 90       	pop	r0
    1478:	0f 90       	pop	r0
    147a:	cf 91       	pop	r28
    147c:	df 91       	pop	r29
    147e:	08 95       	ret

00001480 <vTaskStartScheduler>:
vTaskStartScheduler():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1988

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1480:	af 92       	push	r10
    1482:	bf 92       	push	r11
    1484:	cf 92       	push	r12
    1486:	df 92       	push	r13
    1488:	ef 92       	push	r14
    148a:	ff 92       	push	r15
    148c:	0f 93       	push	r16
    148e:	1f 93       	push	r17
    1490:	df 93       	push	r29
    1492:	cf 93       	push	r28
    1494:	cd b7       	in	r28, 0x3d	; 61
    1496:	de b7       	in	r29, 0x3e	; 62
    1498:	2a 97       	sbiw	r28, 0x0a	; 10
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	de bf       	out	0x3e, r29	; 62
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	cd bf       	out	0x3d, r28	; 61
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1994
    BaseType_t xReturn;

    /* Add the idle task at the lowest priority. */
    #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
        {
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
    14a4:	1b 82       	std	Y+3, r1	; 0x03
    14a6:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:1995
            StackType_t * pxIdleTaskStackBuffer = NULL;
    14a8:	1d 82       	std	Y+5, r1	; 0x05
    14aa:	1c 82       	std	Y+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2000
            uint32_t ulIdleTaskStackSize;

            /* The Idle task is created using user provided RAM - obtain the
             * address of the RAM then create the idle task. */
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
    14ac:	ce 01       	movw	r24, r28
    14ae:	02 96       	adiw	r24, 0x02	; 2
    14b0:	9e 01       	movw	r18, r28
    14b2:	2c 5f       	subi	r18, 0xFC	; 252
    14b4:	3f 4f       	sbci	r19, 0xFF	; 255
    14b6:	ae 01       	movw	r20, r28
    14b8:	4a 5f       	subi	r20, 0xFA	; 250
    14ba:	5f 4f       	sbci	r21, 0xFF	; 255
    14bc:	b9 01       	movw	r22, r18
    14be:	0e 94 92 00 	call	0x124	; 0x124 <vApplicationGetIdleTaskMemory>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2001
            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
    14c2:	ee 80       	ldd	r14, Y+6	; 0x06
    14c4:	ff 80       	ldd	r15, Y+7	; 0x07
    14c6:	08 85       	ldd	r16, Y+8	; 0x08
    14c8:	19 85       	ldd	r17, Y+9	; 0x09
    14ca:	ec 81       	ldd	r30, Y+4	; 0x04
    14cc:	fd 81       	ldd	r31, Y+5	; 0x05
    14ce:	aa 81       	ldd	r26, Y+2	; 0x02
    14d0:	bb 81       	ldd	r27, Y+3	; 0x03
    14d2:	82 e1       	ldi	r24, 0x12	; 18
    14d4:	9f e0       	ldi	r25, 0x0F	; 15
    14d6:	26 e6       	ldi	r18, 0x66	; 102
    14d8:	31 e0       	ldi	r19, 0x01	; 1
    14da:	b9 01       	movw	r22, r18
    14dc:	a8 01       	movw	r20, r16
    14de:	97 01       	movw	r18, r14
    14e0:	00 e0       	ldi	r16, 0x00	; 0
    14e2:	10 e0       	ldi	r17, 0x00	; 0
    14e4:	ee 24       	eor	r14, r14
    14e6:	6f 01       	movw	r12, r30
    14e8:	5d 01       	movw	r10, r26
    14ea:	0e 94 86 07 	call	0xf0c	; 0xf0c <xTaskCreateStatic>
    14ee:	90 93 b5 03 	sts	0x03B5, r25
    14f2:	80 93 b4 03 	sts	0x03B4, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2009
                                                 ( void * ) NULL,       /*lint !e961.  The cast is not redundant for all compilers. */
                                                 portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
                                                 pxIdleTaskStackBuffer,
                                                 pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

            if( xIdleTaskHandle != NULL )
    14f6:	80 91 b4 03 	lds	r24, 0x03B4
    14fa:	90 91 b5 03 	lds	r25, 0x03B5
    14fe:	00 97       	sbiw	r24, 0x00	; 0
    1500:	19 f0       	breq	.+6      	; 0x1508 <vTaskStartScheduler+0x88>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2011
            {
                xReturn = pdPASS;
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	89 83       	std	Y+1, r24	; 0x01
    1506:	01 c0       	rjmp	.+2      	; 0x150a <vTaskStartScheduler+0x8a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2015
            }
            else
            {
                xReturn = pdFAIL;
    1508:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2043
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    150a:	89 81       	ldd	r24, Y+1	; 0x01
    150c:	81 30       	cpi	r24, 0x01	; 1
    150e:	81 f4       	brne	.+32     	; 0x1530 <vTaskStartScheduler+0xb0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2059
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    1510:	f8 94       	cli
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2071
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    1512:	8f ef       	ldi	r24, 0xFF	; 255
    1514:	9f ef       	ldi	r25, 0xFF	; 255
    1516:	90 93 b3 03 	sts	0x03B3, r25
    151a:	80 93 b2 03 	sts	0x03B2, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2072
        xSchedulerRunning = pdTRUE;
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	80 93 ac 03 	sts	0x03AC, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2073
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1524:	10 92 aa 03 	sts	0x03AA, r1
    1528:	10 92 a9 03 	sts	0x03A9, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2087

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    152c:	0e 94 a6 21 	call	0x434c	; 0x434c <xPortStartScheduler>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2111
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    1530:	80 91 65 01 	lds	r24, 0x0165
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2112
}
    1534:	2a 96       	adiw	r28, 0x0a	; 10
    1536:	0f b6       	in	r0, 0x3f	; 63
    1538:	f8 94       	cli
    153a:	de bf       	out	0x3e, r29	; 62
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	cd bf       	out	0x3d, r28	; 61
    1540:	cf 91       	pop	r28
    1542:	df 91       	pop	r29
    1544:	1f 91       	pop	r17
    1546:	0f 91       	pop	r16
    1548:	ff 90       	pop	r15
    154a:	ef 90       	pop	r14
    154c:	df 90       	pop	r13
    154e:	cf 90       	pop	r12
    1550:	bf 90       	pop	r11
    1552:	af 90       	pop	r10
    1554:	08 95       	ret

00001556 <vTaskEndScheduler>:
vTaskEndScheduler():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2116
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1556:	df 93       	push	r29
    1558:	cf 93       	push	r28
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2120
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    155e:	f8 94       	cli
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2121
    xSchedulerRunning = pdFALSE;
    1560:	10 92 ac 03 	sts	0x03AC, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2122
    vPortEndScheduler();
    1564:	0e 94 db 21 	call	0x43b6	; 0x43b6 <vPortEndScheduler>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2123
}
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	08 95       	ret

0000156e <vTaskSuspendAll>:
vTaskSuspendAll():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2127
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    156e:	df 93       	push	r29
    1570:	cf 93       	push	r28
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2139
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    1576:	80 91 b6 03 	lds	r24, 0x03B6
    157a:	8f 5f       	subi	r24, 0xFF	; 255
    157c:	80 93 b6 03 	sts	0x03B6, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2144

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    1580:	cf 91       	pop	r28
    1582:	df 91       	pop	r29
    1584:	08 95       	ret

00001586 <xTaskResumeAll>:
xTaskResumeAll():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2211

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1586:	df 93       	push	r29
    1588:	cf 93       	push	r28
    158a:	00 d0       	rcall	.+0      	; 0x158c <xTaskResumeAll+0x6>
    158c:	00 d0       	rcall	.+0      	; 0x158e <xTaskResumeAll+0x8>
    158e:	0f 92       	push	r0
    1590:	cd b7       	in	r28, 0x3d	; 61
    1592:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2212
    TCB_t * pxTCB = NULL;
    1594:	1d 82       	std	Y+5, r1	; 0x05
    1596:	1c 82       	std	Y+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2213
    BaseType_t xAlreadyYielded = pdFALSE;
    1598:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2224
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2226
    {
        --uxSchedulerSuspended;
    15a0:	80 91 b6 03 	lds	r24, 0x03B6
    15a4:	81 50       	subi	r24, 0x01	; 1
    15a6:	80 93 b6 03 	sts	0x03B6, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2228

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    15aa:	80 91 b6 03 	lds	r24, 0x03B6
    15ae:	88 23       	and	r24, r24
    15b0:	09 f0       	breq	.+2      	; 0x15b4 <xTaskResumeAll+0x2e>
    15b2:	7c c0       	rjmp	.+248    	; 0x16ac <xTaskResumeAll+0x126>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2230
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    15b4:	80 91 a8 03 	lds	r24, 0x03A8
    15b8:	88 23       	and	r24, r24
    15ba:	09 f4       	brne	.+2      	; 0x15be <xTaskResumeAll+0x38>
    15bc:	77 c0       	rjmp	.+238    	; 0x16ac <xTaskResumeAll+0x126>
    15be:	45 c0       	rjmp	.+138    	; 0x164a <xTaskResumeAll+0xc4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2236
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    15c0:	e0 91 f6 03 	lds	r30, 0x03F6
    15c4:	f0 91 f7 03 	lds	r31, 0x03F7
    15c8:	86 81       	ldd	r24, Z+6	; 0x06
    15ca:	97 81       	ldd	r25, Z+7	; 0x07
    15cc:	9d 83       	std	Y+5, r25	; 0x05
    15ce:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2237
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    15d0:	8c 81       	ldd	r24, Y+4	; 0x04
    15d2:	9d 81       	ldd	r25, Y+5	; 0x05
    15d4:	0c 96       	adiw	r24, 0x0c	; 12
    15d6:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2238
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    15da:	8c 81       	ldd	r24, Y+4	; 0x04
    15dc:	9d 81       	ldd	r25, Y+5	; 0x05
    15de:	02 96       	adiw	r24, 0x02	; 2
    15e0:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2239
                    prvAddTaskToReadyList( pxTCB );
    15e4:	ec 81       	ldd	r30, Y+4	; 0x04
    15e6:	fd 81       	ldd	r31, Y+5	; 0x05
    15e8:	96 89       	ldd	r25, Z+22	; 0x16
    15ea:	80 91 ab 03 	lds	r24, 0x03AB
    15ee:	89 17       	cp	r24, r25
    15f0:	28 f4       	brcc	.+10     	; 0x15fc <xTaskResumeAll+0x76>
    15f2:	ec 81       	ldd	r30, Y+4	; 0x04
    15f4:	fd 81       	ldd	r31, Y+5	; 0x05
    15f6:	86 89       	ldd	r24, Z+22	; 0x16
    15f8:	80 93 ab 03 	sts	0x03AB, r24
    15fc:	ec 81       	ldd	r30, Y+4	; 0x04
    15fe:	fd 81       	ldd	r31, Y+5	; 0x05
    1600:	86 89       	ldd	r24, Z+22	; 0x16
    1602:	28 2f       	mov	r18, r24
    1604:	30 e0       	ldi	r19, 0x00	; 0
    1606:	c9 01       	movw	r24, r18
    1608:	88 0f       	add	r24, r24
    160a:	99 1f       	adc	r25, r25
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	88 0f       	add	r24, r24
    1612:	99 1f       	adc	r25, r25
    1614:	82 0f       	add	r24, r18
    1616:	93 1f       	adc	r25, r19
    1618:	ac 01       	movw	r20, r24
    161a:	49 54       	subi	r20, 0x49	; 73
    161c:	5c 4f       	sbci	r21, 0xFC	; 252
    161e:	8c 81       	ldd	r24, Y+4	; 0x04
    1620:	9d 81       	ldd	r25, Y+5	; 0x05
    1622:	9c 01       	movw	r18, r24
    1624:	2e 5f       	subi	r18, 0xFE	; 254
    1626:	3f 4f       	sbci	r19, 0xFF	; 255
    1628:	ca 01       	movw	r24, r20
    162a:	b9 01       	movw	r22, r18
    162c:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2243

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1630:	ec 81       	ldd	r30, Y+4	; 0x04
    1632:	fd 81       	ldd	r31, Y+5	; 0x05
    1634:	96 89       	ldd	r25, Z+22	; 0x16
    1636:	e0 91 a5 03 	lds	r30, 0x03A5
    163a:	f0 91 a6 03 	lds	r31, 0x03A6
    163e:	86 89       	ldd	r24, Z+22	; 0x16
    1640:	98 17       	cp	r25, r24
    1642:	18 f0       	brcs	.+6      	; 0x164a <xTaskResumeAll+0xc4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2245
                    {
                        xYieldPending = pdTRUE;
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2234
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    164a:	80 91 f1 03 	lds	r24, 0x03F1
    164e:	88 23       	and	r24, r24
    1650:	09 f0       	breq	.+2      	; 0x1654 <xTaskResumeAll+0xce>
    1652:	b6 cf       	rjmp	.-148    	; 0x15c0 <xTaskResumeAll+0x3a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2253
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    1654:	8c 81       	ldd	r24, Y+4	; 0x04
    1656:	9d 81       	ldd	r25, Y+5	; 0x05
    1658:	00 97       	sbiw	r24, 0x00	; 0
    165a:	11 f0       	breq	.+4      	; 0x1660 <xTaskResumeAll+0xda>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2261
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    165c:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <prvResetNextTaskUnblockTime>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2269
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    1660:	80 91 ad 03 	lds	r24, 0x03AD
    1664:	90 91 ae 03 	lds	r25, 0x03AE
    1668:	9a 83       	std	Y+2, r25	; 0x02
    166a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2271

                    if( xPendedCounts > ( TickType_t ) 0U )
    166c:	89 81       	ldd	r24, Y+1	; 0x01
    166e:	9a 81       	ldd	r25, Y+2	; 0x02
    1670:	00 97       	sbiw	r24, 0x00	; 0
    1672:	a1 f0       	breq	.+40     	; 0x169c <xTaskResumeAll+0x116>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2275
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    1674:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xTaskIncrementTick>
    1678:	88 23       	and	r24, r24
    167a:	19 f0       	breq	.+6      	; 0x1682 <xTaskResumeAll+0xfc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2277
                            {
                                xYieldPending = pdTRUE;
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2284
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	9a 81       	ldd	r25, Y+2	; 0x02
    1686:	01 97       	sbiw	r24, 0x01	; 1
    1688:	9a 83       	std	Y+2, r25	; 0x02
    168a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2285
                        } while( xPendedCounts > ( TickType_t ) 0U );
    168c:	89 81       	ldd	r24, Y+1	; 0x01
    168e:	9a 81       	ldd	r25, Y+2	; 0x02
    1690:	00 97       	sbiw	r24, 0x00	; 0
    1692:	81 f7       	brne	.-32     	; 0x1674 <xTaskResumeAll+0xee>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2287

                        xPendedTicks = 0;
    1694:	10 92 ae 03 	sts	0x03AE, r1
    1698:	10 92 ad 03 	sts	0x03AD, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2295
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    169c:	80 91 af 03 	lds	r24, 0x03AF
    16a0:	88 23       	and	r24, r24
    16a2:	21 f0       	breq	.+8      	; 0x16ac <xTaskResumeAll+0x126>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2299
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2302
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    16a8:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2315
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2317

    return xAlreadyYielded;
    16b0:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2318
}
    16b2:	0f 90       	pop	r0
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
    16b8:	0f 90       	pop	r0
    16ba:	0f 90       	pop	r0
    16bc:	cf 91       	pop	r28
    16be:	df 91       	pop	r29
    16c0:	08 95       	ret

000016c2 <xTaskGetTickCount>:
xTaskGetTickCount():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2322
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    16c2:	df 93       	push	r29
    16c4:	cf 93       	push	r28
    16c6:	00 d0       	rcall	.+0      	; 0x16c8 <xTaskGetTickCount+0x6>
    16c8:	cd b7       	in	r28, 0x3d	; 61
    16ca:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2326
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2328
    {
        xTicks = xTickCount;
    16d2:	80 91 a9 03 	lds	r24, 0x03A9
    16d6:	90 91 aa 03 	lds	r25, 0x03AA
    16da:	9a 83       	std	Y+2, r25	; 0x02
    16dc:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2330
    }
    portTICK_TYPE_EXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2332

    return xTicks;
    16e2:	89 81       	ldd	r24, Y+1	; 0x01
    16e4:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2333
}
    16e6:	0f 90       	pop	r0
    16e8:	0f 90       	pop	r0
    16ea:	cf 91       	pop	r28
    16ec:	df 91       	pop	r29
    16ee:	08 95       	ret

000016f0 <xTaskGetTickCountFromISR>:
xTaskGetTickCountFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2337
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    16f0:	df 93       	push	r29
    16f2:	cf 93       	push	r28
    16f4:	00 d0       	rcall	.+0      	; 0x16f6 <xTaskGetTickCountFromISR+0x6>
    16f6:	0f 92       	push	r0
    16f8:	cd b7       	in	r28, 0x3d	; 61
    16fa:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2357
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    16fc:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2359
    {
        xReturn = xTickCount;
    16fe:	80 91 a9 03 	lds	r24, 0x03A9
    1702:	90 91 aa 03 	lds	r25, 0x03AA
    1706:	9b 83       	std	Y+3, r25	; 0x03
    1708:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2363
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    170a:	8a 81       	ldd	r24, Y+2	; 0x02
    170c:	9b 81       	ldd	r25, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2364
}
    170e:	0f 90       	pop	r0
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	cf 91       	pop	r28
    1716:	df 91       	pop	r29
    1718:	08 95       	ret

0000171a <uxTaskGetNumberOfTasks>:
uxTaskGetNumberOfTasks():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2368
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    171a:	df 93       	push	r29
    171c:	cf 93       	push	r28
    171e:	cd b7       	in	r28, 0x3d	; 61
    1720:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2371
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    1722:	80 91 a8 03 	lds	r24, 0x03A8
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2372
}
    1726:	cf 91       	pop	r28
    1728:	df 91       	pop	r29
    172a:	08 95       	ret

0000172c <pcTaskGetName>:
pcTaskGetName():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2376
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    172c:	df 93       	push	r29
    172e:	cf 93       	push	r28
    1730:	00 d0       	rcall	.+0      	; 0x1732 <pcTaskGetName+0x6>
    1732:	00 d0       	rcall	.+0      	; 0x1734 <pcTaskGetName+0x8>
    1734:	00 d0       	rcall	.+0      	; 0x1736 <pcTaskGetName+0xa>
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
    173a:	9c 83       	std	Y+4, r25	; 0x04
    173c:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2381
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    173e:	8b 81       	ldd	r24, Y+3	; 0x03
    1740:	9c 81       	ldd	r25, Y+4	; 0x04
    1742:	00 97       	sbiw	r24, 0x00	; 0
    1744:	39 f4       	brne	.+14     	; 0x1754 <pcTaskGetName+0x28>
    1746:	80 91 a5 03 	lds	r24, 0x03A5
    174a:	90 91 a6 03 	lds	r25, 0x03A6
    174e:	9e 83       	std	Y+6, r25	; 0x06
    1750:	8d 83       	std	Y+5, r24	; 0x05
    1752:	04 c0       	rjmp	.+8      	; 0x175c <pcTaskGetName+0x30>
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	9e 83       	std	Y+6, r25	; 0x06
    175a:	8d 83       	std	Y+5, r24	; 0x05
    175c:	8d 81       	ldd	r24, Y+5	; 0x05
    175e:	9e 81       	ldd	r25, Y+6	; 0x06
    1760:	9a 83       	std	Y+2, r25	; 0x02
    1762:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2383
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    1764:	89 81       	ldd	r24, Y+1	; 0x01
    1766:	9a 81       	ldd	r25, Y+2	; 0x02
    1768:	49 96       	adiw	r24, 0x19	; 25
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2384
}
    176a:	26 96       	adiw	r28, 0x06	; 6
    176c:	0f b6       	in	r0, 0x3f	; 63
    176e:	f8 94       	cli
    1770:	de bf       	out	0x3e, r29	; 62
    1772:	0f be       	out	0x3f, r0	; 63
    1774:	cd bf       	out	0x3d, r28	; 61
    1776:	cf 91       	pop	r28
    1778:	df 91       	pop	r29
    177a:	08 95       	ret

0000177c <xTaskCatchUpTicks>:
xTaskCatchUpTicks():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2628

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    177c:	df 93       	push	r29
    177e:	cf 93       	push	r28
    1780:	00 d0       	rcall	.+0      	; 0x1782 <xTaskCatchUpTicks+0x6>
    1782:	0f 92       	push	r0
    1784:	cd b7       	in	r28, 0x3d	; 61
    1786:	de b7       	in	r29, 0x3e	; 62
    1788:	9b 83       	std	Y+3, r25	; 0x03
    178a:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2637
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    178c:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2638
    xPendedTicks += xTicksToCatchUp;
    1790:	20 91 ad 03 	lds	r18, 0x03AD
    1794:	30 91 ae 03 	lds	r19, 0x03AE
    1798:	8a 81       	ldd	r24, Y+2	; 0x02
    179a:	9b 81       	ldd	r25, Y+3	; 0x03
    179c:	82 0f       	add	r24, r18
    179e:	93 1f       	adc	r25, r19
    17a0:	90 93 ae 03 	sts	0x03AE, r25
    17a4:	80 93 ad 03 	sts	0x03AD, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2639
    xYieldOccurred = xTaskResumeAll();
    17a8:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    17ac:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2641

    return xYieldOccurred;
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2642
}
    17b0:	0f 90       	pop	r0
    17b2:	0f 90       	pop	r0
    17b4:	0f 90       	pop	r0
    17b6:	cf 91       	pop	r28
    17b8:	df 91       	pop	r29
    17ba:	08 95       	ret

000017bc <xTaskIncrementTick>:
xTaskIncrementTick():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2726

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    17bc:	df 93       	push	r29
    17be:	cf 93       	push	r28
    17c0:	cd b7       	in	r28, 0x3d	; 61
    17c2:	de b7       	in	r29, 0x3e	; 62
    17c4:	29 97       	sbiw	r28, 0x09	; 9
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	f8 94       	cli
    17ca:	de bf       	out	0x3e, r29	; 62
    17cc:	0f be       	out	0x3f, r0	; 63
    17ce:	cd bf       	out	0x3d, r28	; 61
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2729
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    17d0:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2736
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    17d2:	80 91 b6 03 	lds	r24, 0x03B6
    17d6:	88 23       	and	r24, r24
    17d8:	09 f0       	breq	.+2      	; 0x17dc <xTaskIncrementTick+0x20>
    17da:	c6 c0       	rjmp	.+396    	; 0x1968 <xTaskIncrementTick+0x1ac>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2740
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    17dc:	80 91 a9 03 	lds	r24, 0x03A9
    17e0:	90 91 aa 03 	lds	r25, 0x03AA
    17e4:	01 96       	adiw	r24, 0x01	; 1
    17e6:	9c 83       	std	Y+4, r25	; 0x04
    17e8:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2744

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	90 93 aa 03 	sts	0x03AA, r25
    17f2:	80 93 a9 03 	sts	0x03A9, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2746

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    17f6:	8b 81       	ldd	r24, Y+3	; 0x03
    17f8:	9c 81       	ldd	r25, Y+4	; 0x04
    17fa:	00 97       	sbiw	r24, 0x00	; 0
    17fc:	d9 f4       	brne	.+54     	; 0x1834 <xTaskIncrementTick+0x78>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2748
        {
            taskSWITCH_DELAYED_LISTS();
    17fe:	80 91 ed 03 	lds	r24, 0x03ED
    1802:	90 91 ee 03 	lds	r25, 0x03EE
    1806:	9a 83       	std	Y+2, r25	; 0x02
    1808:	89 83       	std	Y+1, r24	; 0x01
    180a:	80 91 ef 03 	lds	r24, 0x03EF
    180e:	90 91 f0 03 	lds	r25, 0x03F0
    1812:	90 93 ee 03 	sts	0x03EE, r25
    1816:	80 93 ed 03 	sts	0x03ED, r24
    181a:	89 81       	ldd	r24, Y+1	; 0x01
    181c:	9a 81       	ldd	r25, Y+2	; 0x02
    181e:	90 93 f0 03 	sts	0x03F0, r25
    1822:	80 93 ef 03 	sts	0x03EF, r24
    1826:	80 91 b0 03 	lds	r24, 0x03B0
    182a:	8f 5f       	subi	r24, 0xFF	; 255
    182c:	80 93 b0 03 	sts	0x03B0, r24
    1830:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <prvResetNextTaskUnblockTime>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2759

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1834:	20 91 b2 03 	lds	r18, 0x03B2
    1838:	30 91 b3 03 	lds	r19, 0x03B3
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	82 17       	cp	r24, r18
    1842:	93 07       	cpc	r25, r19
    1844:	08 f4       	brcc	.+2      	; 0x1848 <xTaskIncrementTick+0x8c>
    1846:	71 c0       	rjmp	.+226    	; 0x192a <xTaskIncrementTick+0x16e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2763
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1848:	e0 91 ed 03 	lds	r30, 0x03ED
    184c:	f0 91 ee 03 	lds	r31, 0x03EE
    1850:	80 81       	ld	r24, Z
    1852:	88 23       	and	r24, r24
    1854:	39 f4       	brne	.+14     	; 0x1864 <xTaskIncrementTick+0xa8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2770
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1856:	8f ef       	ldi	r24, 0xFF	; 255
    1858:	9f ef       	ldi	r25, 0xFF	; 255
    185a:	90 93 b3 03 	sts	0x03B3, r25
    185e:	80 93 b2 03 	sts	0x03B2, r24
    1862:	63 c0       	rjmp	.+198    	; 0x192a <xTaskIncrementTick+0x16e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2779
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1864:	e0 91 ed 03 	lds	r30, 0x03ED
    1868:	f0 91 ee 03 	lds	r31, 0x03EE
    186c:	05 80       	ldd	r0, Z+5	; 0x05
    186e:	f6 81       	ldd	r31, Z+6	; 0x06
    1870:	e0 2d       	mov	r30, r0
    1872:	86 81       	ldd	r24, Z+6	; 0x06
    1874:	97 81       	ldd	r25, Z+7	; 0x07
    1876:	99 87       	std	Y+9, r25	; 0x09
    1878:	88 87       	std	Y+8, r24	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2780
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    187a:	e8 85       	ldd	r30, Y+8	; 0x08
    187c:	f9 85       	ldd	r31, Y+9	; 0x09
    187e:	82 81       	ldd	r24, Z+2	; 0x02
    1880:	93 81       	ldd	r25, Z+3	; 0x03
    1882:	9f 83       	std	Y+7, r25	; 0x07
    1884:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2782

                    if( xConstTickCount < xItemValue )
    1886:	2b 81       	ldd	r18, Y+3	; 0x03
    1888:	3c 81       	ldd	r19, Y+4	; 0x04
    188a:	8e 81       	ldd	r24, Y+6	; 0x06
    188c:	9f 81       	ldd	r25, Y+7	; 0x07
    188e:	28 17       	cp	r18, r24
    1890:	39 07       	cpc	r19, r25
    1892:	38 f4       	brcc	.+14     	; 0x18a2 <xTaskIncrementTick+0xe6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2789
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    1894:	8e 81       	ldd	r24, Y+6	; 0x06
    1896:	9f 81       	ldd	r25, Y+7	; 0x07
    1898:	90 93 b3 03 	sts	0x03B3, r25
    189c:	80 93 b2 03 	sts	0x03B2, r24
    18a0:	44 c0       	rjmp	.+136    	; 0x192a <xTaskIncrementTick+0x16e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2798
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    18a2:	88 85       	ldd	r24, Y+8	; 0x08
    18a4:	99 85       	ldd	r25, Y+9	; 0x09
    18a6:	02 96       	adiw	r24, 0x02	; 2
    18a8:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2802

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    18ac:	e8 85       	ldd	r30, Y+8	; 0x08
    18ae:	f9 85       	ldd	r31, Y+9	; 0x09
    18b0:	84 89       	ldd	r24, Z+20	; 0x14
    18b2:	95 89       	ldd	r25, Z+21	; 0x15
    18b4:	00 97       	sbiw	r24, 0x00	; 0
    18b6:	29 f0       	breq	.+10     	; 0x18c2 <xTaskIncrementTick+0x106>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2804
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    18b8:	88 85       	ldd	r24, Y+8	; 0x08
    18ba:	99 85       	ldd	r25, Y+9	; 0x09
    18bc:	0c 96       	adiw	r24, 0x0c	; 12
    18be:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2813
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    18c2:	e8 85       	ldd	r30, Y+8	; 0x08
    18c4:	f9 85       	ldd	r31, Y+9	; 0x09
    18c6:	96 89       	ldd	r25, Z+22	; 0x16
    18c8:	80 91 ab 03 	lds	r24, 0x03AB
    18cc:	89 17       	cp	r24, r25
    18ce:	28 f4       	brcc	.+10     	; 0x18da <xTaskIncrementTick+0x11e>
    18d0:	e8 85       	ldd	r30, Y+8	; 0x08
    18d2:	f9 85       	ldd	r31, Y+9	; 0x09
    18d4:	86 89       	ldd	r24, Z+22	; 0x16
    18d6:	80 93 ab 03 	sts	0x03AB, r24
    18da:	e8 85       	ldd	r30, Y+8	; 0x08
    18dc:	f9 85       	ldd	r31, Y+9	; 0x09
    18de:	86 89       	ldd	r24, Z+22	; 0x16
    18e0:	28 2f       	mov	r18, r24
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	c9 01       	movw	r24, r18
    18e6:	88 0f       	add	r24, r24
    18e8:	99 1f       	adc	r25, r25
    18ea:	88 0f       	add	r24, r24
    18ec:	99 1f       	adc	r25, r25
    18ee:	88 0f       	add	r24, r24
    18f0:	99 1f       	adc	r25, r25
    18f2:	82 0f       	add	r24, r18
    18f4:	93 1f       	adc	r25, r19
    18f6:	ac 01       	movw	r20, r24
    18f8:	49 54       	subi	r20, 0x49	; 73
    18fa:	5c 4f       	sbci	r21, 0xFC	; 252
    18fc:	88 85       	ldd	r24, Y+8	; 0x08
    18fe:	99 85       	ldd	r25, Y+9	; 0x09
    1900:	9c 01       	movw	r18, r24
    1902:	2e 5f       	subi	r18, 0xFE	; 254
    1904:	3f 4f       	sbci	r19, 0xFF	; 255
    1906:	ca 01       	movw	r24, r20
    1908:	b9 01       	movw	r22, r18
    190a:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2823
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    190e:	e8 85       	ldd	r30, Y+8	; 0x08
    1910:	f9 85       	ldd	r31, Y+9	; 0x09
    1912:	96 89       	ldd	r25, Z+22	; 0x16
    1914:	e0 91 a5 03 	lds	r30, 0x03A5
    1918:	f0 91 a6 03 	lds	r31, 0x03A6
    191c:	86 89       	ldd	r24, Z+22	; 0x16
    191e:	98 17       	cp	r25, r24
    1920:	08 f4       	brcc	.+2      	; 0x1924 <xTaskIncrementTick+0x168>
    1922:	92 cf       	rjmp	.-220    	; 0x1848 <xTaskIncrementTick+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2825
                            {
                                xSwitchRequired = pdTRUE;
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	8d 83       	std	Y+5, r24	; 0x05
    1928:	8f cf       	rjmp	.-226    	; 0x1848 <xTaskIncrementTick+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2842
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    192a:	e0 91 a5 03 	lds	r30, 0x03A5
    192e:	f0 91 a6 03 	lds	r31, 0x03A6
    1932:	86 89       	ldd	r24, Z+22	; 0x16
    1934:	28 2f       	mov	r18, r24
    1936:	30 e0       	ldi	r19, 0x00	; 0
    1938:	c9 01       	movw	r24, r18
    193a:	88 0f       	add	r24, r24
    193c:	99 1f       	adc	r25, r25
    193e:	88 0f       	add	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	88 0f       	add	r24, r24
    1944:	99 1f       	adc	r25, r25
    1946:	82 0f       	add	r24, r18
    1948:	93 1f       	adc	r25, r19
    194a:	fc 01       	movw	r30, r24
    194c:	e9 54       	subi	r30, 0x49	; 73
    194e:	fc 4f       	sbci	r31, 0xFC	; 252
    1950:	80 81       	ld	r24, Z
    1952:	82 30       	cpi	r24, 0x02	; 2
    1954:	10 f0       	brcs	.+4      	; 0x195a <xTaskIncrementTick+0x19e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2844
                {
                    xSwitchRequired = pdTRUE;
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2870
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    195a:	80 91 af 03 	lds	r24, 0x03AF
    195e:	88 23       	and	r24, r24
    1960:	61 f0       	breq	.+24     	; 0x197a <xTaskIncrementTick+0x1be>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2872
                {
                    xSwitchRequired = pdTRUE;
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	8d 83       	std	Y+5, r24	; 0x05
    1966:	09 c0       	rjmp	.+18     	; 0x197a <xTaskIncrementTick+0x1be>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2883
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    1968:	80 91 ad 03 	lds	r24, 0x03AD
    196c:	90 91 ae 03 	lds	r25, 0x03AE
    1970:	01 96       	adiw	r24, 0x01	; 1
    1972:	90 93 ae 03 	sts	0x03AE, r25
    1976:	80 93 ad 03 	sts	0x03AD, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2894
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    197a:	8d 81       	ldd	r24, Y+5	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:2895
}
    197c:	29 96       	adiw	r28, 0x09	; 9
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	f8 94       	cli
    1982:	de bf       	out	0x3e, r29	; 62
    1984:	0f be       	out	0x3f, r0	; 63
    1986:	cd bf       	out	0x3d, r28	; 61
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	08 95       	ret

0000198e <vTaskSwitchContext>:
vTaskSwitchContext():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3011

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    198e:	df 93       	push	r29
    1990:	cf 93       	push	r28
    1992:	00 d0       	rcall	.+0      	; 0x1994 <vTaskSwitchContext+0x6>
    1994:	0f 92       	push	r0
    1996:	cd b7       	in	r28, 0x3d	; 61
    1998:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3012
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    199a:	80 91 b6 03 	lds	r24, 0x03B6
    199e:	88 23       	and	r24, r24
    19a0:	21 f0       	breq	.+8      	; 0x19aa <vTaskSwitchContext+0x1c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3016
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    19a2:	81 e0       	ldi	r24, 0x01	; 1
    19a4:	80 93 af 03 	sts	0x03AF, r24
    19a8:	75 c0       	rjmp	.+234    	; 0x1a94 <vTaskSwitchContext+0x106>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3020
    }
    else
    {
        xYieldPending = pdFALSE;
    19aa:	10 92 af 03 	sts	0x03AF, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3052
                ulTaskSwitchedInTime = ulTotalRunTime;
            }
        #endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();
    19ae:	e0 91 a5 03 	lds	r30, 0x03A5
    19b2:	f0 91 a6 03 	lds	r31, 0x03A6
    19b6:	20 81       	ld	r18, Z
    19b8:	31 81       	ldd	r19, Z+1	; 0x01
    19ba:	e0 91 a5 03 	lds	r30, 0x03A5
    19be:	f0 91 a6 03 	lds	r31, 0x03A6
    19c2:	87 89       	ldd	r24, Z+23	; 0x17
    19c4:	90 8d       	ldd	r25, Z+24	; 0x18
    19c6:	82 17       	cp	r24, r18
    19c8:	93 07       	cpc	r25, r19
    19ca:	68 f0       	brcs	.+26     	; 0x19e6 <vTaskSwitchContext+0x58>
    19cc:	80 91 a5 03 	lds	r24, 0x03A5
    19d0:	90 91 a6 03 	lds	r25, 0x03A6
    19d4:	20 91 a5 03 	lds	r18, 0x03A5
    19d8:	30 91 a6 03 	lds	r19, 0x03A6
    19dc:	27 5e       	subi	r18, 0xE7	; 231
    19de:	3f 4f       	sbci	r19, 0xFF	; 255
    19e0:	b9 01       	movw	r22, r18
    19e2:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <vApplicationStackOverflowHook>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3063
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    19e6:	80 91 ab 03 	lds	r24, 0x03AB
    19ea:	8b 83       	std	Y+3, r24	; 0x03
    19ec:	03 c0       	rjmp	.+6      	; 0x19f4 <vTaskSwitchContext+0x66>
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	8b 83       	std	Y+3, r24	; 0x03
    19f4:	8b 81       	ldd	r24, Y+3	; 0x03
    19f6:	28 2f       	mov	r18, r24
    19f8:	30 e0       	ldi	r19, 0x00	; 0
    19fa:	c9 01       	movw	r24, r18
    19fc:	88 0f       	add	r24, r24
    19fe:	99 1f       	adc	r25, r25
    1a00:	88 0f       	add	r24, r24
    1a02:	99 1f       	adc	r25, r25
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	82 0f       	add	r24, r18
    1a0a:	93 1f       	adc	r25, r19
    1a0c:	fc 01       	movw	r30, r24
    1a0e:	e9 54       	subi	r30, 0x49	; 73
    1a10:	fc 4f       	sbci	r31, 0xFC	; 252
    1a12:	80 81       	ld	r24, Z
    1a14:	88 23       	and	r24, r24
    1a16:	59 f3       	breq	.-42     	; 0x19ee <vTaskSwitchContext+0x60>
    1a18:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1a:	28 2f       	mov	r18, r24
    1a1c:	30 e0       	ldi	r19, 0x00	; 0
    1a1e:	c9 01       	movw	r24, r18
    1a20:	88 0f       	add	r24, r24
    1a22:	99 1f       	adc	r25, r25
    1a24:	88 0f       	add	r24, r24
    1a26:	99 1f       	adc	r25, r25
    1a28:	88 0f       	add	r24, r24
    1a2a:	99 1f       	adc	r25, r25
    1a2c:	82 0f       	add	r24, r18
    1a2e:	93 1f       	adc	r25, r19
    1a30:	89 54       	subi	r24, 0x49	; 73
    1a32:	9c 4f       	sbci	r25, 0xFC	; 252
    1a34:	9a 83       	std	Y+2, r25	; 0x02
    1a36:	89 83       	std	Y+1, r24	; 0x01
    1a38:	e9 81       	ldd	r30, Y+1	; 0x01
    1a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a3c:	01 80       	ldd	r0, Z+1	; 0x01
    1a3e:	f2 81       	ldd	r31, Z+2	; 0x02
    1a40:	e0 2d       	mov	r30, r0
    1a42:	82 81       	ldd	r24, Z+2	; 0x02
    1a44:	93 81       	ldd	r25, Z+3	; 0x03
    1a46:	e9 81       	ldd	r30, Y+1	; 0x01
    1a48:	fa 81       	ldd	r31, Y+2	; 0x02
    1a4a:	92 83       	std	Z+2, r25	; 0x02
    1a4c:	81 83       	std	Z+1, r24	; 0x01
    1a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a50:	fa 81       	ldd	r31, Y+2	; 0x02
    1a52:	21 81       	ldd	r18, Z+1	; 0x01
    1a54:	32 81       	ldd	r19, Z+2	; 0x02
    1a56:	89 81       	ldd	r24, Y+1	; 0x01
    1a58:	9a 81       	ldd	r25, Y+2	; 0x02
    1a5a:	03 96       	adiw	r24, 0x03	; 3
    1a5c:	28 17       	cp	r18, r24
    1a5e:	39 07       	cpc	r19, r25
    1a60:	59 f4       	brne	.+22     	; 0x1a78 <vTaskSwitchContext+0xea>
    1a62:	e9 81       	ldd	r30, Y+1	; 0x01
    1a64:	fa 81       	ldd	r31, Y+2	; 0x02
    1a66:	01 80       	ldd	r0, Z+1	; 0x01
    1a68:	f2 81       	ldd	r31, Z+2	; 0x02
    1a6a:	e0 2d       	mov	r30, r0
    1a6c:	82 81       	ldd	r24, Z+2	; 0x02
    1a6e:	93 81       	ldd	r25, Z+3	; 0x03
    1a70:	e9 81       	ldd	r30, Y+1	; 0x01
    1a72:	fa 81       	ldd	r31, Y+2	; 0x02
    1a74:	92 83       	std	Z+2, r25	; 0x02
    1a76:	81 83       	std	Z+1, r24	; 0x01
    1a78:	e9 81       	ldd	r30, Y+1	; 0x01
    1a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7c:	01 80       	ldd	r0, Z+1	; 0x01
    1a7e:	f2 81       	ldd	r31, Z+2	; 0x02
    1a80:	e0 2d       	mov	r30, r0
    1a82:	86 81       	ldd	r24, Z+6	; 0x06
    1a84:	97 81       	ldd	r25, Z+7	; 0x07
    1a86:	90 93 a6 03 	sts	0x03A6, r25
    1a8a:	80 93 a5 03 	sts	0x03A5, r24
    1a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a90:	80 93 ab 03 	sts	0x03AB, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3083
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    1a94:	0f 90       	pop	r0
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	cf 91       	pop	r28
    1a9c:	df 91       	pop	r29
    1a9e:	08 95       	ret

00001aa0 <vTaskPlaceOnEventList>:
vTaskPlaceOnEventList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3088
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	00 d0       	rcall	.+0      	; 0x1aa6 <vTaskPlaceOnEventList+0x6>
    1aa6:	00 d0       	rcall	.+0      	; 0x1aa8 <vTaskPlaceOnEventList+0x8>
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	9a 83       	std	Y+2, r25	; 0x02
    1aae:	89 83       	std	Y+1, r24	; 0x01
    1ab0:	7c 83       	std	Y+4, r23	; 0x04
    1ab2:	6b 83       	std	Y+3, r22	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3098

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1ab4:	80 91 a5 03 	lds	r24, 0x03A5
    1ab8:	90 91 a6 03 	lds	r25, 0x03A6
    1abc:	9c 01       	movw	r18, r24
    1abe:	24 5f       	subi	r18, 0xF4	; 244
    1ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ac2:	89 81       	ldd	r24, Y+1	; 0x01
    1ac4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac6:	b9 01       	movw	r22, r18
    1ac8:	0e 94 82 20 	call	0x4104	; 0x4104 <vListInsert>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3100

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1acc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ace:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad0:	61 e0       	ldi	r22, 0x01	; 1
    1ad2:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3101
}
    1ad6:	0f 90       	pop	r0
    1ad8:	0f 90       	pop	r0
    1ada:	0f 90       	pop	r0
    1adc:	0f 90       	pop	r0
    1ade:	cf 91       	pop	r28
    1ae0:	df 91       	pop	r29
    1ae2:	08 95       	ret

00001ae4 <vTaskPlaceOnUnorderedEventList>:
vTaskPlaceOnUnorderedEventList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3107
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    1ae4:	df 93       	push	r29
    1ae6:	cf 93       	push	r28
    1ae8:	00 d0       	rcall	.+0      	; 0x1aea <vTaskPlaceOnUnorderedEventList+0x6>
    1aea:	00 d0       	rcall	.+0      	; 0x1aec <vTaskPlaceOnUnorderedEventList+0x8>
    1aec:	00 d0       	rcall	.+0      	; 0x1aee <vTaskPlaceOnUnorderedEventList+0xa>
    1aee:	cd b7       	in	r28, 0x3d	; 61
    1af0:	de b7       	in	r29, 0x3e	; 62
    1af2:	9a 83       	std	Y+2, r25	; 0x02
    1af4:	89 83       	std	Y+1, r24	; 0x01
    1af6:	7c 83       	std	Y+4, r23	; 0x04
    1af8:	6b 83       	std	Y+3, r22	; 0x03
    1afa:	5e 83       	std	Y+6, r21	; 0x06
    1afc:	4d 83       	std	Y+5, r20	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3117
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1afe:	e0 91 a5 03 	lds	r30, 0x03A5
    1b02:	f0 91 a6 03 	lds	r31, 0x03A6
    1b06:	8b 81       	ldd	r24, Y+3	; 0x03
    1b08:	9c 81       	ldd	r25, Y+4	; 0x04
    1b0a:	90 68       	ori	r25, 0x80	; 128
    1b0c:	95 87       	std	Z+13, r25	; 0x0d
    1b0e:	84 87       	std	Z+12, r24	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3124
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1b10:	80 91 a5 03 	lds	r24, 0x03A5
    1b14:	90 91 a6 03 	lds	r25, 0x03A6
    1b18:	9c 01       	movw	r18, r24
    1b1a:	24 5f       	subi	r18, 0xF4	; 244
    1b1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b1e:	89 81       	ldd	r24, Y+1	; 0x01
    1b20:	9a 81       	ldd	r25, Y+2	; 0x02
    1b22:	b9 01       	movw	r22, r18
    1b24:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3126

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1b28:	8d 81       	ldd	r24, Y+5	; 0x05
    1b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1b2c:	61 e0       	ldi	r22, 0x01	; 1
    1b2e:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3127
}
    1b32:	26 96       	adiw	r28, 0x06	; 6
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	de bf       	out	0x3e, r29	; 62
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	cd bf       	out	0x3d, r28	; 61
    1b3e:	cf 91       	pop	r28
    1b40:	df 91       	pop	r29
    1b42:	08 95       	ret

00001b44 <xTaskRemoveFromEventList>:
xTaskRemoveFromEventList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3166

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1b44:	df 93       	push	r29
    1b46:	cf 93       	push	r28
    1b48:	00 d0       	rcall	.+0      	; 0x1b4a <xTaskRemoveFromEventList+0x6>
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <xTaskRemoveFromEventList+0x8>
    1b4c:	0f 92       	push	r0
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62
    1b52:	9d 83       	std	Y+5, r25	; 0x05
    1b54:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3183
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1b56:	ec 81       	ldd	r30, Y+4	; 0x04
    1b58:	fd 81       	ldd	r31, Y+5	; 0x05
    1b5a:	05 80       	ldd	r0, Z+5	; 0x05
    1b5c:	f6 81       	ldd	r31, Z+6	; 0x06
    1b5e:	e0 2d       	mov	r30, r0
    1b60:	86 81       	ldd	r24, Z+6	; 0x06
    1b62:	97 81       	ldd	r25, Z+7	; 0x07
    1b64:	9b 83       	std	Y+3, r25	; 0x03
    1b66:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3185
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b68:	8a 81       	ldd	r24, Y+2	; 0x02
    1b6a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b6c:	0c 96       	adiw	r24, 0x0c	; 12
    1b6e:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3187

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b72:	80 91 b6 03 	lds	r24, 0x03B6
    1b76:	88 23       	and	r24, r24
    1b78:	61 f5       	brne	.+88     	; 0x1bd2 <xTaskRemoveFromEventList+0x8e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3189
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1b7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b7c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b7e:	02 96       	adiw	r24, 0x02	; 2
    1b80:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3190
        prvAddTaskToReadyList( pxUnblockedTCB );
    1b84:	ea 81       	ldd	r30, Y+2	; 0x02
    1b86:	fb 81       	ldd	r31, Y+3	; 0x03
    1b88:	96 89       	ldd	r25, Z+22	; 0x16
    1b8a:	80 91 ab 03 	lds	r24, 0x03AB
    1b8e:	89 17       	cp	r24, r25
    1b90:	28 f4       	brcc	.+10     	; 0x1b9c <xTaskRemoveFromEventList+0x58>
    1b92:	ea 81       	ldd	r30, Y+2	; 0x02
    1b94:	fb 81       	ldd	r31, Y+3	; 0x03
    1b96:	86 89       	ldd	r24, Z+22	; 0x16
    1b98:	80 93 ab 03 	sts	0x03AB, r24
    1b9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba0:	86 89       	ldd	r24, Z+22	; 0x16
    1ba2:	28 2f       	mov	r18, r24
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	c9 01       	movw	r24, r18
    1ba8:	88 0f       	add	r24, r24
    1baa:	99 1f       	adc	r25, r25
    1bac:	88 0f       	add	r24, r24
    1bae:	99 1f       	adc	r25, r25
    1bb0:	88 0f       	add	r24, r24
    1bb2:	99 1f       	adc	r25, r25
    1bb4:	82 0f       	add	r24, r18
    1bb6:	93 1f       	adc	r25, r19
    1bb8:	ac 01       	movw	r20, r24
    1bba:	49 54       	subi	r20, 0x49	; 73
    1bbc:	5c 4f       	sbci	r21, 0xFC	; 252
    1bbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1bc2:	9c 01       	movw	r18, r24
    1bc4:	2e 5f       	subi	r18, 0xFE	; 254
    1bc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc8:	ca 01       	movw	r24, r20
    1bca:	b9 01       	movw	r22, r18
    1bcc:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
    1bd0:	0a c0       	rjmp	.+20     	; 0x1be6 <xTaskRemoveFromEventList+0xa2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3210
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd4:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd6:	9c 01       	movw	r18, r24
    1bd8:	24 5f       	subi	r18, 0xF4	; 244
    1bda:	3f 4f       	sbci	r19, 0xFF	; 255
    1bdc:	81 ef       	ldi	r24, 0xF1	; 241
    1bde:	93 e0       	ldi	r25, 0x03	; 3
    1be0:	b9 01       	movw	r22, r18
    1be2:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3213
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1be6:	ea 81       	ldd	r30, Y+2	; 0x02
    1be8:	fb 81       	ldd	r31, Y+3	; 0x03
    1bea:	96 89       	ldd	r25, Z+22	; 0x16
    1bec:	e0 91 a5 03 	lds	r30, 0x03A5
    1bf0:	f0 91 a6 03 	lds	r31, 0x03A6
    1bf4:	86 89       	ldd	r24, Z+22	; 0x16
    1bf6:	89 17       	cp	r24, r25
    1bf8:	30 f4       	brcc	.+12     	; 0x1c06 <xTaskRemoveFromEventList+0xc2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3218
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
    1bfc:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3222

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	80 93 af 03 	sts	0x03AF, r24
    1c04:	01 c0       	rjmp	.+2      	; 0x1c08 <xTaskRemoveFromEventList+0xc4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3226
    }
    else
    {
        xReturn = pdFALSE;
    1c06:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3229
    }

    return xReturn;
    1c08:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3230
}
    1c0a:	0f 90       	pop	r0
    1c0c:	0f 90       	pop	r0
    1c0e:	0f 90       	pop	r0
    1c10:	0f 90       	pop	r0
    1c12:	0f 90       	pop	r0
    1c14:	cf 91       	pop	r28
    1c16:	df 91       	pop	r29
    1c18:	08 95       	ret

00001c1a <vTaskRemoveFromUnorderedEventList>:
vTaskRemoveFromUnorderedEventList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3235
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    1c1a:	df 93       	push	r29
    1c1c:	cf 93       	push	r28
    1c1e:	00 d0       	rcall	.+0      	; 0x1c20 <vTaskRemoveFromUnorderedEventList+0x6>
    1c20:	00 d0       	rcall	.+0      	; 0x1c22 <vTaskRemoveFromUnorderedEventList+0x8>
    1c22:	00 d0       	rcall	.+0      	; 0x1c24 <vTaskRemoveFromUnorderedEventList+0xa>
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    1c28:	9c 83       	std	Y+4, r25	; 0x04
    1c2a:	8b 83       	std	Y+3, r24	; 0x03
    1c2c:	7e 83       	std	Y+6, r23	; 0x06
    1c2e:	6d 83       	std	Y+5, r22	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3243
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1c30:	8d 81       	ldd	r24, Y+5	; 0x05
    1c32:	9e 81       	ldd	r25, Y+6	; 0x06
    1c34:	90 68       	ori	r25, 0x80	; 128
    1c36:	eb 81       	ldd	r30, Y+3	; 0x03
    1c38:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3a:	91 83       	std	Z+1, r25	; 0x01
    1c3c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3247

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1c3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c40:	fc 81       	ldd	r31, Y+4	; 0x04
    1c42:	86 81       	ldd	r24, Z+6	; 0x06
    1c44:	97 81       	ldd	r25, Z+7	; 0x07
    1c46:	9a 83       	std	Y+2, r25	; 0x02
    1c48:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3249
    configASSERT( pxUnblockedTCB );
    ( void ) uxListRemove( pxEventListItem );
    1c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4e:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3268
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	9a 81       	ldd	r25, Y+2	; 0x02
    1c56:	02 96       	adiw	r24, 0x02	; 2
    1c58:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3269
    prvAddTaskToReadyList( pxUnblockedTCB );
    1c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c60:	96 89       	ldd	r25, Z+22	; 0x16
    1c62:	80 91 ab 03 	lds	r24, 0x03AB
    1c66:	89 17       	cp	r24, r25
    1c68:	28 f4       	brcc	.+10     	; 0x1c74 <vTaskRemoveFromUnorderedEventList+0x5a>
    1c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6e:	86 89       	ldd	r24, Z+22	; 0x16
    1c70:	80 93 ab 03 	sts	0x03AB, r24
    1c74:	e9 81       	ldd	r30, Y+1	; 0x01
    1c76:	fa 81       	ldd	r31, Y+2	; 0x02
    1c78:	86 89       	ldd	r24, Z+22	; 0x16
    1c7a:	28 2f       	mov	r18, r24
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	c9 01       	movw	r24, r18
    1c80:	88 0f       	add	r24, r24
    1c82:	99 1f       	adc	r25, r25
    1c84:	88 0f       	add	r24, r24
    1c86:	99 1f       	adc	r25, r25
    1c88:	88 0f       	add	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	82 0f       	add	r24, r18
    1c8e:	93 1f       	adc	r25, r19
    1c90:	ac 01       	movw	r20, r24
    1c92:	49 54       	subi	r20, 0x49	; 73
    1c94:	5c 4f       	sbci	r21, 0xFC	; 252
    1c96:	89 81       	ldd	r24, Y+1	; 0x01
    1c98:	9a 81       	ldd	r25, Y+2	; 0x02
    1c9a:	9c 01       	movw	r18, r24
    1c9c:	2e 5f       	subi	r18, 0xFE	; 254
    1c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca0:	ca 01       	movw	r24, r20
    1ca2:	b9 01       	movw	r22, r18
    1ca4:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3271

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    1caa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cac:	96 89       	ldd	r25, Z+22	; 0x16
    1cae:	e0 91 a5 03 	lds	r30, 0x03A5
    1cb2:	f0 91 a6 03 	lds	r31, 0x03A6
    1cb6:	86 89       	ldd	r24, Z+22	; 0x16
    1cb8:	89 17       	cp	r24, r25
    1cba:	18 f4       	brcc	.+6      	; 0x1cc2 <vTaskRemoveFromUnorderedEventList+0xa8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3277
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3279
    }
}
    1cc2:	26 96       	adiw	r28, 0x06	; 6
    1cc4:	0f b6       	in	r0, 0x3f	; 63
    1cc6:	f8 94       	cli
    1cc8:	de bf       	out	0x3e, r29	; 62
    1cca:	0f be       	out	0x3f, r0	; 63
    1ccc:	cd bf       	out	0x3d, r28	; 61
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <vTaskSetTimeOutState>:
vTaskSetTimeOutState():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3283
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1cd4:	df 93       	push	r29
    1cd6:	cf 93       	push	r28
    1cd8:	00 d0       	rcall	.+0      	; 0x1cda <vTaskSetTimeOutState+0x6>
    1cda:	cd b7       	in	r28, 0x3d	; 61
    1cdc:	de b7       	in	r29, 0x3e	; 62
    1cde:	9a 83       	std	Y+2, r25	; 0x02
    1ce0:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3285
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	f8 94       	cli
    1ce6:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3287
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ce8:	80 91 b0 03 	lds	r24, 0x03B0
    1cec:	e9 81       	ldd	r30, Y+1	; 0x01
    1cee:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf0:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3288
        pxTimeOut->xTimeOnEntering = xTickCount;
    1cf2:	80 91 a9 03 	lds	r24, 0x03A9
    1cf6:	90 91 aa 03 	lds	r25, 0x03AA
    1cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfe:	92 83       	std	Z+2, r25	; 0x02
    1d00:	81 83       	std	Z+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3290
    }
    taskEXIT_CRITICAL();
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3291
}
    1d06:	0f 90       	pop	r0
    1d08:	0f 90       	pop	r0
    1d0a:	cf 91       	pop	r28
    1d0c:	df 91       	pop	r29
    1d0e:	08 95       	ret

00001d10 <vTaskInternalSetTimeOutState>:
vTaskInternalSetTimeOutState():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3295
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1d10:	df 93       	push	r29
    1d12:	cf 93       	push	r28
    1d14:	00 d0       	rcall	.+0      	; 0x1d16 <vTaskInternalSetTimeOutState+0x6>
    1d16:	cd b7       	in	r28, 0x3d	; 61
    1d18:	de b7       	in	r29, 0x3e	; 62
    1d1a:	9a 83       	std	Y+2, r25	; 0x02
    1d1c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3297
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1d1e:	80 91 b0 03 	lds	r24, 0x03B0
    1d22:	e9 81       	ldd	r30, Y+1	; 0x01
    1d24:	fa 81       	ldd	r31, Y+2	; 0x02
    1d26:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3298
    pxTimeOut->xTimeOnEntering = xTickCount;
    1d28:	80 91 a9 03 	lds	r24, 0x03A9
    1d2c:	90 91 aa 03 	lds	r25, 0x03AA
    1d30:	e9 81       	ldd	r30, Y+1	; 0x01
    1d32:	fa 81       	ldd	r31, Y+2	; 0x02
    1d34:	92 83       	std	Z+2, r25	; 0x02
    1d36:	81 83       	std	Z+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3299
}
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	cf 91       	pop	r28
    1d3e:	df 91       	pop	r29
    1d40:	08 95       	ret

00001d42 <xTaskCheckForTimeOut>:
xTaskCheckForTimeOut():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3304
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
    1d4a:	29 97       	sbiw	r28, 0x09	; 9
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	de bf       	out	0x3e, r29	; 62
    1d52:	0f be       	out	0x3f, r0	; 63
    1d54:	cd bf       	out	0x3d, r28	; 61
    1d56:	9f 83       	std	Y+7, r25	; 0x07
    1d58:	8e 83       	std	Y+6, r24	; 0x06
    1d5a:	79 87       	std	Y+9, r23	; 0x09
    1d5c:	68 87       	std	Y+8, r22	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3310
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3313
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    1d64:	80 91 a9 03 	lds	r24, 0x03A9
    1d68:	90 91 aa 03 	lds	r25, 0x03AA
    1d6c:	9c 83       	std	Y+4, r25	; 0x04
    1d6e:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3314
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1d70:	ee 81       	ldd	r30, Y+6	; 0x06
    1d72:	ff 81       	ldd	r31, Y+7	; 0x07
    1d74:	21 81       	ldd	r18, Z+1	; 0x01
    1d76:	32 81       	ldd	r19, Z+2	; 0x02
    1d78:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7c:	82 1b       	sub	r24, r18
    1d7e:	93 0b       	sbc	r25, r19
    1d80:	9a 83       	std	Y+2, r25	; 0x02
    1d82:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3338
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1d84:	ee 81       	ldd	r30, Y+6	; 0x06
    1d86:	ff 81       	ldd	r31, Y+7	; 0x07
    1d88:	90 81       	ld	r25, Z
    1d8a:	80 91 b0 03 	lds	r24, 0x03B0
    1d8e:	98 17       	cp	r25, r24
    1d90:	81 f0       	breq	.+32     	; 0x1db2 <xTaskCheckForTimeOut+0x70>
    1d92:	ee 81       	ldd	r30, Y+6	; 0x06
    1d94:	ff 81       	ldd	r31, Y+7	; 0x07
    1d96:	21 81       	ldd	r18, Z+1	; 0x01
    1d98:	32 81       	ldd	r19, Z+2	; 0x02
    1d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d9e:	82 17       	cp	r24, r18
    1da0:	93 07       	cpc	r25, r19
    1da2:	38 f0       	brcs	.+14     	; 0x1db2 <xTaskCheckForTimeOut+0x70>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3345
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    1da4:	81 e0       	ldi	r24, 0x01	; 1
    1da6:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3346
            *pxTicksToWait = ( TickType_t ) 0;
    1da8:	e8 85       	ldd	r30, Y+8	; 0x08
    1daa:	f9 85       	ldd	r31, Y+9	; 0x09
    1dac:	11 82       	std	Z+1, r1	; 0x01
    1dae:	10 82       	st	Z, r1
    1db0:	23 c0       	rjmp	.+70     	; 0x1df8 <xTaskCheckForTimeOut+0xb6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3348
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1db2:	e8 85       	ldd	r30, Y+8	; 0x08
    1db4:	f9 85       	ldd	r31, Y+9	; 0x09
    1db6:	20 81       	ld	r18, Z
    1db8:	31 81       	ldd	r19, Z+1	; 0x01
    1dba:	89 81       	ldd	r24, Y+1	; 0x01
    1dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dbe:	82 17       	cp	r24, r18
    1dc0:	93 07       	cpc	r25, r19
    1dc2:	a0 f4       	brcc	.+40     	; 0x1dec <xTaskCheckForTimeOut+0xaa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3351
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    1dc4:	e8 85       	ldd	r30, Y+8	; 0x08
    1dc6:	f9 85       	ldd	r31, Y+9	; 0x09
    1dc8:	20 81       	ld	r18, Z
    1dca:	31 81       	ldd	r19, Z+1	; 0x01
    1dcc:	89 81       	ldd	r24, Y+1	; 0x01
    1dce:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd0:	a9 01       	movw	r20, r18
    1dd2:	48 1b       	sub	r20, r24
    1dd4:	59 0b       	sbc	r21, r25
    1dd6:	ca 01       	movw	r24, r20
    1dd8:	e8 85       	ldd	r30, Y+8	; 0x08
    1dda:	f9 85       	ldd	r31, Y+9	; 0x09
    1ddc:	91 83       	std	Z+1, r25	; 0x01
    1dde:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3352
            vTaskInternalSetTimeOutState( pxTimeOut );
    1de0:	8e 81       	ldd	r24, Y+6	; 0x06
    1de2:	9f 81       	ldd	r25, Y+7	; 0x07
    1de4:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskInternalSetTimeOutState>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3353
            xReturn = pdFALSE;
    1de8:	1d 82       	std	Y+5, r1	; 0x05
    1dea:	06 c0       	rjmp	.+12     	; 0x1df8 <xTaskCheckForTimeOut+0xb6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3357
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    1dec:	e8 85       	ldd	r30, Y+8	; 0x08
    1dee:	f9 85       	ldd	r31, Y+9	; 0x09
    1df0:	11 82       	std	Z+1, r1	; 0x01
    1df2:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3358
            xReturn = pdTRUE;
    1df4:	81 e0       	ldi	r24, 0x01	; 1
    1df6:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3361
        }
    }
    taskEXIT_CRITICAL();
    1df8:	0f 90       	pop	r0
    1dfa:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3363

    return xReturn;
    1dfc:	8d 81       	ldd	r24, Y+5	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3364
}
    1dfe:	29 96       	adiw	r28, 0x09	; 9
    1e00:	0f b6       	in	r0, 0x3f	; 63
    1e02:	f8 94       	cli
    1e04:	de bf       	out	0x3e, r29	; 62
    1e06:	0f be       	out	0x3f, r0	; 63
    1e08:	cd bf       	out	0x3d, r28	; 61
    1e0a:	cf 91       	pop	r28
    1e0c:	df 91       	pop	r29
    1e0e:	08 95       	ret

00001e10 <vTaskMissedYield>:
vTaskMissedYield():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3368
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    1e10:	df 93       	push	r29
    1e12:	cf 93       	push	r28
    1e14:	cd b7       	in	r28, 0x3d	; 61
    1e16:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3369
    xYieldPending = pdTRUE;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3370
}
    1e1e:	cf 91       	pop	r28
    1e20:	df 91       	pop	r29
    1e22:	08 95       	ret

00001e24 <prvIdleTask>:
prvIdleTask():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3424
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1e24:	df 93       	push	r29
    1e26:	cf 93       	push	r28
    1e28:	00 d0       	rcall	.+0      	; 0x1e2a <prvIdleTask+0x6>
    1e2a:	cd b7       	in	r28, 0x3d	; 61
    1e2c:	de b7       	in	r29, 0x3e	; 62
    1e2e:	9a 83       	std	Y+2, r25	; 0x02
    1e30:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3440

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    1e32:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <prvCheckTasksWaitingTermination>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3463
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1e36:	80 91 b7 03 	lds	r24, 0x03B7
    1e3a:	82 30       	cpi	r24, 0x02	; 2
    1e3c:	10 f0       	brcs	.+4      	; 0x1e42 <prvIdleTask+0x1e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3465
                {
                    taskYIELD();
    1e3e:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3483
                /* Call the user defined function from within the idle task.  This
                 * allows the application designer to add background functionality
                 * without the overhead of a separate task.
                 * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
                 * CALL A FUNCTION THAT MIGHT BLOCK. */
                vApplicationIdleHook();
    1e42:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <vApplicationIdleHook>
    1e46:	f5 cf       	rjmp	.-22     	; 0x1e32 <prvIdleTask+0xe>

00001e48 <prvInitialiseTaskLists>:
prvInitialiseTaskLists():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3649

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    1e48:	df 93       	push	r29
    1e4a:	cf 93       	push	r28
    1e4c:	0f 92       	push	r0
    1e4e:	cd b7       	in	r28, 0x3d	; 61
    1e50:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3652
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1e52:	19 82       	std	Y+1, r1	; 0x01
    1e54:	13 c0       	rjmp	.+38     	; 0x1e7c <prvInitialiseTaskLists+0x34>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3654
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1e56:	89 81       	ldd	r24, Y+1	; 0x01
    1e58:	28 2f       	mov	r18, r24
    1e5a:	30 e0       	ldi	r19, 0x00	; 0
    1e5c:	c9 01       	movw	r24, r18
    1e5e:	88 0f       	add	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	88 0f       	add	r24, r24
    1e64:	99 1f       	adc	r25, r25
    1e66:	88 0f       	add	r24, r24
    1e68:	99 1f       	adc	r25, r25
    1e6a:	82 0f       	add	r24, r18
    1e6c:	93 1f       	adc	r25, r19
    1e6e:	89 54       	subi	r24, 0x49	; 73
    1e70:	9c 4f       	sbci	r25, 0xFC	; 252
    1e72:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3652

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1e76:	89 81       	ldd	r24, Y+1	; 0x01
    1e78:	8f 5f       	subi	r24, 0xFF	; 255
    1e7a:	89 83       	std	Y+1, r24	; 0x01
    1e7c:	89 81       	ldd	r24, Y+1	; 0x01
    1e7e:	84 30       	cpi	r24, 0x04	; 4
    1e80:	50 f3       	brcs	.-44     	; 0x1e56 <prvInitialiseTaskLists+0xe>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3657
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    1e82:	8b ed       	ldi	r24, 0xDB	; 219
    1e84:	93 e0       	ldi	r25, 0x03	; 3
    1e86:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3658
    vListInitialise( &xDelayedTaskList2 );
    1e8a:	84 ee       	ldi	r24, 0xE4	; 228
    1e8c:	93 e0       	ldi	r25, 0x03	; 3
    1e8e:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3659
    vListInitialise( &xPendingReadyList );
    1e92:	81 ef       	ldi	r24, 0xF1	; 241
    1e94:	93 e0       	ldi	r25, 0x03	; 3
    1e96:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3663

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    1e9a:	8a ef       	ldi	r24, 0xFA	; 250
    1e9c:	93 e0       	ldi	r25, 0x03	; 3
    1e9e:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3675
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    1ea2:	8b ed       	ldi	r24, 0xDB	; 219
    1ea4:	93 e0       	ldi	r25, 0x03	; 3
    1ea6:	90 93 ee 03 	sts	0x03EE, r25
    1eaa:	80 93 ed 03 	sts	0x03ED, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3676
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1eae:	84 ee       	ldi	r24, 0xE4	; 228
    1eb0:	93 e0       	ldi	r25, 0x03	; 3
    1eb2:	90 93 f0 03 	sts	0x03F0, r25
    1eb6:	80 93 ef 03 	sts	0x03EF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3677
}
    1eba:	0f 90       	pop	r0
    1ebc:	cf 91       	pop	r28
    1ebe:	df 91       	pop	r29
    1ec0:	08 95       	ret

00001ec2 <prvCheckTasksWaitingTermination>:
prvCheckTasksWaitingTermination():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3681
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1ec2:	df 93       	push	r29
    1ec4:	cf 93       	push	r28
    1ec6:	00 d0       	rcall	.+0      	; 0x1ec8 <prvCheckTasksWaitingTermination+0x6>
    1ec8:	cd b7       	in	r28, 0x3d	; 61
    1eca:	de b7       	in	r29, 0x3e	; 62
    1ecc:	20 c0       	rjmp	.+64     	; 0x1f0e <prvCheckTasksWaitingTermination+0x4c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3692

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    1ece:	0f b6       	in	r0, 0x3f	; 63
    1ed0:	f8 94       	cli
    1ed2:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3694
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1ed4:	e0 91 ff 03 	lds	r30, 0x03FF
    1ed8:	f0 91 00 04 	lds	r31, 0x0400
    1edc:	86 81       	ldd	r24, Z+6	; 0x06
    1ede:	97 81       	ldd	r25, Z+7	; 0x07
    1ee0:	9a 83       	std	Y+2, r25	; 0x02
    1ee2:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3695
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
    1ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee8:	02 96       	adiw	r24, 0x02	; 2
    1eea:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3696
                    --uxCurrentNumberOfTasks;
    1eee:	80 91 a8 03 	lds	r24, 0x03A8
    1ef2:	81 50       	subi	r24, 0x01	; 1
    1ef4:	80 93 a8 03 	sts	0x03A8, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3697
                    --uxDeletedTasksWaitingCleanUp;
    1ef8:	80 91 a7 03 	lds	r24, 0x03A7
    1efc:	81 50       	subi	r24, 0x01	; 1
    1efe:	80 93 a7 03 	sts	0x03A7, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3699
                }
                taskEXIT_CRITICAL();
    1f02:	0f 90       	pop	r0
    1f04:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3701

                prvDeleteTCB( pxTCB );
    1f06:	89 81       	ldd	r24, Y+1	; 0x01
    1f08:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0a:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <prvDeleteTCB>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3690
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1f0e:	80 91 a7 03 	lds	r24, 0x03A7
    1f12:	88 23       	and	r24, r24
    1f14:	e1 f6       	brne	.-72     	; 0x1ece <prvCheckTasksWaitingTermination+0xc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3705

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    1f16:	0f 90       	pop	r0
    1f18:	0f 90       	pop	r0
    1f1a:	cf 91       	pop	r28
    1f1c:	df 91       	pop	r29
    1f1e:	08 95       	ret

00001f20 <prvTaskCheckFreeStackSpace>:
prvTaskCheckFreeStackSpace():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3845
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
    1f20:	df 93       	push	r29
    1f22:	cf 93       	push	r28
    1f24:	00 d0       	rcall	.+0      	; 0x1f26 <prvTaskCheckFreeStackSpace+0x6>
    1f26:	00 d0       	rcall	.+0      	; 0x1f28 <prvTaskCheckFreeStackSpace+0x8>
    1f28:	00 d0       	rcall	.+0      	; 0x1f2a <prvTaskCheckFreeStackSpace+0xa>
    1f2a:	cd b7       	in	r28, 0x3d	; 61
    1f2c:	de b7       	in	r29, 0x3e	; 62
    1f2e:	9e 83       	std	Y+6, r25	; 0x06
    1f30:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3846
        uint32_t ulCount = 0U;
    1f32:	19 82       	std	Y+1, r1	; 0x01
    1f34:	1a 82       	std	Y+2, r1	; 0x02
    1f36:	1b 82       	std	Y+3, r1	; 0x03
    1f38:	1c 82       	std	Y+4, r1	; 0x04
    1f3a:	10 c0       	rjmp	.+32     	; 0x1f5c <prvTaskCheckFreeStackSpace+0x3c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3850

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
        {
            pucStackByte -= portSTACK_GROWTH;
    1f3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f40:	01 96       	adiw	r24, 0x01	; 1
    1f42:	9e 83       	std	Y+6, r25	; 0x06
    1f44:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3851
            ulCount++;
    1f46:	89 81       	ldd	r24, Y+1	; 0x01
    1f48:	9a 81       	ldd	r25, Y+2	; 0x02
    1f4a:	ab 81       	ldd	r26, Y+3	; 0x03
    1f4c:	bc 81       	ldd	r27, Y+4	; 0x04
    1f4e:	01 96       	adiw	r24, 0x01	; 1
    1f50:	a1 1d       	adc	r26, r1
    1f52:	b1 1d       	adc	r27, r1
    1f54:	89 83       	std	Y+1, r24	; 0x01
    1f56:	9a 83       	std	Y+2, r25	; 0x02
    1f58:	ab 83       	std	Y+3, r26	; 0x03
    1f5a:	bc 83       	std	Y+4, r27	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3848

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        uint32_t ulCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    1f5c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f5e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f60:	80 81       	ld	r24, Z
    1f62:	85 3a       	cpi	r24, 0xA5	; 165
    1f64:	59 f3       	breq	.-42     	; 0x1f3c <prvTaskCheckFreeStackSpace+0x1c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3856
            ulCount++;
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

        return ( configSTACK_DEPTH_TYPE ) ulCount;
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3857
    }
    1f6a:	26 96       	adiw	r28, 0x06	; 6
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	de bf       	out	0x3e, r29	; 62
    1f72:	0f be       	out	0x3f, r0	; 63
    1f74:	cd bf       	out	0x3d, r28	; 61
    1f76:	cf 91       	pop	r28
    1f78:	df 91       	pop	r29
    1f7a:	08 95       	ret

00001f7c <uxTaskGetStackHighWaterMark>:
uxTaskGetStackHighWaterMark():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3905
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	cd b7       	in	r28, 0x3d	; 61
    1f82:	de b7       	in	r29, 0x3e	; 62
    1f84:	29 97       	sbiw	r28, 0x09	; 9
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	9f 83       	std	Y+7, r25	; 0x07
    1f92:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3910
        TCB_t * pxTCB;
        uint8_t * pucEndOfStack;
        UBaseType_t uxReturn;

        pxTCB = prvGetTCBFromHandle( xTask );
    1f94:	8e 81       	ldd	r24, Y+6	; 0x06
    1f96:	9f 81       	ldd	r25, Y+7	; 0x07
    1f98:	00 97       	sbiw	r24, 0x00	; 0
    1f9a:	39 f4       	brne	.+14     	; 0x1faa <uxTaskGetStackHighWaterMark+0x2e>
    1f9c:	80 91 a5 03 	lds	r24, 0x03A5
    1fa0:	90 91 a6 03 	lds	r25, 0x03A6
    1fa4:	99 87       	std	Y+9, r25	; 0x09
    1fa6:	88 87       	std	Y+8, r24	; 0x08
    1fa8:	04 c0       	rjmp	.+8      	; 0x1fb2 <uxTaskGetStackHighWaterMark+0x36>
    1faa:	8e 81       	ldd	r24, Y+6	; 0x06
    1fac:	9f 81       	ldd	r25, Y+7	; 0x07
    1fae:	99 87       	std	Y+9, r25	; 0x09
    1fb0:	88 87       	std	Y+8, r24	; 0x08
    1fb2:	88 85       	ldd	r24, Y+8	; 0x08
    1fb4:	99 85       	ldd	r25, Y+9	; 0x09
    1fb6:	9d 83       	std	Y+5, r25	; 0x05
    1fb8:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3914

        #if portSTACK_GROWTH < 0
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
    1fba:	ec 81       	ldd	r30, Y+4	; 0x04
    1fbc:	fd 81       	ldd	r31, Y+5	; 0x05
    1fbe:	87 89       	ldd	r24, Z+23	; 0x17
    1fc0:	90 8d       	ldd	r25, Z+24	; 0x18
    1fc2:	9b 83       	std	Y+3, r25	; 0x03
    1fc4:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3922
            {
                pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
            }
        #endif

        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
    1fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fca:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <prvTaskCheckFreeStackSpace>
    1fce:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3924

        return uxReturn;
    1fd0:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3925
    }
    1fd2:	29 96       	adiw	r28, 0x09	; 9
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	de bf       	out	0x3e, r29	; 62
    1fda:	0f be       	out	0x3f, r0	; 63
    1fdc:	cd bf       	out	0x3d, r28	; 61
    1fde:	cf 91       	pop	r28
    1fe0:	df 91       	pop	r29
    1fe2:	08 95       	ret

00001fe4 <prvDeleteTCB>:
prvDeleteTCB():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3933
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    1fe4:	df 93       	push	r29
    1fe6:	cf 93       	push	r28
    1fe8:	00 d0       	rcall	.+0      	; 0x1fea <prvDeleteTCB+0x6>
    1fea:	cd b7       	in	r28, 0x3d	; 61
    1fec:	de b7       	in	r29, 0x3e	; 62
    1fee:	9a 83       	std	Y+2, r25	; 0x02
    1ff0:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3983
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    1ff2:	0f 90       	pop	r0
    1ff4:	0f 90       	pop	r0
    1ff6:	cf 91       	pop	r28
    1ff8:	df 91       	pop	r29
    1ffa:	08 95       	ret

00001ffc <prvResetNextTaskUnblockTime>:
prvResetNextTaskUnblockTime():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3989

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1ffc:	df 93       	push	r29
    1ffe:	cf 93       	push	r28
    2000:	cd b7       	in	r28, 0x3d	; 61
    2002:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3990
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2004:	e0 91 ed 03 	lds	r30, 0x03ED
    2008:	f0 91 ee 03 	lds	r31, 0x03EE
    200c:	80 81       	ld	r24, Z
    200e:	88 23       	and	r24, r24
    2010:	39 f4       	brne	.+14     	; 0x2020 <prvResetNextTaskUnblockTime+0x24>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:3996
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2012:	8f ef       	ldi	r24, 0xFF	; 255
    2014:	9f ef       	ldi	r25, 0xFF	; 255
    2016:	90 93 b3 03 	sts	0x03B3, r25
    201a:	80 93 b2 03 	sts	0x03B2, r24
    201e:	0d c0       	rjmp	.+26     	; 0x203a <prvResetNextTaskUnblockTime+0x3e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4004
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2020:	e0 91 ed 03 	lds	r30, 0x03ED
    2024:	f0 91 ee 03 	lds	r31, 0x03EE
    2028:	05 80       	ldd	r0, Z+5	; 0x05
    202a:	f6 81       	ldd	r31, Z+6	; 0x06
    202c:	e0 2d       	mov	r30, r0
    202e:	80 81       	ld	r24, Z
    2030:	91 81       	ldd	r25, Z+1	; 0x01
    2032:	90 93 b3 03 	sts	0x03B3, r25
    2036:	80 93 b2 03 	sts	0x03B2, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4006
    }
}
    203a:	cf 91       	pop	r28
    203c:	df 91       	pop	r29
    203e:	08 95       	ret

00002040 <xTaskGetCurrentTaskHandle>:
xTaskGetCurrentTaskHandle():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4012
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    2040:	df 93       	push	r29
    2042:	cf 93       	push	r28
    2044:	00 d0       	rcall	.+0      	; 0x2046 <xTaskGetCurrentTaskHandle+0x6>
    2046:	cd b7       	in	r28, 0x3d	; 61
    2048:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4018
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    204a:	80 91 a5 03 	lds	r24, 0x03A5
    204e:	90 91 a6 03 	lds	r25, 0x03A6
    2052:	9a 83       	std	Y+2, r25	; 0x02
    2054:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4020

        return xReturn;
    2056:	89 81       	ldd	r24, Y+1	; 0x01
    2058:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4021
    }
    205a:	0f 90       	pop	r0
    205c:	0f 90       	pop	r0
    205e:	cf 91       	pop	r28
    2060:	df 91       	pop	r29
    2062:	08 95       	ret

00002064 <xTaskPriorityInherit>:
xTaskPriorityInherit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4057
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    2064:	df 93       	push	r29
    2066:	cf 93       	push	r28
    2068:	00 d0       	rcall	.+0      	; 0x206a <xTaskPriorityInherit+0x6>
    206a:	00 d0       	rcall	.+0      	; 0x206c <xTaskPriorityInherit+0x8>
    206c:	0f 92       	push	r0
    206e:	cd b7       	in	r28, 0x3d	; 61
    2070:	de b7       	in	r29, 0x3e	; 62
    2072:	9d 83       	std	Y+5, r25	; 0x05
    2074:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4058
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    2076:	8c 81       	ldd	r24, Y+4	; 0x04
    2078:	9d 81       	ldd	r25, Y+5	; 0x05
    207a:	9b 83       	std	Y+3, r25	; 0x03
    207c:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4059
        BaseType_t xReturn = pdFALSE;
    207e:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4064

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    2080:	8c 81       	ldd	r24, Y+4	; 0x04
    2082:	9d 81       	ldd	r25, Y+5	; 0x05
    2084:	00 97       	sbiw	r24, 0x00	; 0
    2086:	09 f4       	brne	.+2      	; 0x208a <xTaskPriorityInherit+0x26>
    2088:	82 c0       	rjmp	.+260    	; 0x218e <xTaskPriorityInherit+0x12a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4069
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    208a:	ea 81       	ldd	r30, Y+2	; 0x02
    208c:	fb 81       	ldd	r31, Y+3	; 0x03
    208e:	96 89       	ldd	r25, Z+22	; 0x16
    2090:	e0 91 a5 03 	lds	r30, 0x03A5
    2094:	f0 91 a6 03 	lds	r31, 0x03A6
    2098:	86 89       	ldd	r24, Z+22	; 0x16
    209a:	98 17       	cp	r25, r24
    209c:	08 f0       	brcs	.+2      	; 0x20a0 <xTaskPriorityInherit+0x3c>
    209e:	6b c0       	rjmp	.+214    	; 0x2176 <xTaskPriorityInherit+0x112>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4074
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    20a0:	ea 81       	ldd	r30, Y+2	; 0x02
    20a2:	fb 81       	ldd	r31, Y+3	; 0x03
    20a4:	84 85       	ldd	r24, Z+12	; 0x0c
    20a6:	95 85       	ldd	r25, Z+13	; 0x0d
    20a8:	99 23       	and	r25, r25
    20aa:	7c f0       	brlt	.+30     	; 0x20ca <xTaskPriorityInherit+0x66>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4076
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20ac:	e0 91 a5 03 	lds	r30, 0x03A5
    20b0:	f0 91 a6 03 	lds	r31, 0x03A6
    20b4:	86 89       	ldd	r24, Z+22	; 0x16
    20b6:	28 2f       	mov	r18, r24
    20b8:	30 e0       	ldi	r19, 0x00	; 0
    20ba:	84 e0       	ldi	r24, 0x04	; 4
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	82 1b       	sub	r24, r18
    20c0:	93 0b       	sbc	r25, r19
    20c2:	ea 81       	ldd	r30, Y+2	; 0x02
    20c4:	fb 81       	ldd	r31, Y+3	; 0x03
    20c6:	95 87       	std	Z+13, r25	; 0x0d
    20c8:	84 87       	std	Z+12, r24	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4085
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    20ca:	ea 81       	ldd	r30, Y+2	; 0x02
    20cc:	fb 81       	ldd	r31, Y+3	; 0x03
    20ce:	42 85       	ldd	r20, Z+10	; 0x0a
    20d0:	53 85       	ldd	r21, Z+11	; 0x0b
    20d2:	ea 81       	ldd	r30, Y+2	; 0x02
    20d4:	fb 81       	ldd	r31, Y+3	; 0x03
    20d6:	86 89       	ldd	r24, Z+22	; 0x16
    20d8:	28 2f       	mov	r18, r24
    20da:	30 e0       	ldi	r19, 0x00	; 0
    20dc:	c9 01       	movw	r24, r18
    20de:	88 0f       	add	r24, r24
    20e0:	99 1f       	adc	r25, r25
    20e2:	88 0f       	add	r24, r24
    20e4:	99 1f       	adc	r25, r25
    20e6:	88 0f       	add	r24, r24
    20e8:	99 1f       	adc	r25, r25
    20ea:	82 0f       	add	r24, r18
    20ec:	93 1f       	adc	r25, r19
    20ee:	89 54       	subi	r24, 0x49	; 73
    20f0:	9c 4f       	sbci	r25, 0xFC	; 252
    20f2:	48 17       	cp	r20, r24
    20f4:	59 07       	cpc	r21, r25
    20f6:	a1 f5       	brne	.+104    	; 0x2160 <xTaskPriorityInherit+0xfc>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4087
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    20f8:	8a 81       	ldd	r24, Y+2	; 0x02
    20fa:	9b 81       	ldd	r25, Y+3	; 0x03
    20fc:	02 96       	adiw	r24, 0x02	; 2
    20fe:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4100
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    2102:	e0 91 a5 03 	lds	r30, 0x03A5
    2106:	f0 91 a6 03 	lds	r31, 0x03A6
    210a:	86 89       	ldd	r24, Z+22	; 0x16
    210c:	ea 81       	ldd	r30, Y+2	; 0x02
    210e:	fb 81       	ldd	r31, Y+3	; 0x03
    2110:	86 8b       	std	Z+22, r24	; 0x16
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4101
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    2112:	ea 81       	ldd	r30, Y+2	; 0x02
    2114:	fb 81       	ldd	r31, Y+3	; 0x03
    2116:	96 89       	ldd	r25, Z+22	; 0x16
    2118:	80 91 ab 03 	lds	r24, 0x03AB
    211c:	89 17       	cp	r24, r25
    211e:	28 f4       	brcc	.+10     	; 0x212a <xTaskPriorityInherit+0xc6>
    2120:	ea 81       	ldd	r30, Y+2	; 0x02
    2122:	fb 81       	ldd	r31, Y+3	; 0x03
    2124:	86 89       	ldd	r24, Z+22	; 0x16
    2126:	80 93 ab 03 	sts	0x03AB, r24
    212a:	ea 81       	ldd	r30, Y+2	; 0x02
    212c:	fb 81       	ldd	r31, Y+3	; 0x03
    212e:	86 89       	ldd	r24, Z+22	; 0x16
    2130:	28 2f       	mov	r18, r24
    2132:	30 e0       	ldi	r19, 0x00	; 0
    2134:	c9 01       	movw	r24, r18
    2136:	88 0f       	add	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	88 0f       	add	r24, r24
    213c:	99 1f       	adc	r25, r25
    213e:	88 0f       	add	r24, r24
    2140:	99 1f       	adc	r25, r25
    2142:	82 0f       	add	r24, r18
    2144:	93 1f       	adc	r25, r19
    2146:	ac 01       	movw	r20, r24
    2148:	49 54       	subi	r20, 0x49	; 73
    214a:	5c 4f       	sbci	r21, 0xFC	; 252
    214c:	8a 81       	ldd	r24, Y+2	; 0x02
    214e:	9b 81       	ldd	r25, Y+3	; 0x03
    2150:	9c 01       	movw	r18, r24
    2152:	2e 5f       	subi	r18, 0xFE	; 254
    2154:	3f 4f       	sbci	r19, 0xFF	; 255
    2156:	ca 01       	movw	r24, r20
    2158:	b9 01       	movw	r22, r18
    215a:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
    215e:	08 c0       	rjmp	.+16     	; 0x2170 <xTaskPriorityInherit+0x10c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4106
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    2160:	e0 91 a5 03 	lds	r30, 0x03A5
    2164:	f0 91 a6 03 	lds	r31, 0x03A6
    2168:	86 89       	ldd	r24, Z+22	; 0x16
    216a:	ea 81       	ldd	r30, Y+2	; 0x02
    216c:	fb 81       	ldd	r31, Y+3	; 0x03
    216e:	86 8b       	std	Z+22, r24	; 0x16
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4112
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
    2170:	81 e0       	ldi	r24, 0x01	; 1
    2172:	89 83       	std	Y+1, r24	; 0x01
    2174:	0c c0       	rjmp	.+24     	; 0x218e <xTaskPriorityInherit+0x12a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4116
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    2176:	ea 81       	ldd	r30, Y+2	; 0x02
    2178:	fb 81       	ldd	r31, Y+3	; 0x03
    217a:	91 a1       	ldd	r25, Z+33	; 0x21
    217c:	e0 91 a5 03 	lds	r30, 0x03A5
    2180:	f0 91 a6 03 	lds	r31, 0x03A6
    2184:	86 89       	ldd	r24, Z+22	; 0x16
    2186:	98 17       	cp	r25, r24
    2188:	10 f4       	brcc	.+4      	; 0x218e <xTaskPriorityInherit+0x12a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4125
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
    218a:	81 e0       	ldi	r24, 0x01	; 1
    218c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4138
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    218e:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4139
    }
    2190:	0f 90       	pop	r0
    2192:	0f 90       	pop	r0
    2194:	0f 90       	pop	r0
    2196:	0f 90       	pop	r0
    2198:	0f 90       	pop	r0
    219a:	cf 91       	pop	r28
    219c:	df 91       	pop	r29
    219e:	08 95       	ret

000021a0 <xTaskPriorityDisinherit>:
xTaskPriorityDisinherit():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4147
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    21a0:	df 93       	push	r29
    21a2:	cf 93       	push	r28
    21a4:	00 d0       	rcall	.+0      	; 0x21a6 <xTaskPriorityDisinherit+0x6>
    21a6:	00 d0       	rcall	.+0      	; 0x21a8 <xTaskPriorityDisinherit+0x8>
    21a8:	0f 92       	push	r0
    21aa:	cd b7       	in	r28, 0x3d	; 61
    21ac:	de b7       	in	r29, 0x3e	; 62
    21ae:	9d 83       	std	Y+5, r25	; 0x05
    21b0:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4148
        TCB_t * const pxTCB = pxMutexHolder;
    21b2:	8c 81       	ldd	r24, Y+4	; 0x04
    21b4:	9d 81       	ldd	r25, Y+5	; 0x05
    21b6:	9b 83       	std	Y+3, r25	; 0x03
    21b8:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4149
        BaseType_t xReturn = pdFALSE;
    21ba:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4151

        if( pxMutexHolder != NULL )
    21bc:	8c 81       	ldd	r24, Y+4	; 0x04
    21be:	9d 81       	ldd	r25, Y+5	; 0x05
    21c0:	00 97       	sbiw	r24, 0x00	; 0
    21c2:	09 f4       	brne	.+2      	; 0x21c6 <xTaskPriorityDisinherit+0x26>
    21c4:	56 c0       	rjmp	.+172    	; 0x2272 <xTaskPriorityDisinherit+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4159
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    21c6:	ea 81       	ldd	r30, Y+2	; 0x02
    21c8:	fb 81       	ldd	r31, Y+3	; 0x03
    21ca:	82 a1       	ldd	r24, Z+34	; 0x22
    21cc:	81 50       	subi	r24, 0x01	; 1
    21ce:	ea 81       	ldd	r30, Y+2	; 0x02
    21d0:	fb 81       	ldd	r31, Y+3	; 0x03
    21d2:	82 a3       	std	Z+34, r24	; 0x22
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4163

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    21d4:	ea 81       	ldd	r30, Y+2	; 0x02
    21d6:	fb 81       	ldd	r31, Y+3	; 0x03
    21d8:	96 89       	ldd	r25, Z+22	; 0x16
    21da:	ea 81       	ldd	r30, Y+2	; 0x02
    21dc:	fb 81       	ldd	r31, Y+3	; 0x03
    21de:	81 a1       	ldd	r24, Z+33	; 0x21
    21e0:	98 17       	cp	r25, r24
    21e2:	09 f4       	brne	.+2      	; 0x21e6 <xTaskPriorityDisinherit+0x46>
    21e4:	46 c0       	rjmp	.+140    	; 0x2272 <xTaskPriorityDisinherit+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4166
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    21e6:	ea 81       	ldd	r30, Y+2	; 0x02
    21e8:	fb 81       	ldd	r31, Y+3	; 0x03
    21ea:	82 a1       	ldd	r24, Z+34	; 0x22
    21ec:	88 23       	and	r24, r24
    21ee:	09 f0       	breq	.+2      	; 0x21f2 <xTaskPriorityDisinherit+0x52>
    21f0:	40 c0       	rjmp	.+128    	; 0x2272 <xTaskPriorityDisinherit+0xd2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4173
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    21f2:	8a 81       	ldd	r24, Y+2	; 0x02
    21f4:	9b 81       	ldd	r25, Y+3	; 0x03
    21f6:	02 96       	adiw	r24, 0x02	; 2
    21f8:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4185
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    21fc:	ea 81       	ldd	r30, Y+2	; 0x02
    21fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2200:	81 a1       	ldd	r24, Z+33	; 0x21
    2202:	ea 81       	ldd	r30, Y+2	; 0x02
    2204:	fb 81       	ldd	r31, Y+3	; 0x03
    2206:	86 8b       	std	Z+22, r24	; 0x16
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4190

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2208:	ea 81       	ldd	r30, Y+2	; 0x02
    220a:	fb 81       	ldd	r31, Y+3	; 0x03
    220c:	86 89       	ldd	r24, Z+22	; 0x16
    220e:	28 2f       	mov	r18, r24
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	84 e0       	ldi	r24, 0x04	; 4
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	82 1b       	sub	r24, r18
    2218:	93 0b       	sbc	r25, r19
    221a:	ea 81       	ldd	r30, Y+2	; 0x02
    221c:	fb 81       	ldd	r31, Y+3	; 0x03
    221e:	95 87       	std	Z+13, r25	; 0x0d
    2220:	84 87       	std	Z+12, r24	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4191
                    prvAddTaskToReadyList( pxTCB );
    2222:	ea 81       	ldd	r30, Y+2	; 0x02
    2224:	fb 81       	ldd	r31, Y+3	; 0x03
    2226:	96 89       	ldd	r25, Z+22	; 0x16
    2228:	80 91 ab 03 	lds	r24, 0x03AB
    222c:	89 17       	cp	r24, r25
    222e:	28 f4       	brcc	.+10     	; 0x223a <xTaskPriorityDisinherit+0x9a>
    2230:	ea 81       	ldd	r30, Y+2	; 0x02
    2232:	fb 81       	ldd	r31, Y+3	; 0x03
    2234:	86 89       	ldd	r24, Z+22	; 0x16
    2236:	80 93 ab 03 	sts	0x03AB, r24
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	86 89       	ldd	r24, Z+22	; 0x16
    2240:	28 2f       	mov	r18, r24
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	c9 01       	movw	r24, r18
    2246:	88 0f       	add	r24, r24
    2248:	99 1f       	adc	r25, r25
    224a:	88 0f       	add	r24, r24
    224c:	99 1f       	adc	r25, r25
    224e:	88 0f       	add	r24, r24
    2250:	99 1f       	adc	r25, r25
    2252:	82 0f       	add	r24, r18
    2254:	93 1f       	adc	r25, r19
    2256:	ac 01       	movw	r20, r24
    2258:	49 54       	subi	r20, 0x49	; 73
    225a:	5c 4f       	sbci	r21, 0xFC	; 252
    225c:	8a 81       	ldd	r24, Y+2	; 0x02
    225e:	9b 81       	ldd	r25, Y+3	; 0x03
    2260:	9c 01       	movw	r18, r24
    2262:	2e 5f       	subi	r18, 0xFE	; 254
    2264:	3f 4f       	sbci	r19, 0xFF	; 255
    2266:	ca 01       	movw	r24, r20
    2268:	b9 01       	movw	r22, r18
    226a:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4201
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4218
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    2272:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4219
    }
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	0f 90       	pop	r0
    227e:	cf 91       	pop	r28
    2280:	df 91       	pop	r29
    2282:	08 95       	ret

00002284 <vTaskPriorityDisinheritAfterTimeout>:
vTaskPriorityDisinheritAfterTimeout():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4228

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    2284:	df 93       	push	r29
    2286:	cf 93       	push	r28
    2288:	cd b7       	in	r28, 0x3d	; 61
    228a:	de b7       	in	r29, 0x3e	; 62
    228c:	28 97       	sbiw	r28, 0x08	; 8
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	de bf       	out	0x3e, r29	; 62
    2294:	0f be       	out	0x3f, r0	; 63
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	9f 83       	std	Y+7, r25	; 0x07
    229a:	8e 83       	std	Y+6, r24	; 0x06
    229c:	68 87       	std	Y+8, r22	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4229
        TCB_t * const pxTCB = pxMutexHolder;
    229e:	8e 81       	ldd	r24, Y+6	; 0x06
    22a0:	9f 81       	ldd	r25, Y+7	; 0x07
    22a2:	9d 83       	std	Y+5, r25	; 0x05
    22a4:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4231
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4233

        if( pxMutexHolder != NULL )
    22aa:	8e 81       	ldd	r24, Y+6	; 0x06
    22ac:	9f 81       	ldd	r25, Y+7	; 0x07
    22ae:	00 97       	sbiw	r24, 0x00	; 0
    22b0:	09 f4       	brne	.+2      	; 0x22b4 <vTaskPriorityDisinheritAfterTimeout+0x30>
    22b2:	74 c0       	rjmp	.+232    	; 0x239c <vTaskPriorityDisinheritAfterTimeout+0x118>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4243

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    22b4:	ec 81       	ldd	r30, Y+4	; 0x04
    22b6:	fd 81       	ldd	r31, Y+5	; 0x05
    22b8:	91 a1       	ldd	r25, Z+33	; 0x21
    22ba:	88 85       	ldd	r24, Y+8	; 0x08
    22bc:	98 17       	cp	r25, r24
    22be:	18 f4       	brcc	.+6      	; 0x22c6 <vTaskPriorityDisinheritAfterTimeout+0x42>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4245
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
    22c0:	88 85       	ldd	r24, Y+8	; 0x08
    22c2:	8a 83       	std	Y+2, r24	; 0x02
    22c4:	04 c0       	rjmp	.+8      	; 0x22ce <vTaskPriorityDisinheritAfterTimeout+0x4a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4249
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
    22c6:	ec 81       	ldd	r30, Y+4	; 0x04
    22c8:	fd 81       	ldd	r31, Y+5	; 0x05
    22ca:	81 a1       	ldd	r24, Z+33	; 0x21
    22cc:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4253
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    22ce:	ec 81       	ldd	r30, Y+4	; 0x04
    22d0:	fd 81       	ldd	r31, Y+5	; 0x05
    22d2:	96 89       	ldd	r25, Z+22	; 0x16
    22d4:	8a 81       	ldd	r24, Y+2	; 0x02
    22d6:	98 17       	cp	r25, r24
    22d8:	09 f4       	brne	.+2      	; 0x22dc <vTaskPriorityDisinheritAfterTimeout+0x58>
    22da:	60 c0       	rjmp	.+192    	; 0x239c <vTaskPriorityDisinheritAfterTimeout+0x118>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4259
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    22dc:	ec 81       	ldd	r30, Y+4	; 0x04
    22de:	fd 81       	ldd	r31, Y+5	; 0x05
    22e0:	92 a1       	ldd	r25, Z+34	; 0x22
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	98 17       	cp	r25, r24
    22e6:	09 f0       	breq	.+2      	; 0x22ea <vTaskPriorityDisinheritAfterTimeout+0x66>
    22e8:	59 c0       	rjmp	.+178    	; 0x239c <vTaskPriorityDisinheritAfterTimeout+0x118>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4270

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
    22ea:	ec 81       	ldd	r30, Y+4	; 0x04
    22ec:	fd 81       	ldd	r31, Y+5	; 0x05
    22ee:	86 89       	ldd	r24, Z+22	; 0x16
    22f0:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4271
                    pxTCB->uxPriority = uxPriorityToUse;
    22f2:	ec 81       	ldd	r30, Y+4	; 0x04
    22f4:	fd 81       	ldd	r31, Y+5	; 0x05
    22f6:	8a 81       	ldd	r24, Y+2	; 0x02
    22f8:	86 8b       	std	Z+22, r24	; 0x16
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4275

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    22fa:	ec 81       	ldd	r30, Y+4	; 0x04
    22fc:	fd 81       	ldd	r31, Y+5	; 0x05
    22fe:	84 85       	ldd	r24, Z+12	; 0x0c
    2300:	95 85       	ldd	r25, Z+13	; 0x0d
    2302:	99 23       	and	r25, r25
    2304:	5c f0       	brlt	.+22     	; 0x231c <vTaskPriorityDisinheritAfterTimeout+0x98>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4277
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2306:	8a 81       	ldd	r24, Y+2	; 0x02
    2308:	28 2f       	mov	r18, r24
    230a:	30 e0       	ldi	r19, 0x00	; 0
    230c:	84 e0       	ldi	r24, 0x04	; 4
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	82 1b       	sub	r24, r18
    2312:	93 0b       	sbc	r25, r19
    2314:	ec 81       	ldd	r30, Y+4	; 0x04
    2316:	fd 81       	ldd	r31, Y+5	; 0x05
    2318:	95 87       	std	Z+13, r25	; 0x0d
    231a:	84 87       	std	Z+12, r24	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4290
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    231c:	ec 81       	ldd	r30, Y+4	; 0x04
    231e:	fd 81       	ldd	r31, Y+5	; 0x05
    2320:	42 85       	ldd	r20, Z+10	; 0x0a
    2322:	53 85       	ldd	r21, Z+11	; 0x0b
    2324:	8b 81       	ldd	r24, Y+3	; 0x03
    2326:	28 2f       	mov	r18, r24
    2328:	30 e0       	ldi	r19, 0x00	; 0
    232a:	c9 01       	movw	r24, r18
    232c:	88 0f       	add	r24, r24
    232e:	99 1f       	adc	r25, r25
    2330:	88 0f       	add	r24, r24
    2332:	99 1f       	adc	r25, r25
    2334:	88 0f       	add	r24, r24
    2336:	99 1f       	adc	r25, r25
    2338:	82 0f       	add	r24, r18
    233a:	93 1f       	adc	r25, r19
    233c:	89 54       	subi	r24, 0x49	; 73
    233e:	9c 4f       	sbci	r25, 0xFC	; 252
    2340:	48 17       	cp	r20, r24
    2342:	59 07       	cpc	r21, r25
    2344:	59 f5       	brne	.+86     	; 0x239c <vTaskPriorityDisinheritAfterTimeout+0x118>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4292
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2346:	8c 81       	ldd	r24, Y+4	; 0x04
    2348:	9d 81       	ldd	r25, Y+5	; 0x05
    234a:	02 96       	adiw	r24, 0x02	; 2
    234c:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4304
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    2350:	ec 81       	ldd	r30, Y+4	; 0x04
    2352:	fd 81       	ldd	r31, Y+5	; 0x05
    2354:	96 89       	ldd	r25, Z+22	; 0x16
    2356:	80 91 ab 03 	lds	r24, 0x03AB
    235a:	89 17       	cp	r24, r25
    235c:	28 f4       	brcc	.+10     	; 0x2368 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    235e:	ec 81       	ldd	r30, Y+4	; 0x04
    2360:	fd 81       	ldd	r31, Y+5	; 0x05
    2362:	86 89       	ldd	r24, Z+22	; 0x16
    2364:	80 93 ab 03 	sts	0x03AB, r24
    2368:	ec 81       	ldd	r30, Y+4	; 0x04
    236a:	fd 81       	ldd	r31, Y+5	; 0x05
    236c:	86 89       	ldd	r24, Z+22	; 0x16
    236e:	28 2f       	mov	r18, r24
    2370:	30 e0       	ldi	r19, 0x00	; 0
    2372:	c9 01       	movw	r24, r18
    2374:	88 0f       	add	r24, r24
    2376:	99 1f       	adc	r25, r25
    2378:	88 0f       	add	r24, r24
    237a:	99 1f       	adc	r25, r25
    237c:	88 0f       	add	r24, r24
    237e:	99 1f       	adc	r25, r25
    2380:	82 0f       	add	r24, r18
    2382:	93 1f       	adc	r25, r19
    2384:	ac 01       	movw	r20, r24
    2386:	49 54       	subi	r20, 0x49	; 73
    2388:	5c 4f       	sbci	r21, 0xFC	; 252
    238a:	8c 81       	ldd	r24, Y+4	; 0x04
    238c:	9d 81       	ldd	r25, Y+5	; 0x05
    238e:	9c 01       	movw	r18, r24
    2390:	2e 5f       	subi	r18, 0xFE	; 254
    2392:	3f 4f       	sbci	r19, 0xFF	; 255
    2394:	ca 01       	movw	r24, r20
    2396:	b9 01       	movw	r22, r18
    2398:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4325
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    239c:	28 96       	adiw	r28, 0x08	; 8
    239e:	0f b6       	in	r0, 0x3f	; 63
    23a0:	f8 94       	cli
    23a2:	de bf       	out	0x3e, r29	; 62
    23a4:	0f be       	out	0x3f, r0	; 63
    23a6:	cd bf       	out	0x3d, r28	; 61
    23a8:	cf 91       	pop	r28
    23aa:	df 91       	pop	r29
    23ac:	08 95       	ret

000023ae <uxTaskResetEventItemValue>:
uxTaskResetEventItemValue():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4652

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    23ae:	df 93       	push	r29
    23b0:	cf 93       	push	r28
    23b2:	00 d0       	rcall	.+0      	; 0x23b4 <uxTaskResetEventItemValue+0x6>
    23b4:	cd b7       	in	r28, 0x3d	; 61
    23b6:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4655
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    23b8:	e0 91 a5 03 	lds	r30, 0x03A5
    23bc:	f0 91 a6 03 	lds	r31, 0x03A6
    23c0:	84 85       	ldd	r24, Z+12	; 0x0c
    23c2:	95 85       	ldd	r25, Z+13	; 0x0d
    23c4:	9a 83       	std	Y+2, r25	; 0x02
    23c6:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4659

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    23c8:	a0 91 a5 03 	lds	r26, 0x03A5
    23cc:	b0 91 a6 03 	lds	r27, 0x03A6
    23d0:	e0 91 a5 03 	lds	r30, 0x03A5
    23d4:	f0 91 a6 03 	lds	r31, 0x03A6
    23d8:	86 89       	ldd	r24, Z+22	; 0x16
    23da:	28 2f       	mov	r18, r24
    23dc:	30 e0       	ldi	r19, 0x00	; 0
    23de:	84 e0       	ldi	r24, 0x04	; 4
    23e0:	90 e0       	ldi	r25, 0x00	; 0
    23e2:	82 1b       	sub	r24, r18
    23e4:	93 0b       	sbc	r25, r19
    23e6:	1d 96       	adiw	r26, 0x0d	; 13
    23e8:	9c 93       	st	X, r25
    23ea:	8e 93       	st	-X, r24
    23ec:	1c 97       	sbiw	r26, 0x0c	; 12
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4661

    return uxReturn;
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4662
}
    23f2:	0f 90       	pop	r0
    23f4:	0f 90       	pop	r0
    23f6:	cf 91       	pop	r28
    23f8:	df 91       	pop	r29
    23fa:	08 95       	ret

000023fc <pvTaskIncrementMutexHeldCount>:
pvTaskIncrementMutexHeldCount():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4668
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
    23fc:	df 93       	push	r29
    23fe:	cf 93       	push	r28
    2400:	cd b7       	in	r28, 0x3d	; 61
    2402:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4671
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    2404:	80 91 a5 03 	lds	r24, 0x03A5
    2408:	90 91 a6 03 	lds	r25, 0x03A6
    240c:	00 97       	sbiw	r24, 0x00	; 0
    240e:	39 f0       	breq	.+14     	; 0x241e <pvTaskIncrementMutexHeldCount+0x22>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4673
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    2410:	e0 91 a5 03 	lds	r30, 0x03A5
    2414:	f0 91 a6 03 	lds	r31, 0x03A6
    2418:	82 a1       	ldd	r24, Z+34	; 0x22
    241a:	8f 5f       	subi	r24, 0xFF	; 255
    241c:	82 a3       	std	Z+34, r24	; 0x22
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4676
        }

        return pxCurrentTCB;
    241e:	80 91 a5 03 	lds	r24, 0x03A5
    2422:	90 91 a6 03 	lds	r25, 0x03A6
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4677
    }
    2426:	cf 91       	pop	r28
    2428:	df 91       	pop	r29
    242a:	08 95       	ret

0000242c <ulTaskGenericNotifyTake>:
ulTaskGenericNotifyTake():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4687
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    242c:	df 93       	push	r29
    242e:	cf 93       	push	r28
    2430:	cd b7       	in	r28, 0x3d	; 61
    2432:	de b7       	in	r29, 0x3e	; 62
    2434:	28 97       	sbiw	r28, 0x08	; 8
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	de bf       	out	0x3e, r29	; 62
    243c:	0f be       	out	0x3f, r0	; 63
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	8d 83       	std	Y+5, r24	; 0x05
    2442:	6e 83       	std	Y+6, r22	; 0x06
    2444:	58 87       	std	Y+8, r21	; 0x08
    2446:	4f 83       	std	Y+7, r20	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4692
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4695
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    244e:	20 91 a5 03 	lds	r18, 0x03A5
    2452:	30 91 a6 03 	lds	r19, 0x03A6
    2456:	8d 81       	ldd	r24, Y+5	; 0x05
    2458:	88 2f       	mov	r24, r24
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	88 0f       	add	r24, r24
    245e:	99 1f       	adc	r25, r25
    2460:	88 0f       	add	r24, r24
    2462:	99 1f       	adc	r25, r25
    2464:	82 0f       	add	r24, r18
    2466:	93 1f       	adc	r25, r19
    2468:	fc 01       	movw	r30, r24
    246a:	b3 96       	adiw	r30, 0x23	; 35
    246c:	80 81       	ld	r24, Z
    246e:	91 81       	ldd	r25, Z+1	; 0x01
    2470:	a2 81       	ldd	r26, Z+2	; 0x02
    2472:	b3 81       	ldd	r27, Z+3	; 0x03
    2474:	00 97       	sbiw	r24, 0x00	; 0
    2476:	a1 05       	cpc	r26, r1
    2478:	b1 05       	cpc	r27, r1
    247a:	c1 f4       	brne	.+48     	; 0x24ac <ulTaskGenericNotifyTake+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4698
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    247c:	20 91 a5 03 	lds	r18, 0x03A5
    2480:	30 91 a6 03 	lds	r19, 0x03A6
    2484:	8d 81       	ldd	r24, Y+5	; 0x05
    2486:	88 2f       	mov	r24, r24
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	82 0f       	add	r24, r18
    248c:	93 1f       	adc	r25, r19
    248e:	fc 01       	movw	r30, r24
    2490:	b7 96       	adiw	r30, 0x27	; 39
    2492:	81 e0       	ldi	r24, 0x01	; 1
    2494:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4700

                if( xTicksToWait > ( TickType_t ) 0 )
    2496:	8f 81       	ldd	r24, Y+7	; 0x07
    2498:	98 85       	ldd	r25, Y+8	; 0x08
    249a:	00 97       	sbiw	r24, 0x00	; 0
    249c:	39 f0       	breq	.+14     	; 0x24ac <ulTaskGenericNotifyTake+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4702
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    249e:	8f 81       	ldd	r24, Y+7	; 0x07
    24a0:	98 85       	ldd	r25, Y+8	; 0x08
    24a2:	61 e0       	ldi	r22, 0x01	; 1
    24a4:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4709

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    24a8:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4721
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    24ac:	0f 90       	pop	r0
    24ae:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4723

        taskENTER_CRITICAL();
    24b0:	0f b6       	in	r0, 0x3f	; 63
    24b2:	f8 94       	cli
    24b4:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4726
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    24b6:	20 91 a5 03 	lds	r18, 0x03A5
    24ba:	30 91 a6 03 	lds	r19, 0x03A6
    24be:	8d 81       	ldd	r24, Y+5	; 0x05
    24c0:	88 2f       	mov	r24, r24
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	88 0f       	add	r24, r24
    24c6:	99 1f       	adc	r25, r25
    24c8:	88 0f       	add	r24, r24
    24ca:	99 1f       	adc	r25, r25
    24cc:	82 0f       	add	r24, r18
    24ce:	93 1f       	adc	r25, r19
    24d0:	fc 01       	movw	r30, r24
    24d2:	b3 96       	adiw	r30, 0x23	; 35
    24d4:	80 81       	ld	r24, Z
    24d6:	91 81       	ldd	r25, Z+1	; 0x01
    24d8:	a2 81       	ldd	r26, Z+2	; 0x02
    24da:	b3 81       	ldd	r27, Z+3	; 0x03
    24dc:	89 83       	std	Y+1, r24	; 0x01
    24de:	9a 83       	std	Y+2, r25	; 0x02
    24e0:	ab 83       	std	Y+3, r26	; 0x03
    24e2:	bc 83       	std	Y+4, r27	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4728

            if( ulReturn != 0UL )
    24e4:	89 81       	ldd	r24, Y+1	; 0x01
    24e6:	9a 81       	ldd	r25, Y+2	; 0x02
    24e8:	ab 81       	ldd	r26, Y+3	; 0x03
    24ea:	bc 81       	ldd	r27, Y+4	; 0x04
    24ec:	00 97       	sbiw	r24, 0x00	; 0
    24ee:	a1 05       	cpc	r26, r1
    24f0:	b1 05       	cpc	r27, r1
    24f2:	a9 f1       	breq	.+106    	; 0x255e <ulTaskGenericNotifyTake+0x132>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4730
            {
                if( xClearCountOnExit != pdFALSE )
    24f4:	8e 81       	ldd	r24, Y+6	; 0x06
    24f6:	88 23       	and	r24, r24
    24f8:	a1 f0       	breq	.+40     	; 0x2522 <ulTaskGenericNotifyTake+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4732
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    24fa:	20 91 a5 03 	lds	r18, 0x03A5
    24fe:	30 91 a6 03 	lds	r19, 0x03A6
    2502:	8d 81       	ldd	r24, Y+5	; 0x05
    2504:	88 2f       	mov	r24, r24
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	88 0f       	add	r24, r24
    250a:	99 1f       	adc	r25, r25
    250c:	88 0f       	add	r24, r24
    250e:	99 1f       	adc	r25, r25
    2510:	82 0f       	add	r24, r18
    2512:	93 1f       	adc	r25, r19
    2514:	fc 01       	movw	r30, r24
    2516:	b3 96       	adiw	r30, 0x23	; 35
    2518:	10 82       	st	Z, r1
    251a:	11 82       	std	Z+1, r1	; 0x01
    251c:	12 82       	std	Z+2, r1	; 0x02
    251e:	13 82       	std	Z+3, r1	; 0x03
    2520:	1e c0       	rjmp	.+60     	; 0x255e <ulTaskGenericNotifyTake+0x132>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4736
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    2522:	e0 91 a5 03 	lds	r30, 0x03A5
    2526:	f0 91 a6 03 	lds	r31, 0x03A6
    252a:	8d 81       	ldd	r24, Y+5	; 0x05
    252c:	68 2f       	mov	r22, r24
    252e:	70 e0       	ldi	r23, 0x00	; 0
    2530:	89 81       	ldd	r24, Y+1	; 0x01
    2532:	9a 81       	ldd	r25, Y+2	; 0x02
    2534:	ab 81       	ldd	r26, Y+3	; 0x03
    2536:	bc 81       	ldd	r27, Y+4	; 0x04
    2538:	9c 01       	movw	r18, r24
    253a:	ad 01       	movw	r20, r26
    253c:	21 50       	subi	r18, 0x01	; 1
    253e:	30 40       	sbci	r19, 0x00	; 0
    2540:	40 40       	sbci	r20, 0x00	; 0
    2542:	50 40       	sbci	r21, 0x00	; 0
    2544:	cb 01       	movw	r24, r22
    2546:	88 0f       	add	r24, r24
    2548:	99 1f       	adc	r25, r25
    254a:	88 0f       	add	r24, r24
    254c:	99 1f       	adc	r25, r25
    254e:	8e 0f       	add	r24, r30
    2550:	9f 1f       	adc	r25, r31
    2552:	fc 01       	movw	r30, r24
    2554:	b3 96       	adiw	r30, 0x23	; 35
    2556:	20 83       	st	Z, r18
    2558:	31 83       	std	Z+1, r19	; 0x01
    255a:	42 83       	std	Z+2, r20	; 0x02
    255c:	53 83       	std	Z+3, r21	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4744
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    255e:	20 91 a5 03 	lds	r18, 0x03A5
    2562:	30 91 a6 03 	lds	r19, 0x03A6
    2566:	8d 81       	ldd	r24, Y+5	; 0x05
    2568:	88 2f       	mov	r24, r24
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	82 0f       	add	r24, r18
    256e:	93 1f       	adc	r25, r19
    2570:	fc 01       	movw	r30, r24
    2572:	b7 96       	adiw	r30, 0x27	; 39
    2574:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4746
        }
        taskEXIT_CRITICAL();
    2576:	0f 90       	pop	r0
    2578:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4748

        return ulReturn;
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	9a 81       	ldd	r25, Y+2	; 0x02
    257e:	ab 81       	ldd	r26, Y+3	; 0x03
    2580:	bc 81       	ldd	r27, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4749
    }
    2582:	bc 01       	movw	r22, r24
    2584:	cd 01       	movw	r24, r26
    2586:	28 96       	adiw	r28, 0x08	; 8
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	de bf       	out	0x3e, r29	; 62
    258e:	0f be       	out	0x3f, r0	; 63
    2590:	cd bf       	out	0x3d, r28	; 61
    2592:	cf 91       	pop	r28
    2594:	df 91       	pop	r29
    2596:	08 95       	ret

00002598 <xTaskGenericNotifyWait>:
xTaskGenericNotifyWait():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4761
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    2598:	cf 92       	push	r12
    259a:	df 92       	push	r13
    259c:	ef 92       	push	r14
    259e:	ff 92       	push	r15
    25a0:	0f 93       	push	r16
    25a2:	1f 93       	push	r17
    25a4:	df 93       	push	r29
    25a6:	cf 93       	push	r28
    25a8:	cd b7       	in	r28, 0x3d	; 61
    25aa:	de b7       	in	r29, 0x3e	; 62
    25ac:	2e 97       	sbiw	r28, 0x0e	; 14
    25ae:	0f b6       	in	r0, 0x3f	; 63
    25b0:	f8 94       	cli
    25b2:	de bf       	out	0x3e, r29	; 62
    25b4:	0f be       	out	0x3f, r0	; 63
    25b6:	cd bf       	out	0x3d, r28	; 61
    25b8:	8a 83       	std	Y+2, r24	; 0x02
    25ba:	4b 83       	std	Y+3, r20	; 0x03
    25bc:	5c 83       	std	Y+4, r21	; 0x04
    25be:	6d 83       	std	Y+5, r22	; 0x05
    25c0:	7e 83       	std	Y+6, r23	; 0x06
    25c2:	0f 83       	std	Y+7, r16	; 0x07
    25c4:	18 87       	std	Y+8, r17	; 0x08
    25c6:	29 87       	std	Y+9, r18	; 0x09
    25c8:	3a 87       	std	Y+10, r19	; 0x0a
    25ca:	fc 86       	std	Y+12, r15	; 0x0c
    25cc:	eb 86       	std	Y+11, r14	; 0x0b
    25ce:	de 86       	std	Y+14, r13	; 0x0e
    25d0:	cd 86       	std	Y+13, r12	; 0x0d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4766
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4769
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    25d8:	20 91 a5 03 	lds	r18, 0x03A5
    25dc:	30 91 a6 03 	lds	r19, 0x03A6
    25e0:	8a 81       	ldd	r24, Y+2	; 0x02
    25e2:	88 2f       	mov	r24, r24
    25e4:	90 e0       	ldi	r25, 0x00	; 0
    25e6:	82 0f       	add	r24, r18
    25e8:	93 1f       	adc	r25, r19
    25ea:	fc 01       	movw	r30, r24
    25ec:	b7 96       	adiw	r30, 0x27	; 39
    25ee:	80 81       	ld	r24, Z
    25f0:	82 30       	cpi	r24, 0x02	; 2
    25f2:	09 f4       	brne	.+2      	; 0x25f6 <xTaskGenericNotifyWait+0x5e>
    25f4:	47 c0       	rjmp	.+142    	; 0x2684 <xTaskGenericNotifyWait+0xec>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4774
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    25f6:	60 91 a5 03 	lds	r22, 0x03A5
    25fa:	70 91 a6 03 	lds	r23, 0x03A6
    25fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2600:	08 2f       	mov	r16, r24
    2602:	10 e0       	ldi	r17, 0x00	; 0
    2604:	8a 81       	ldd	r24, Y+2	; 0x02
    2606:	88 2f       	mov	r24, r24
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	88 0f       	add	r24, r24
    260c:	99 1f       	adc	r25, r25
    260e:	88 0f       	add	r24, r24
    2610:	99 1f       	adc	r25, r25
    2612:	86 0f       	add	r24, r22
    2614:	97 1f       	adc	r25, r23
    2616:	fc 01       	movw	r30, r24
    2618:	b3 96       	adiw	r30, 0x23	; 35
    261a:	20 81       	ld	r18, Z
    261c:	31 81       	ldd	r19, Z+1	; 0x01
    261e:	42 81       	ldd	r20, Z+2	; 0x02
    2620:	53 81       	ldd	r21, Z+3	; 0x03
    2622:	8b 81       	ldd	r24, Y+3	; 0x03
    2624:	9c 81       	ldd	r25, Y+4	; 0x04
    2626:	ad 81       	ldd	r26, Y+5	; 0x05
    2628:	be 81       	ldd	r27, Y+6	; 0x06
    262a:	80 95       	com	r24
    262c:	90 95       	com	r25
    262e:	a0 95       	com	r26
    2630:	b0 95       	com	r27
    2632:	28 23       	and	r18, r24
    2634:	39 23       	and	r19, r25
    2636:	4a 23       	and	r20, r26
    2638:	5b 23       	and	r21, r27
    263a:	c8 01       	movw	r24, r16
    263c:	88 0f       	add	r24, r24
    263e:	99 1f       	adc	r25, r25
    2640:	88 0f       	add	r24, r24
    2642:	99 1f       	adc	r25, r25
    2644:	86 0f       	add	r24, r22
    2646:	97 1f       	adc	r25, r23
    2648:	fc 01       	movw	r30, r24
    264a:	b3 96       	adiw	r30, 0x23	; 35
    264c:	20 83       	st	Z, r18
    264e:	31 83       	std	Z+1, r19	; 0x01
    2650:	42 83       	std	Z+2, r20	; 0x02
    2652:	53 83       	std	Z+3, r21	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4777

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    2654:	20 91 a5 03 	lds	r18, 0x03A5
    2658:	30 91 a6 03 	lds	r19, 0x03A6
    265c:	8a 81       	ldd	r24, Y+2	; 0x02
    265e:	88 2f       	mov	r24, r24
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	82 0f       	add	r24, r18
    2664:	93 1f       	adc	r25, r19
    2666:	fc 01       	movw	r30, r24
    2668:	b7 96       	adiw	r30, 0x27	; 39
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4779

                if( xTicksToWait > ( TickType_t ) 0 )
    266e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2670:	9e 85       	ldd	r25, Y+14	; 0x0e
    2672:	00 97       	sbiw	r24, 0x00	; 0
    2674:	39 f0       	breq	.+14     	; 0x2684 <xTaskGenericNotifyWait+0xec>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4781
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2676:	8d 85       	ldd	r24, Y+13	; 0x0d
    2678:	9e 85       	ldd	r25, Y+14	; 0x0e
    267a:	61 e0       	ldi	r22, 0x01	; 1
    267c:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <prvAddCurrentTaskToDelayedList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4788

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2680:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4800
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2684:	0f 90       	pop	r0
    2686:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4802

        taskENTER_CRITICAL();
    2688:	0f b6       	in	r0, 0x3f	; 63
    268a:	f8 94       	cli
    268c:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4806
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    268e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2690:	9c 85       	ldd	r25, Y+12	; 0x0c
    2692:	00 97       	sbiw	r24, 0x00	; 0
    2694:	c9 f0       	breq	.+50     	; 0x26c8 <xTaskGenericNotifyWait+0x130>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4810
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2696:	20 91 a5 03 	lds	r18, 0x03A5
    269a:	30 91 a6 03 	lds	r19, 0x03A6
    269e:	8a 81       	ldd	r24, Y+2	; 0x02
    26a0:	88 2f       	mov	r24, r24
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	88 0f       	add	r24, r24
    26a6:	99 1f       	adc	r25, r25
    26a8:	88 0f       	add	r24, r24
    26aa:	99 1f       	adc	r25, r25
    26ac:	82 0f       	add	r24, r18
    26ae:	93 1f       	adc	r25, r19
    26b0:	fc 01       	movw	r30, r24
    26b2:	b3 96       	adiw	r30, 0x23	; 35
    26b4:	80 81       	ld	r24, Z
    26b6:	91 81       	ldd	r25, Z+1	; 0x01
    26b8:	a2 81       	ldd	r26, Z+2	; 0x02
    26ba:	b3 81       	ldd	r27, Z+3	; 0x03
    26bc:	eb 85       	ldd	r30, Y+11	; 0x0b
    26be:	fc 85       	ldd	r31, Y+12	; 0x0c
    26c0:	80 83       	st	Z, r24
    26c2:	91 83       	std	Z+1, r25	; 0x01
    26c4:	a2 83       	std	Z+2, r26	; 0x02
    26c6:	b3 83       	std	Z+3, r27	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4817

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    26c8:	20 91 a5 03 	lds	r18, 0x03A5
    26cc:	30 91 a6 03 	lds	r19, 0x03A6
    26d0:	8a 81       	ldd	r24, Y+2	; 0x02
    26d2:	88 2f       	mov	r24, r24
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	82 0f       	add	r24, r18
    26d8:	93 1f       	adc	r25, r19
    26da:	fc 01       	movw	r30, r24
    26dc:	b7 96       	adiw	r30, 0x27	; 39
    26de:	80 81       	ld	r24, Z
    26e0:	82 30       	cpi	r24, 0x02	; 2
    26e2:	11 f0       	breq	.+4      	; 0x26e8 <xTaskGenericNotifyWait+0x150>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4820
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    26e4:	19 82       	std	Y+1, r1	; 0x01
    26e6:	31 c0       	rjmp	.+98     	; 0x274a <xTaskGenericNotifyWait+0x1b2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4826
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    26e8:	60 91 a5 03 	lds	r22, 0x03A5
    26ec:	70 91 a6 03 	lds	r23, 0x03A6
    26f0:	8a 81       	ldd	r24, Y+2	; 0x02
    26f2:	08 2f       	mov	r16, r24
    26f4:	10 e0       	ldi	r17, 0x00	; 0
    26f6:	8a 81       	ldd	r24, Y+2	; 0x02
    26f8:	88 2f       	mov	r24, r24
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	88 0f       	add	r24, r24
    2702:	99 1f       	adc	r25, r25
    2704:	86 0f       	add	r24, r22
    2706:	97 1f       	adc	r25, r23
    2708:	fc 01       	movw	r30, r24
    270a:	b3 96       	adiw	r30, 0x23	; 35
    270c:	20 81       	ld	r18, Z
    270e:	31 81       	ldd	r19, Z+1	; 0x01
    2710:	42 81       	ldd	r20, Z+2	; 0x02
    2712:	53 81       	ldd	r21, Z+3	; 0x03
    2714:	8f 81       	ldd	r24, Y+7	; 0x07
    2716:	98 85       	ldd	r25, Y+8	; 0x08
    2718:	a9 85       	ldd	r26, Y+9	; 0x09
    271a:	ba 85       	ldd	r27, Y+10	; 0x0a
    271c:	80 95       	com	r24
    271e:	90 95       	com	r25
    2720:	a0 95       	com	r26
    2722:	b0 95       	com	r27
    2724:	28 23       	and	r18, r24
    2726:	39 23       	and	r19, r25
    2728:	4a 23       	and	r20, r26
    272a:	5b 23       	and	r21, r27
    272c:	c8 01       	movw	r24, r16
    272e:	88 0f       	add	r24, r24
    2730:	99 1f       	adc	r25, r25
    2732:	88 0f       	add	r24, r24
    2734:	99 1f       	adc	r25, r25
    2736:	86 0f       	add	r24, r22
    2738:	97 1f       	adc	r25, r23
    273a:	fc 01       	movw	r30, r24
    273c:	b3 96       	adiw	r30, 0x23	; 35
    273e:	20 83       	st	Z, r18
    2740:	31 83       	std	Z+1, r19	; 0x01
    2742:	42 83       	std	Z+2, r20	; 0x02
    2744:	53 83       	std	Z+3, r21	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4827
                xReturn = pdTRUE;
    2746:	81 e0       	ldi	r24, 0x01	; 1
    2748:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4830
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    274a:	20 91 a5 03 	lds	r18, 0x03A5
    274e:	30 91 a6 03 	lds	r19, 0x03A6
    2752:	8a 81       	ldd	r24, Y+2	; 0x02
    2754:	88 2f       	mov	r24, r24
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	82 0f       	add	r24, r18
    275a:	93 1f       	adc	r25, r19
    275c:	fc 01       	movw	r30, r24
    275e:	b7 96       	adiw	r30, 0x27	; 39
    2760:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4832
        }
        taskEXIT_CRITICAL();
    2762:	0f 90       	pop	r0
    2764:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4834

        return xReturn;
    2766:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4835
    }
    2768:	2e 96       	adiw	r28, 0x0e	; 14
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	de bf       	out	0x3e, r29	; 62
    2770:	0f be       	out	0x3f, r0	; 63
    2772:	cd bf       	out	0x3d, r28	; 61
    2774:	cf 91       	pop	r28
    2776:	df 91       	pop	r29
    2778:	1f 91       	pop	r17
    277a:	0f 91       	pop	r16
    277c:	ff 90       	pop	r15
    277e:	ef 90       	pop	r14
    2780:	df 90       	pop	r13
    2782:	cf 90       	pop	r12
    2784:	08 95       	ret

00002786 <xTaskGenericNotify>:
xTaskGenericNotify():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4847
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	df 93       	push	r29
    2790:	cf 93       	push	r28
    2792:	cd b7       	in	r28, 0x3d	; 61
    2794:	de b7       	in	r29, 0x3e	; 62
    2796:	60 97       	sbiw	r28, 0x10	; 16
    2798:	0f b6       	in	r0, 0x3f	; 63
    279a:	f8 94       	cli
    279c:	de bf       	out	0x3e, r29	; 62
    279e:	0f be       	out	0x3f, r0	; 63
    27a0:	cd bf       	out	0x3d, r28	; 61
    27a2:	9e 83       	std	Y+6, r25	; 0x06
    27a4:	8d 83       	std	Y+5, r24	; 0x05
    27a6:	6f 83       	std	Y+7, r22	; 0x07
    27a8:	28 87       	std	Y+8, r18	; 0x08
    27aa:	39 87       	std	Y+9, r19	; 0x09
    27ac:	4a 87       	std	Y+10, r20	; 0x0a
    27ae:	5b 87       	std	Y+11, r21	; 0x0b
    27b0:	0c 87       	std	Y+12, r16	; 0x0c
    27b2:	fe 86       	std	Y+14, r15	; 0x0e
    27b4:	ed 86       	std	Y+13, r14	; 0x0d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4849
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4854
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    27ba:	8d 81       	ldd	r24, Y+5	; 0x05
    27bc:	9e 81       	ldd	r25, Y+6	; 0x06
    27be:	9c 83       	std	Y+4, r25	; 0x04
    27c0:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4856

        taskENTER_CRITICAL();
    27c2:	0f b6       	in	r0, 0x3f	; 63
    27c4:	f8 94       	cli
    27c6:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4858
        {
            if( pulPreviousNotificationValue != NULL )
    27c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    27ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    27cc:	00 97       	sbiw	r24, 0x00	; 0
    27ce:	b9 f0       	breq	.+46     	; 0x27fe <xTaskGenericNotify+0x78>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4860
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    27d0:	8f 81       	ldd	r24, Y+7	; 0x07
    27d2:	88 2f       	mov	r24, r24
    27d4:	90 e0       	ldi	r25, 0x00	; 0
    27d6:	2b 81       	ldd	r18, Y+3	; 0x03
    27d8:	3c 81       	ldd	r19, Y+4	; 0x04
    27da:	88 0f       	add	r24, r24
    27dc:	99 1f       	adc	r25, r25
    27de:	88 0f       	add	r24, r24
    27e0:	99 1f       	adc	r25, r25
    27e2:	82 0f       	add	r24, r18
    27e4:	93 1f       	adc	r25, r19
    27e6:	fc 01       	movw	r30, r24
    27e8:	b3 96       	adiw	r30, 0x23	; 35
    27ea:	80 81       	ld	r24, Z
    27ec:	91 81       	ldd	r25, Z+1	; 0x01
    27ee:	a2 81       	ldd	r26, Z+2	; 0x02
    27f0:	b3 81       	ldd	r27, Z+3	; 0x03
    27f2:	ed 85       	ldd	r30, Y+13	; 0x0d
    27f4:	fe 85       	ldd	r31, Y+14	; 0x0e
    27f6:	80 83       	st	Z, r24
    27f8:	91 83       	std	Z+1, r25	; 0x01
    27fa:	a2 83       	std	Z+2, r26	; 0x02
    27fc:	b3 83       	std	Z+3, r27	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4863
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    27fe:	8f 81       	ldd	r24, Y+7	; 0x07
    2800:	28 2f       	mov	r18, r24
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	8b 81       	ldd	r24, Y+3	; 0x03
    2806:	9c 81       	ldd	r25, Y+4	; 0x04
    2808:	82 0f       	add	r24, r18
    280a:	93 1f       	adc	r25, r19
    280c:	fc 01       	movw	r30, r24
    280e:	b7 96       	adiw	r30, 0x27	; 39
    2810:	80 81       	ld	r24, Z
    2812:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4865

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    2814:	8f 81       	ldd	r24, Y+7	; 0x07
    2816:	28 2f       	mov	r18, r24
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	8b 81       	ldd	r24, Y+3	; 0x03
    281c:	9c 81       	ldd	r25, Y+4	; 0x04
    281e:	82 0f       	add	r24, r18
    2820:	93 1f       	adc	r25, r19
    2822:	fc 01       	movw	r30, r24
    2824:	b7 96       	adiw	r30, 0x27	; 39
    2826:	82 e0       	ldi	r24, 0x02	; 2
    2828:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4867

            switch( eAction )
    282a:	8c 85       	ldd	r24, Y+12	; 0x0c
    282c:	28 2f       	mov	r18, r24
    282e:	30 e0       	ldi	r19, 0x00	; 0
    2830:	38 8b       	std	Y+16, r19	; 0x10
    2832:	2f 87       	std	Y+15, r18	; 0x0f
    2834:	8f 85       	ldd	r24, Y+15	; 0x0f
    2836:	98 89       	ldd	r25, Y+16	; 0x10
    2838:	82 30       	cpi	r24, 0x02	; 2
    283a:	91 05       	cpc	r25, r1
    283c:	09 f4       	brne	.+2      	; 0x2840 <xTaskGenericNotify+0xba>
    283e:	46 c0       	rjmp	.+140    	; 0x28cc <xTaskGenericNotify+0x146>
    2840:	2f 85       	ldd	r18, Y+15	; 0x0f
    2842:	38 89       	ldd	r19, Y+16	; 0x10
    2844:	23 30       	cpi	r18, 0x03	; 3
    2846:	31 05       	cpc	r19, r1
    2848:	34 f4       	brge	.+12     	; 0x2856 <xTaskGenericNotify+0xd0>
    284a:	8f 85       	ldd	r24, Y+15	; 0x0f
    284c:	98 89       	ldd	r25, Y+16	; 0x10
    284e:	81 30       	cpi	r24, 0x01	; 1
    2850:	91 05       	cpc	r25, r1
    2852:	71 f0       	breq	.+28     	; 0x2870 <xTaskGenericNotify+0xea>
    2854:	93 c0       	rjmp	.+294    	; 0x297c <xTaskGenericNotify+0x1f6>
    2856:	2f 85       	ldd	r18, Y+15	; 0x0f
    2858:	38 89       	ldd	r19, Y+16	; 0x10
    285a:	23 30       	cpi	r18, 0x03	; 3
    285c:	31 05       	cpc	r19, r1
    285e:	09 f4       	brne	.+2      	; 0x2862 <xTaskGenericNotify+0xdc>
    2860:	5d c0       	rjmp	.+186    	; 0x291c <xTaskGenericNotify+0x196>
    2862:	8f 85       	ldd	r24, Y+15	; 0x0f
    2864:	98 89       	ldd	r25, Y+16	; 0x10
    2866:	84 30       	cpi	r24, 0x04	; 4
    2868:	91 05       	cpc	r25, r1
    286a:	09 f4       	brne	.+2      	; 0x286e <xTaskGenericNotify+0xe8>
    286c:	6d c0       	rjmp	.+218    	; 0x2948 <xTaskGenericNotify+0x1c2>
    286e:	86 c0       	rjmp	.+268    	; 0x297c <xTaskGenericNotify+0x1f6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4870
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    2870:	8f 81       	ldd	r24, Y+7	; 0x07
    2872:	08 2f       	mov	r16, r24
    2874:	10 e0       	ldi	r17, 0x00	; 0
    2876:	8f 81       	ldd	r24, Y+7	; 0x07
    2878:	88 2f       	mov	r24, r24
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	2b 81       	ldd	r18, Y+3	; 0x03
    287e:	3c 81       	ldd	r19, Y+4	; 0x04
    2880:	88 0f       	add	r24, r24
    2882:	99 1f       	adc	r25, r25
    2884:	88 0f       	add	r24, r24
    2886:	99 1f       	adc	r25, r25
    2888:	82 0f       	add	r24, r18
    288a:	93 1f       	adc	r25, r19
    288c:	fc 01       	movw	r30, r24
    288e:	b3 96       	adiw	r30, 0x23	; 35
    2890:	20 81       	ld	r18, Z
    2892:	31 81       	ldd	r19, Z+1	; 0x01
    2894:	42 81       	ldd	r20, Z+2	; 0x02
    2896:	53 81       	ldd	r21, Z+3	; 0x03
    2898:	88 85       	ldd	r24, Y+8	; 0x08
    289a:	99 85       	ldd	r25, Y+9	; 0x09
    289c:	aa 85       	ldd	r26, Y+10	; 0x0a
    289e:	bb 85       	ldd	r27, Y+11	; 0x0b
    28a0:	ba 01       	movw	r22, r20
    28a2:	a9 01       	movw	r20, r18
    28a4:	48 2b       	or	r20, r24
    28a6:	59 2b       	or	r21, r25
    28a8:	6a 2b       	or	r22, r26
    28aa:	7b 2b       	or	r23, r27
    28ac:	2b 81       	ldd	r18, Y+3	; 0x03
    28ae:	3c 81       	ldd	r19, Y+4	; 0x04
    28b0:	c8 01       	movw	r24, r16
    28b2:	88 0f       	add	r24, r24
    28b4:	99 1f       	adc	r25, r25
    28b6:	88 0f       	add	r24, r24
    28b8:	99 1f       	adc	r25, r25
    28ba:	82 0f       	add	r24, r18
    28bc:	93 1f       	adc	r25, r19
    28be:	fc 01       	movw	r30, r24
    28c0:	b3 96       	adiw	r30, 0x23	; 35
    28c2:	40 83       	st	Z, r20
    28c4:	51 83       	std	Z+1, r21	; 0x01
    28c6:	62 83       	std	Z+2, r22	; 0x02
    28c8:	73 83       	std	Z+3, r23	; 0x03
    28ca:	58 c0       	rjmp	.+176    	; 0x297c <xTaskGenericNotify+0x1f6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4874
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    28cc:	8f 81       	ldd	r24, Y+7	; 0x07
    28ce:	08 2f       	mov	r16, r24
    28d0:	10 e0       	ldi	r17, 0x00	; 0
    28d2:	2b 81       	ldd	r18, Y+3	; 0x03
    28d4:	3c 81       	ldd	r19, Y+4	; 0x04
    28d6:	c8 01       	movw	r24, r16
    28d8:	88 0f       	add	r24, r24
    28da:	99 1f       	adc	r25, r25
    28dc:	88 0f       	add	r24, r24
    28de:	99 1f       	adc	r25, r25
    28e0:	82 0f       	add	r24, r18
    28e2:	93 1f       	adc	r25, r19
    28e4:	fc 01       	movw	r30, r24
    28e6:	b3 96       	adiw	r30, 0x23	; 35
    28e8:	80 81       	ld	r24, Z
    28ea:	91 81       	ldd	r25, Z+1	; 0x01
    28ec:	a2 81       	ldd	r26, Z+2	; 0x02
    28ee:	b3 81       	ldd	r27, Z+3	; 0x03
    28f0:	ac 01       	movw	r20, r24
    28f2:	bd 01       	movw	r22, r26
    28f4:	4f 5f       	subi	r20, 0xFF	; 255
    28f6:	5f 4f       	sbci	r21, 0xFF	; 255
    28f8:	6f 4f       	sbci	r22, 0xFF	; 255
    28fa:	7f 4f       	sbci	r23, 0xFF	; 255
    28fc:	2b 81       	ldd	r18, Y+3	; 0x03
    28fe:	3c 81       	ldd	r19, Y+4	; 0x04
    2900:	c8 01       	movw	r24, r16
    2902:	88 0f       	add	r24, r24
    2904:	99 1f       	adc	r25, r25
    2906:	88 0f       	add	r24, r24
    2908:	99 1f       	adc	r25, r25
    290a:	82 0f       	add	r24, r18
    290c:	93 1f       	adc	r25, r19
    290e:	fc 01       	movw	r30, r24
    2910:	b3 96       	adiw	r30, 0x23	; 35
    2912:	40 83       	st	Z, r20
    2914:	51 83       	std	Z+1, r21	; 0x01
    2916:	62 83       	std	Z+2, r22	; 0x02
    2918:	73 83       	std	Z+3, r23	; 0x03
    291a:	30 c0       	rjmp	.+96     	; 0x297c <xTaskGenericNotify+0x1f6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4878
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    291c:	8f 81       	ldd	r24, Y+7	; 0x07
    291e:	88 2f       	mov	r24, r24
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	2b 81       	ldd	r18, Y+3	; 0x03
    2924:	3c 81       	ldd	r19, Y+4	; 0x04
    2926:	88 0f       	add	r24, r24
    2928:	99 1f       	adc	r25, r25
    292a:	88 0f       	add	r24, r24
    292c:	99 1f       	adc	r25, r25
    292e:	82 0f       	add	r24, r18
    2930:	93 1f       	adc	r25, r19
    2932:	fc 01       	movw	r30, r24
    2934:	b3 96       	adiw	r30, 0x23	; 35
    2936:	88 85       	ldd	r24, Y+8	; 0x08
    2938:	99 85       	ldd	r25, Y+9	; 0x09
    293a:	aa 85       	ldd	r26, Y+10	; 0x0a
    293c:	bb 85       	ldd	r27, Y+11	; 0x0b
    293e:	80 83       	st	Z, r24
    2940:	91 83       	std	Z+1, r25	; 0x01
    2942:	a2 83       	std	Z+2, r26	; 0x02
    2944:	b3 83       	std	Z+3, r27	; 0x03
    2946:	1a c0       	rjmp	.+52     	; 0x297c <xTaskGenericNotify+0x1f6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4883
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2948:	89 81       	ldd	r24, Y+1	; 0x01
    294a:	82 30       	cpi	r24, 0x02	; 2
    294c:	b1 f0       	breq	.+44     	; 0x297a <xTaskGenericNotify+0x1f4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4885
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    294e:	8f 81       	ldd	r24, Y+7	; 0x07
    2950:	88 2f       	mov	r24, r24
    2952:	90 e0       	ldi	r25, 0x00	; 0
    2954:	2b 81       	ldd	r18, Y+3	; 0x03
    2956:	3c 81       	ldd	r19, Y+4	; 0x04
    2958:	88 0f       	add	r24, r24
    295a:	99 1f       	adc	r25, r25
    295c:	88 0f       	add	r24, r24
    295e:	99 1f       	adc	r25, r25
    2960:	82 0f       	add	r24, r18
    2962:	93 1f       	adc	r25, r19
    2964:	fc 01       	movw	r30, r24
    2966:	b3 96       	adiw	r30, 0x23	; 35
    2968:	88 85       	ldd	r24, Y+8	; 0x08
    296a:	99 85       	ldd	r25, Y+9	; 0x09
    296c:	aa 85       	ldd	r26, Y+10	; 0x0a
    296e:	bb 85       	ldd	r27, Y+11	; 0x0b
    2970:	80 83       	st	Z, r24
    2972:	91 83       	std	Z+1, r25	; 0x01
    2974:	a2 83       	std	Z+2, r26	; 0x02
    2976:	b3 83       	std	Z+3, r27	; 0x03
    2978:	01 c0       	rjmp	.+2      	; 0x297c <xTaskGenericNotify+0x1f6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4890
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    297a:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4915

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    297c:	89 81       	ldd	r24, Y+1	; 0x01
    297e:	81 30       	cpi	r24, 0x01	; 1
    2980:	b9 f5       	brne	.+110    	; 0x29f0 <xTaskGenericNotify+0x26a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4917
            {
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2982:	8b 81       	ldd	r24, Y+3	; 0x03
    2984:	9c 81       	ldd	r25, Y+4	; 0x04
    2986:	02 96       	adiw	r24, 0x02	; 2
    2988:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4918
                prvAddTaskToReadyList( pxTCB );
    298c:	eb 81       	ldd	r30, Y+3	; 0x03
    298e:	fc 81       	ldd	r31, Y+4	; 0x04
    2990:	96 89       	ldd	r25, Z+22	; 0x16
    2992:	80 91 ab 03 	lds	r24, 0x03AB
    2996:	89 17       	cp	r24, r25
    2998:	28 f4       	brcc	.+10     	; 0x29a4 <xTaskGenericNotify+0x21e>
    299a:	eb 81       	ldd	r30, Y+3	; 0x03
    299c:	fc 81       	ldd	r31, Y+4	; 0x04
    299e:	86 89       	ldd	r24, Z+22	; 0x16
    29a0:	80 93 ab 03 	sts	0x03AB, r24
    29a4:	eb 81       	ldd	r30, Y+3	; 0x03
    29a6:	fc 81       	ldd	r31, Y+4	; 0x04
    29a8:	86 89       	ldd	r24, Z+22	; 0x16
    29aa:	28 2f       	mov	r18, r24
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	c9 01       	movw	r24, r18
    29b0:	88 0f       	add	r24, r24
    29b2:	99 1f       	adc	r25, r25
    29b4:	88 0f       	add	r24, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	88 0f       	add	r24, r24
    29ba:	99 1f       	adc	r25, r25
    29bc:	82 0f       	add	r24, r18
    29be:	93 1f       	adc	r25, r19
    29c0:	ac 01       	movw	r20, r24
    29c2:	49 54       	subi	r20, 0x49	; 73
    29c4:	5c 4f       	sbci	r21, 0xFC	; 252
    29c6:	8b 81       	ldd	r24, Y+3	; 0x03
    29c8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ca:	9c 01       	movw	r18, r24
    29cc:	2e 5f       	subi	r18, 0xFE	; 254
    29ce:	3f 4f       	sbci	r19, 0xFF	; 255
    29d0:	ca 01       	movw	r24, r20
    29d2:	b9 01       	movw	r22, r18
    29d4:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4939
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    29d8:	eb 81       	ldd	r30, Y+3	; 0x03
    29da:	fc 81       	ldd	r31, Y+4	; 0x04
    29dc:	96 89       	ldd	r25, Z+22	; 0x16
    29de:	e0 91 a5 03 	lds	r30, 0x03A5
    29e2:	f0 91 a6 03 	lds	r31, 0x03A6
    29e6:	86 89       	ldd	r24, Z+22	; 0x16
    29e8:	89 17       	cp	r24, r25
    29ea:	10 f4       	brcc	.+4      	; 0x29f0 <xTaskGenericNotify+0x26a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4943
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    29ec:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4955
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    29f0:	0f 90       	pop	r0
    29f2:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4957

        return xReturn;
    29f4:	8a 81       	ldd	r24, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4958
    }
    29f6:	60 96       	adiw	r28, 0x10	; 16
    29f8:	0f b6       	in	r0, 0x3f	; 63
    29fa:	f8 94       	cli
    29fc:	de bf       	out	0x3e, r29	; 62
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	cd bf       	out	0x3d, r28	; 61
    2a02:	cf 91       	pop	r28
    2a04:	df 91       	pop	r29
    2a06:	1f 91       	pop	r17
    2a08:	0f 91       	pop	r16
    2a0a:	ff 90       	pop	r15
    2a0c:	ef 90       	pop	r14
    2a0e:	08 95       	ret

00002a10 <xTaskGenericNotifyFromISR>:
xTaskGenericNotifyFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4971
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    2a10:	cf 92       	push	r12
    2a12:	df 92       	push	r13
    2a14:	ef 92       	push	r14
    2a16:	ff 92       	push	r15
    2a18:	0f 93       	push	r16
    2a1a:	1f 93       	push	r17
    2a1c:	df 93       	push	r29
    2a1e:	cf 93       	push	r28
    2a20:	cd b7       	in	r28, 0x3d	; 61
    2a22:	de b7       	in	r29, 0x3e	; 62
    2a24:	63 97       	sbiw	r28, 0x13	; 19
    2a26:	0f b6       	in	r0, 0x3f	; 63
    2a28:	f8 94       	cli
    2a2a:	de bf       	out	0x3e, r29	; 62
    2a2c:	0f be       	out	0x3f, r0	; 63
    2a2e:	cd bf       	out	0x3d, r28	; 61
    2a30:	9f 83       	std	Y+7, r25	; 0x07
    2a32:	8e 83       	std	Y+6, r24	; 0x06
    2a34:	68 87       	std	Y+8, r22	; 0x08
    2a36:	29 87       	std	Y+9, r18	; 0x09
    2a38:	3a 87       	std	Y+10, r19	; 0x0a
    2a3a:	4b 87       	std	Y+11, r20	; 0x0b
    2a3c:	5c 87       	std	Y+12, r21	; 0x0c
    2a3e:	0d 87       	std	Y+13, r16	; 0x0d
    2a40:	ff 86       	std	Y+15, r15	; 0x0f
    2a42:	ee 86       	std	Y+14, r14	; 0x0e
    2a44:	d9 8a       	std	Y+17, r13	; 0x11
    2a46:	c8 8a       	std	Y+16, r12	; 0x10
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4974
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:4998
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    2a4c:	8e 81       	ldd	r24, Y+6	; 0x06
    2a4e:	9f 81       	ldd	r25, Y+7	; 0x07
    2a50:	9d 83       	std	Y+5, r25	; 0x05
    2a52:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5000

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a54:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5002
        {
            if( pulPreviousNotificationValue != NULL )
    2a56:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a58:	9f 85       	ldd	r25, Y+15	; 0x0f
    2a5a:	00 97       	sbiw	r24, 0x00	; 0
    2a5c:	b9 f0       	breq	.+46     	; 0x2a8c <xTaskGenericNotifyFromISR+0x7c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5004
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    2a5e:	88 85       	ldd	r24, Y+8	; 0x08
    2a60:	88 2f       	mov	r24, r24
    2a62:	90 e0       	ldi	r25, 0x00	; 0
    2a64:	2c 81       	ldd	r18, Y+4	; 0x04
    2a66:	3d 81       	ldd	r19, Y+5	; 0x05
    2a68:	88 0f       	add	r24, r24
    2a6a:	99 1f       	adc	r25, r25
    2a6c:	88 0f       	add	r24, r24
    2a6e:	99 1f       	adc	r25, r25
    2a70:	82 0f       	add	r24, r18
    2a72:	93 1f       	adc	r25, r19
    2a74:	fc 01       	movw	r30, r24
    2a76:	b3 96       	adiw	r30, 0x23	; 35
    2a78:	80 81       	ld	r24, Z
    2a7a:	91 81       	ldd	r25, Z+1	; 0x01
    2a7c:	a2 81       	ldd	r26, Z+2	; 0x02
    2a7e:	b3 81       	ldd	r27, Z+3	; 0x03
    2a80:	ee 85       	ldd	r30, Y+14	; 0x0e
    2a82:	ff 85       	ldd	r31, Y+15	; 0x0f
    2a84:	80 83       	st	Z, r24
    2a86:	91 83       	std	Z+1, r25	; 0x01
    2a88:	a2 83       	std	Z+2, r26	; 0x02
    2a8a:	b3 83       	std	Z+3, r27	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5007
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    2a8c:	88 85       	ldd	r24, Y+8	; 0x08
    2a8e:	28 2f       	mov	r18, r24
    2a90:	30 e0       	ldi	r19, 0x00	; 0
    2a92:	8c 81       	ldd	r24, Y+4	; 0x04
    2a94:	9d 81       	ldd	r25, Y+5	; 0x05
    2a96:	82 0f       	add	r24, r18
    2a98:	93 1f       	adc	r25, r19
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	b7 96       	adiw	r30, 0x27	; 39
    2a9e:	80 81       	ld	r24, Z
    2aa0:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5008
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    2aa2:	88 85       	ldd	r24, Y+8	; 0x08
    2aa4:	28 2f       	mov	r18, r24
    2aa6:	30 e0       	ldi	r19, 0x00	; 0
    2aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    2aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    2aac:	82 0f       	add	r24, r18
    2aae:	93 1f       	adc	r25, r19
    2ab0:	fc 01       	movw	r30, r24
    2ab2:	b7 96       	adiw	r30, 0x27	; 39
    2ab4:	82 e0       	ldi	r24, 0x02	; 2
    2ab6:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5010

            switch( eAction )
    2ab8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2aba:	28 2f       	mov	r18, r24
    2abc:	30 e0       	ldi	r19, 0x00	; 0
    2abe:	3b 8b       	std	Y+19, r19	; 0x13
    2ac0:	2a 8b       	std	Y+18, r18	; 0x12
    2ac2:	8a 89       	ldd	r24, Y+18	; 0x12
    2ac4:	9b 89       	ldd	r25, Y+19	; 0x13
    2ac6:	82 30       	cpi	r24, 0x02	; 2
    2ac8:	91 05       	cpc	r25, r1
    2aca:	09 f4       	brne	.+2      	; 0x2ace <xTaskGenericNotifyFromISR+0xbe>
    2acc:	46 c0       	rjmp	.+140    	; 0x2b5a <xTaskGenericNotifyFromISR+0x14a>
    2ace:	2a 89       	ldd	r18, Y+18	; 0x12
    2ad0:	3b 89       	ldd	r19, Y+19	; 0x13
    2ad2:	23 30       	cpi	r18, 0x03	; 3
    2ad4:	31 05       	cpc	r19, r1
    2ad6:	34 f4       	brge	.+12     	; 0x2ae4 <xTaskGenericNotifyFromISR+0xd4>
    2ad8:	8a 89       	ldd	r24, Y+18	; 0x12
    2ada:	9b 89       	ldd	r25, Y+19	; 0x13
    2adc:	81 30       	cpi	r24, 0x01	; 1
    2ade:	91 05       	cpc	r25, r1
    2ae0:	71 f0       	breq	.+28     	; 0x2afe <xTaskGenericNotifyFromISR+0xee>
    2ae2:	93 c0       	rjmp	.+294    	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
    2ae4:	2a 89       	ldd	r18, Y+18	; 0x12
    2ae6:	3b 89       	ldd	r19, Y+19	; 0x13
    2ae8:	23 30       	cpi	r18, 0x03	; 3
    2aea:	31 05       	cpc	r19, r1
    2aec:	09 f4       	brne	.+2      	; 0x2af0 <xTaskGenericNotifyFromISR+0xe0>
    2aee:	5d c0       	rjmp	.+186    	; 0x2baa <xTaskGenericNotifyFromISR+0x19a>
    2af0:	8a 89       	ldd	r24, Y+18	; 0x12
    2af2:	9b 89       	ldd	r25, Y+19	; 0x13
    2af4:	84 30       	cpi	r24, 0x04	; 4
    2af6:	91 05       	cpc	r25, r1
    2af8:	09 f4       	brne	.+2      	; 0x2afc <xTaskGenericNotifyFromISR+0xec>
    2afa:	6d c0       	rjmp	.+218    	; 0x2bd6 <xTaskGenericNotifyFromISR+0x1c6>
    2afc:	86 c0       	rjmp	.+268    	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5013
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    2afe:	88 85       	ldd	r24, Y+8	; 0x08
    2b00:	08 2f       	mov	r16, r24
    2b02:	10 e0       	ldi	r17, 0x00	; 0
    2b04:	88 85       	ldd	r24, Y+8	; 0x08
    2b06:	88 2f       	mov	r24, r24
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	2c 81       	ldd	r18, Y+4	; 0x04
    2b0c:	3d 81       	ldd	r19, Y+5	; 0x05
    2b0e:	88 0f       	add	r24, r24
    2b10:	99 1f       	adc	r25, r25
    2b12:	88 0f       	add	r24, r24
    2b14:	99 1f       	adc	r25, r25
    2b16:	82 0f       	add	r24, r18
    2b18:	93 1f       	adc	r25, r19
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	b3 96       	adiw	r30, 0x23	; 35
    2b1e:	20 81       	ld	r18, Z
    2b20:	31 81       	ldd	r19, Z+1	; 0x01
    2b22:	42 81       	ldd	r20, Z+2	; 0x02
    2b24:	53 81       	ldd	r21, Z+3	; 0x03
    2b26:	89 85       	ldd	r24, Y+9	; 0x09
    2b28:	9a 85       	ldd	r25, Y+10	; 0x0a
    2b2a:	ab 85       	ldd	r26, Y+11	; 0x0b
    2b2c:	bc 85       	ldd	r27, Y+12	; 0x0c
    2b2e:	ba 01       	movw	r22, r20
    2b30:	a9 01       	movw	r20, r18
    2b32:	48 2b       	or	r20, r24
    2b34:	59 2b       	or	r21, r25
    2b36:	6a 2b       	or	r22, r26
    2b38:	7b 2b       	or	r23, r27
    2b3a:	2c 81       	ldd	r18, Y+4	; 0x04
    2b3c:	3d 81       	ldd	r19, Y+5	; 0x05
    2b3e:	c8 01       	movw	r24, r16
    2b40:	88 0f       	add	r24, r24
    2b42:	99 1f       	adc	r25, r25
    2b44:	88 0f       	add	r24, r24
    2b46:	99 1f       	adc	r25, r25
    2b48:	82 0f       	add	r24, r18
    2b4a:	93 1f       	adc	r25, r19
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	b3 96       	adiw	r30, 0x23	; 35
    2b50:	40 83       	st	Z, r20
    2b52:	51 83       	std	Z+1, r21	; 0x01
    2b54:	62 83       	std	Z+2, r22	; 0x02
    2b56:	73 83       	std	Z+3, r23	; 0x03
    2b58:	58 c0       	rjmp	.+176    	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5017
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    2b5a:	88 85       	ldd	r24, Y+8	; 0x08
    2b5c:	08 2f       	mov	r16, r24
    2b5e:	10 e0       	ldi	r17, 0x00	; 0
    2b60:	2c 81       	ldd	r18, Y+4	; 0x04
    2b62:	3d 81       	ldd	r19, Y+5	; 0x05
    2b64:	c8 01       	movw	r24, r16
    2b66:	88 0f       	add	r24, r24
    2b68:	99 1f       	adc	r25, r25
    2b6a:	88 0f       	add	r24, r24
    2b6c:	99 1f       	adc	r25, r25
    2b6e:	82 0f       	add	r24, r18
    2b70:	93 1f       	adc	r25, r19
    2b72:	fc 01       	movw	r30, r24
    2b74:	b3 96       	adiw	r30, 0x23	; 35
    2b76:	80 81       	ld	r24, Z
    2b78:	91 81       	ldd	r25, Z+1	; 0x01
    2b7a:	a2 81       	ldd	r26, Z+2	; 0x02
    2b7c:	b3 81       	ldd	r27, Z+3	; 0x03
    2b7e:	ac 01       	movw	r20, r24
    2b80:	bd 01       	movw	r22, r26
    2b82:	4f 5f       	subi	r20, 0xFF	; 255
    2b84:	5f 4f       	sbci	r21, 0xFF	; 255
    2b86:	6f 4f       	sbci	r22, 0xFF	; 255
    2b88:	7f 4f       	sbci	r23, 0xFF	; 255
    2b8a:	2c 81       	ldd	r18, Y+4	; 0x04
    2b8c:	3d 81       	ldd	r19, Y+5	; 0x05
    2b8e:	c8 01       	movw	r24, r16
    2b90:	88 0f       	add	r24, r24
    2b92:	99 1f       	adc	r25, r25
    2b94:	88 0f       	add	r24, r24
    2b96:	99 1f       	adc	r25, r25
    2b98:	82 0f       	add	r24, r18
    2b9a:	93 1f       	adc	r25, r19
    2b9c:	fc 01       	movw	r30, r24
    2b9e:	b3 96       	adiw	r30, 0x23	; 35
    2ba0:	40 83       	st	Z, r20
    2ba2:	51 83       	std	Z+1, r21	; 0x01
    2ba4:	62 83       	std	Z+2, r22	; 0x02
    2ba6:	73 83       	std	Z+3, r23	; 0x03
    2ba8:	30 c0       	rjmp	.+96     	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5021
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    2baa:	88 85       	ldd	r24, Y+8	; 0x08
    2bac:	88 2f       	mov	r24, r24
    2bae:	90 e0       	ldi	r25, 0x00	; 0
    2bb0:	2c 81       	ldd	r18, Y+4	; 0x04
    2bb2:	3d 81       	ldd	r19, Y+5	; 0x05
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	88 0f       	add	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	82 0f       	add	r24, r18
    2bbe:	93 1f       	adc	r25, r19
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	b3 96       	adiw	r30, 0x23	; 35
    2bc4:	89 85       	ldd	r24, Y+9	; 0x09
    2bc6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bc8:	ab 85       	ldd	r26, Y+11	; 0x0b
    2bca:	bc 85       	ldd	r27, Y+12	; 0x0c
    2bcc:	80 83       	st	Z, r24
    2bce:	91 83       	std	Z+1, r25	; 0x01
    2bd0:	a2 83       	std	Z+2, r26	; 0x02
    2bd2:	b3 83       	std	Z+3, r27	; 0x03
    2bd4:	1a c0       	rjmp	.+52     	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5026
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd8:	82 30       	cpi	r24, 0x02	; 2
    2bda:	b1 f0       	breq	.+44     	; 0x2c08 <xTaskGenericNotifyFromISR+0x1f8>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5028
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    2bdc:	88 85       	ldd	r24, Y+8	; 0x08
    2bde:	88 2f       	mov	r24, r24
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	2c 81       	ldd	r18, Y+4	; 0x04
    2be4:	3d 81       	ldd	r19, Y+5	; 0x05
    2be6:	88 0f       	add	r24, r24
    2be8:	99 1f       	adc	r25, r25
    2bea:	88 0f       	add	r24, r24
    2bec:	99 1f       	adc	r25, r25
    2bee:	82 0f       	add	r24, r18
    2bf0:	93 1f       	adc	r25, r19
    2bf2:	fc 01       	movw	r30, r24
    2bf4:	b3 96       	adiw	r30, 0x23	; 35
    2bf6:	89 85       	ldd	r24, Y+9	; 0x09
    2bf8:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bfa:	ab 85       	ldd	r26, Y+11	; 0x0b
    2bfc:	bc 85       	ldd	r27, Y+12	; 0x0c
    2bfe:	80 83       	st	Z, r24
    2c00:	91 83       	std	Z+1, r25	; 0x01
    2c02:	a2 83       	std	Z+2, r26	; 0x02
    2c04:	b3 83       	std	Z+3, r27	; 0x03
    2c06:	01 c0       	rjmp	.+2      	; 0x2c0a <xTaskGenericNotifyFromISR+0x1fa>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5033
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    2c08:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5057

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0c:	81 30       	cpi	r24, 0x01	; 1
    2c0e:	09 f0       	breq	.+2      	; 0x2c12 <xTaskGenericNotifyFromISR+0x202>
    2c10:	4f c0       	rjmp	.+158    	; 0x2cb0 <xTaskGenericNotifyFromISR+0x2a0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5062
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c12:	80 91 b6 03 	lds	r24, 0x03B6
    2c16:	88 23       	and	r24, r24
    2c18:	61 f5       	brne	.+88     	; 0x2c72 <xTaskGenericNotifyFromISR+0x262>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5064
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c1e:	02 96       	adiw	r24, 0x02	; 2
    2c20:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5065
                    prvAddTaskToReadyList( pxTCB );
    2c24:	ec 81       	ldd	r30, Y+4	; 0x04
    2c26:	fd 81       	ldd	r31, Y+5	; 0x05
    2c28:	96 89       	ldd	r25, Z+22	; 0x16
    2c2a:	80 91 ab 03 	lds	r24, 0x03AB
    2c2e:	89 17       	cp	r24, r25
    2c30:	28 f4       	brcc	.+10     	; 0x2c3c <xTaskGenericNotifyFromISR+0x22c>
    2c32:	ec 81       	ldd	r30, Y+4	; 0x04
    2c34:	fd 81       	ldd	r31, Y+5	; 0x05
    2c36:	86 89       	ldd	r24, Z+22	; 0x16
    2c38:	80 93 ab 03 	sts	0x03AB, r24
    2c3c:	ec 81       	ldd	r30, Y+4	; 0x04
    2c3e:	fd 81       	ldd	r31, Y+5	; 0x05
    2c40:	86 89       	ldd	r24, Z+22	; 0x16
    2c42:	28 2f       	mov	r18, r24
    2c44:	30 e0       	ldi	r19, 0x00	; 0
    2c46:	c9 01       	movw	r24, r18
    2c48:	88 0f       	add	r24, r24
    2c4a:	99 1f       	adc	r25, r25
    2c4c:	88 0f       	add	r24, r24
    2c4e:	99 1f       	adc	r25, r25
    2c50:	88 0f       	add	r24, r24
    2c52:	99 1f       	adc	r25, r25
    2c54:	82 0f       	add	r24, r18
    2c56:	93 1f       	adc	r25, r19
    2c58:	ac 01       	movw	r20, r24
    2c5a:	49 54       	subi	r20, 0x49	; 73
    2c5c:	5c 4f       	sbci	r21, 0xFC	; 252
    2c5e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c60:	9d 81       	ldd	r25, Y+5	; 0x05
    2c62:	9c 01       	movw	r18, r24
    2c64:	2e 5f       	subi	r18, 0xFE	; 254
    2c66:	3f 4f       	sbci	r19, 0xFF	; 255
    2c68:	ca 01       	movw	r24, r20
    2c6a:	b9 01       	movw	r22, r18
    2c6c:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
    2c70:	0a c0       	rjmp	.+20     	; 0x2c86 <xTaskGenericNotifyFromISR+0x276>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5071
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2c72:	8c 81       	ldd	r24, Y+4	; 0x04
    2c74:	9d 81       	ldd	r25, Y+5	; 0x05
    2c76:	9c 01       	movw	r18, r24
    2c78:	24 5f       	subi	r18, 0xF4	; 244
    2c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c7c:	81 ef       	ldi	r24, 0xF1	; 241
    2c7e:	93 e0       	ldi	r25, 0x03	; 3
    2c80:	b9 01       	movw	r22, r18
    2c82:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5074
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2c86:	ec 81       	ldd	r30, Y+4	; 0x04
    2c88:	fd 81       	ldd	r31, Y+5	; 0x05
    2c8a:	96 89       	ldd	r25, Z+22	; 0x16
    2c8c:	e0 91 a5 03 	lds	r30, 0x03A5
    2c90:	f0 91 a6 03 	lds	r31, 0x03A6
    2c94:	86 89       	ldd	r24, Z+22	; 0x16
    2c96:	89 17       	cp	r24, r25
    2c98:	58 f4       	brcc	.+22     	; 0x2cb0 <xTaskGenericNotifyFromISR+0x2a0>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5078
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    2c9a:	88 89       	ldd	r24, Y+16	; 0x10
    2c9c:	99 89       	ldd	r25, Y+17	; 0x11
    2c9e:	00 97       	sbiw	r24, 0x00	; 0
    2ca0:	21 f0       	breq	.+8      	; 0x2caa <xTaskGenericNotifyFromISR+0x29a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5080
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    2ca2:	e8 89       	ldd	r30, Y+16	; 0x10
    2ca4:	f9 89       	ldd	r31, Y+17	; 0x11
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5086
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    2caa:	81 e0       	ldi	r24, 0x01	; 1
    2cac:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5096
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    2cb0:	8a 81       	ldd	r24, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5097
    }
    2cb2:	63 96       	adiw	r28, 0x13	; 19
    2cb4:	0f b6       	in	r0, 0x3f	; 63
    2cb6:	f8 94       	cli
    2cb8:	de bf       	out	0x3e, r29	; 62
    2cba:	0f be       	out	0x3f, r0	; 63
    2cbc:	cd bf       	out	0x3d, r28	; 61
    2cbe:	cf 91       	pop	r28
    2cc0:	df 91       	pop	r29
    2cc2:	1f 91       	pop	r17
    2cc4:	0f 91       	pop	r16
    2cc6:	ff 90       	pop	r15
    2cc8:	ef 90       	pop	r14
    2cca:	df 90       	pop	r13
    2ccc:	cf 90       	pop	r12
    2cce:	08 95       	ret

00002cd0 <vTaskGenericNotifyGiveFromISR>:
vTaskGenericNotifyGiveFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5107
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    2cd0:	0f 93       	push	r16
    2cd2:	1f 93       	push	r17
    2cd4:	df 93       	push	r29
    2cd6:	cf 93       	push	r28
    2cd8:	cd b7       	in	r28, 0x3d	; 61
    2cda:	de b7       	in	r29, 0x3e	; 62
    2cdc:	29 97       	sbiw	r28, 0x09	; 9
    2cde:	0f b6       	in	r0, 0x3f	; 63
    2ce0:	f8 94       	cli
    2ce2:	de bf       	out	0x3e, r29	; 62
    2ce4:	0f be       	out	0x3f, r0	; 63
    2ce6:	cd bf       	out	0x3d, r28	; 61
    2ce8:	9e 83       	std	Y+6, r25	; 0x06
    2cea:	8d 83       	std	Y+5, r24	; 0x05
    2cec:	6f 83       	std	Y+7, r22	; 0x07
    2cee:	59 87       	std	Y+9, r21	; 0x09
    2cf0:	48 87       	std	Y+8, r20	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5133
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    2cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    2cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    2cf6:	9c 83       	std	Y+4, r25	; 0x04
    2cf8:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5135

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2cfa:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5137
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    2cfc:	8f 81       	ldd	r24, Y+7	; 0x07
    2cfe:	28 2f       	mov	r18, r24
    2d00:	30 e0       	ldi	r19, 0x00	; 0
    2d02:	8b 81       	ldd	r24, Y+3	; 0x03
    2d04:	9c 81       	ldd	r25, Y+4	; 0x04
    2d06:	82 0f       	add	r24, r18
    2d08:	93 1f       	adc	r25, r19
    2d0a:	fc 01       	movw	r30, r24
    2d0c:	b7 96       	adiw	r30, 0x27	; 39
    2d0e:	80 81       	ld	r24, Z
    2d10:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5138
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    2d12:	8f 81       	ldd	r24, Y+7	; 0x07
    2d14:	28 2f       	mov	r18, r24
    2d16:	30 e0       	ldi	r19, 0x00	; 0
    2d18:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1c:	82 0f       	add	r24, r18
    2d1e:	93 1f       	adc	r25, r19
    2d20:	fc 01       	movw	r30, r24
    2d22:	b7 96       	adiw	r30, 0x27	; 39
    2d24:	82 e0       	ldi	r24, 0x02	; 2
    2d26:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5142

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    2d28:	8f 81       	ldd	r24, Y+7	; 0x07
    2d2a:	08 2f       	mov	r16, r24
    2d2c:	10 e0       	ldi	r17, 0x00	; 0
    2d2e:	2b 81       	ldd	r18, Y+3	; 0x03
    2d30:	3c 81       	ldd	r19, Y+4	; 0x04
    2d32:	c8 01       	movw	r24, r16
    2d34:	88 0f       	add	r24, r24
    2d36:	99 1f       	adc	r25, r25
    2d38:	88 0f       	add	r24, r24
    2d3a:	99 1f       	adc	r25, r25
    2d3c:	82 0f       	add	r24, r18
    2d3e:	93 1f       	adc	r25, r19
    2d40:	fc 01       	movw	r30, r24
    2d42:	b3 96       	adiw	r30, 0x23	; 35
    2d44:	80 81       	ld	r24, Z
    2d46:	91 81       	ldd	r25, Z+1	; 0x01
    2d48:	a2 81       	ldd	r26, Z+2	; 0x02
    2d4a:	b3 81       	ldd	r27, Z+3	; 0x03
    2d4c:	ac 01       	movw	r20, r24
    2d4e:	bd 01       	movw	r22, r26
    2d50:	4f 5f       	subi	r20, 0xFF	; 255
    2d52:	5f 4f       	sbci	r21, 0xFF	; 255
    2d54:	6f 4f       	sbci	r22, 0xFF	; 255
    2d56:	7f 4f       	sbci	r23, 0xFF	; 255
    2d58:	2b 81       	ldd	r18, Y+3	; 0x03
    2d5a:	3c 81       	ldd	r19, Y+4	; 0x04
    2d5c:	c8 01       	movw	r24, r16
    2d5e:	88 0f       	add	r24, r24
    2d60:	99 1f       	adc	r25, r25
    2d62:	88 0f       	add	r24, r24
    2d64:	99 1f       	adc	r25, r25
    2d66:	82 0f       	add	r24, r18
    2d68:	93 1f       	adc	r25, r19
    2d6a:	fc 01       	movw	r30, r24
    2d6c:	b3 96       	adiw	r30, 0x23	; 35
    2d6e:	40 83       	st	Z, r20
    2d70:	51 83       	std	Z+1, r21	; 0x01
    2d72:	62 83       	std	Z+2, r22	; 0x02
    2d74:	73 83       	std	Z+3, r23	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5148

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2d76:	8a 81       	ldd	r24, Y+2	; 0x02
    2d78:	81 30       	cpi	r24, 0x01	; 1
    2d7a:	09 f0       	breq	.+2      	; 0x2d7e <vTaskGenericNotifyGiveFromISR+0xae>
    2d7c:	4f c0       	rjmp	.+158    	; 0x2e1c <vTaskGenericNotifyGiveFromISR+0x14c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5153
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d7e:	80 91 b6 03 	lds	r24, 0x03B6
    2d82:	88 23       	and	r24, r24
    2d84:	61 f5       	brne	.+88     	; 0x2dde <vTaskGenericNotifyGiveFromISR+0x10e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5155
                {
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2d86:	8b 81       	ldd	r24, Y+3	; 0x03
    2d88:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8a:	02 96       	adiw	r24, 0x02	; 2
    2d8c:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5156
                    prvAddTaskToReadyList( pxTCB );
    2d90:	eb 81       	ldd	r30, Y+3	; 0x03
    2d92:	fc 81       	ldd	r31, Y+4	; 0x04
    2d94:	96 89       	ldd	r25, Z+22	; 0x16
    2d96:	80 91 ab 03 	lds	r24, 0x03AB
    2d9a:	89 17       	cp	r24, r25
    2d9c:	28 f4       	brcc	.+10     	; 0x2da8 <vTaskGenericNotifyGiveFromISR+0xd8>
    2d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2da0:	fc 81       	ldd	r31, Y+4	; 0x04
    2da2:	86 89       	ldd	r24, Z+22	; 0x16
    2da4:	80 93 ab 03 	sts	0x03AB, r24
    2da8:	eb 81       	ldd	r30, Y+3	; 0x03
    2daa:	fc 81       	ldd	r31, Y+4	; 0x04
    2dac:	86 89       	ldd	r24, Z+22	; 0x16
    2dae:	28 2f       	mov	r18, r24
    2db0:	30 e0       	ldi	r19, 0x00	; 0
    2db2:	c9 01       	movw	r24, r18
    2db4:	88 0f       	add	r24, r24
    2db6:	99 1f       	adc	r25, r25
    2db8:	88 0f       	add	r24, r24
    2dba:	99 1f       	adc	r25, r25
    2dbc:	88 0f       	add	r24, r24
    2dbe:	99 1f       	adc	r25, r25
    2dc0:	82 0f       	add	r24, r18
    2dc2:	93 1f       	adc	r25, r19
    2dc4:	ac 01       	movw	r20, r24
    2dc6:	49 54       	subi	r20, 0x49	; 73
    2dc8:	5c 4f       	sbci	r21, 0xFC	; 252
    2dca:	8b 81       	ldd	r24, Y+3	; 0x03
    2dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dce:	9c 01       	movw	r18, r24
    2dd0:	2e 5f       	subi	r18, 0xFE	; 254
    2dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    2dd4:	ca 01       	movw	r24, r20
    2dd6:	b9 01       	movw	r22, r18
    2dd8:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
    2ddc:	0a c0       	rjmp	.+20     	; 0x2df2 <vTaskGenericNotifyGiveFromISR+0x122>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5162
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2dde:	8b 81       	ldd	r24, Y+3	; 0x03
    2de0:	9c 81       	ldd	r25, Y+4	; 0x04
    2de2:	9c 01       	movw	r18, r24
    2de4:	24 5f       	subi	r18, 0xF4	; 244
    2de6:	3f 4f       	sbci	r19, 0xFF	; 255
    2de8:	81 ef       	ldi	r24, 0xF1	; 241
    2dea:	93 e0       	ldi	r25, 0x03	; 3
    2dec:	b9 01       	movw	r22, r18
    2dee:	0e 94 3e 20 	call	0x407c	; 0x407c <vListInsertEnd>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5165
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2df2:	eb 81       	ldd	r30, Y+3	; 0x03
    2df4:	fc 81       	ldd	r31, Y+4	; 0x04
    2df6:	96 89       	ldd	r25, Z+22	; 0x16
    2df8:	e0 91 a5 03 	lds	r30, 0x03A5
    2dfc:	f0 91 a6 03 	lds	r31, 0x03A6
    2e00:	86 89       	ldd	r24, Z+22	; 0x16
    2e02:	89 17       	cp	r24, r25
    2e04:	58 f4       	brcc	.+22     	; 0x2e1c <vTaskGenericNotifyGiveFromISR+0x14c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5169
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    2e06:	88 85       	ldd	r24, Y+8	; 0x08
    2e08:	99 85       	ldd	r25, Y+9	; 0x09
    2e0a:	00 97       	sbiw	r24, 0x00	; 0
    2e0c:	21 f0       	breq	.+8      	; 0x2e16 <vTaskGenericNotifyGiveFromISR+0x146>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5171
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    2e0e:	e8 85       	ldd	r30, Y+8	; 0x08
    2e10:	f9 85       	ldd	r31, Y+9	; 0x09
    2e12:	81 e0       	ldi	r24, 0x01	; 1
    2e14:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5177
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    2e16:	81 e0       	ldi	r24, 0x01	; 1
    2e18:	80 93 af 03 	sts	0x03AF, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5186
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    2e1c:	29 96       	adiw	r28, 0x09	; 9
    2e1e:	0f b6       	in	r0, 0x3f	; 63
    2e20:	f8 94       	cli
    2e22:	de bf       	out	0x3e, r29	; 62
    2e24:	0f be       	out	0x3f, r0	; 63
    2e26:	cd bf       	out	0x3d, r28	; 61
    2e28:	cf 91       	pop	r28
    2e2a:	df 91       	pop	r29
    2e2c:	1f 91       	pop	r17
    2e2e:	0f 91       	pop	r16
    2e30:	08 95       	ret

00002e32 <xTaskGenericNotifyStateClear>:
xTaskGenericNotifyStateClear():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5195

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    2e32:	df 93       	push	r29
    2e34:	cf 93       	push	r28
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	28 97       	sbiw	r28, 0x08	; 8
    2e3c:	0f b6       	in	r0, 0x3f	; 63
    2e3e:	f8 94       	cli
    2e40:	de bf       	out	0x3e, r29	; 62
    2e42:	0f be       	out	0x3f, r0	; 63
    2e44:	cd bf       	out	0x3d, r28	; 61
    2e46:	9d 83       	std	Y+5, r25	; 0x05
    2e48:	8c 83       	std	Y+4, r24	; 0x04
    2e4a:	6e 83       	std	Y+6, r22	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5203

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    2e4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e4e:	9d 81       	ldd	r25, Y+5	; 0x05
    2e50:	00 97       	sbiw	r24, 0x00	; 0
    2e52:	39 f4       	brne	.+14     	; 0x2e62 <xTaskGenericNotifyStateClear+0x30>
    2e54:	80 91 a5 03 	lds	r24, 0x03A5
    2e58:	90 91 a6 03 	lds	r25, 0x03A6
    2e5c:	98 87       	std	Y+8, r25	; 0x08
    2e5e:	8f 83       	std	Y+7, r24	; 0x07
    2e60:	04 c0       	rjmp	.+8      	; 0x2e6a <xTaskGenericNotifyStateClear+0x38>
    2e62:	8c 81       	ldd	r24, Y+4	; 0x04
    2e64:	9d 81       	ldd	r25, Y+5	; 0x05
    2e66:	98 87       	std	Y+8, r25	; 0x08
    2e68:	8f 83       	std	Y+7, r24	; 0x07
    2e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    2e6c:	98 85       	ldd	r25, Y+8	; 0x08
    2e6e:	9b 83       	std	Y+3, r25	; 0x03
    2e70:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5205

        taskENTER_CRITICAL();
    2e72:	0f b6       	in	r0, 0x3f	; 63
    2e74:	f8 94       	cli
    2e76:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5207
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    2e78:	8e 81       	ldd	r24, Y+6	; 0x06
    2e7a:	28 2f       	mov	r18, r24
    2e7c:	30 e0       	ldi	r19, 0x00	; 0
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	9b 81       	ldd	r25, Y+3	; 0x03
    2e82:	82 0f       	add	r24, r18
    2e84:	93 1f       	adc	r25, r19
    2e86:	fc 01       	movw	r30, r24
    2e88:	b7 96       	adiw	r30, 0x27	; 39
    2e8a:	80 81       	ld	r24, Z
    2e8c:	82 30       	cpi	r24, 0x02	; 2
    2e8e:	69 f4       	brne	.+26     	; 0x2eaa <xTaskGenericNotifyStateClear+0x78>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5209
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    2e90:	8e 81       	ldd	r24, Y+6	; 0x06
    2e92:	28 2f       	mov	r18, r24
    2e94:	30 e0       	ldi	r19, 0x00	; 0
    2e96:	8a 81       	ldd	r24, Y+2	; 0x02
    2e98:	9b 81       	ldd	r25, Y+3	; 0x03
    2e9a:	82 0f       	add	r24, r18
    2e9c:	93 1f       	adc	r25, r19
    2e9e:	fc 01       	movw	r30, r24
    2ea0:	b7 96       	adiw	r30, 0x27	; 39
    2ea2:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5210
                xReturn = pdPASS;
    2ea4:	81 e0       	ldi	r24, 0x01	; 1
    2ea6:	89 83       	std	Y+1, r24	; 0x01
    2ea8:	01 c0       	rjmp	.+2      	; 0x2eac <xTaskGenericNotifyStateClear+0x7a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5214
            }
            else
            {
                xReturn = pdFAIL;
    2eaa:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5217
            }
        }
        taskEXIT_CRITICAL();
    2eac:	0f 90       	pop	r0
    2eae:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5219

        return xReturn;
    2eb0:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5220
    }
    2eb2:	28 96       	adiw	r28, 0x08	; 8
    2eb4:	0f b6       	in	r0, 0x3f	; 63
    2eb6:	f8 94       	cli
    2eb8:	de bf       	out	0x3e, r29	; 62
    2eba:	0f be       	out	0x3f, r0	; 63
    2ebc:	cd bf       	out	0x3d, r28	; 61
    2ebe:	cf 91       	pop	r28
    2ec0:	df 91       	pop	r29
    2ec2:	08 95       	ret

00002ec4 <ulTaskGenericNotifyValueClear>:
ulTaskGenericNotifyValueClear():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5230
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    2ec4:	0f 93       	push	r16
    2ec6:	1f 93       	push	r17
    2ec8:	df 93       	push	r29
    2eca:	cf 93       	push	r28
    2ecc:	cd b7       	in	r28, 0x3d	; 61
    2ece:	de b7       	in	r29, 0x3e	; 62
    2ed0:	2f 97       	sbiw	r28, 0x0f	; 15
    2ed2:	0f b6       	in	r0, 0x3f	; 63
    2ed4:	f8 94       	cli
    2ed6:	de bf       	out	0x3e, r29	; 62
    2ed8:	0f be       	out	0x3f, r0	; 63
    2eda:	cd bf       	out	0x3d, r28	; 61
    2edc:	98 87       	std	Y+8, r25	; 0x08
    2ede:	8f 83       	std	Y+7, r24	; 0x07
    2ee0:	69 87       	std	Y+9, r22	; 0x09
    2ee2:	2a 87       	std	Y+10, r18	; 0x0a
    2ee4:	3b 87       	std	Y+11, r19	; 0x0b
    2ee6:	4c 87       	std	Y+12, r20	; 0x0c
    2ee8:	5d 87       	std	Y+13, r21	; 0x0d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5236
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    2eea:	8f 81       	ldd	r24, Y+7	; 0x07
    2eec:	98 85       	ldd	r25, Y+8	; 0x08
    2eee:	00 97       	sbiw	r24, 0x00	; 0
    2ef0:	39 f4       	brne	.+14     	; 0x2f00 <ulTaskGenericNotifyValueClear+0x3c>
    2ef2:	80 91 a5 03 	lds	r24, 0x03A5
    2ef6:	90 91 a6 03 	lds	r25, 0x03A6
    2efa:	9f 87       	std	Y+15, r25	; 0x0f
    2efc:	8e 87       	std	Y+14, r24	; 0x0e
    2efe:	04 c0       	rjmp	.+8      	; 0x2f08 <ulTaskGenericNotifyValueClear+0x44>
    2f00:	8f 81       	ldd	r24, Y+7	; 0x07
    2f02:	98 85       	ldd	r25, Y+8	; 0x08
    2f04:	9f 87       	std	Y+15, r25	; 0x0f
    2f06:	8e 87       	std	Y+14, r24	; 0x0e
    2f08:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f0a:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f0c:	9e 83       	std	Y+6, r25	; 0x06
    2f0e:	8d 83       	std	Y+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5238

        taskENTER_CRITICAL();
    2f10:	0f b6       	in	r0, 0x3f	; 63
    2f12:	f8 94       	cli
    2f14:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5242
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    2f16:	89 85       	ldd	r24, Y+9	; 0x09
    2f18:	88 2f       	mov	r24, r24
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f1e:	3e 81       	ldd	r19, Y+6	; 0x06
    2f20:	88 0f       	add	r24, r24
    2f22:	99 1f       	adc	r25, r25
    2f24:	88 0f       	add	r24, r24
    2f26:	99 1f       	adc	r25, r25
    2f28:	82 0f       	add	r24, r18
    2f2a:	93 1f       	adc	r25, r19
    2f2c:	fc 01       	movw	r30, r24
    2f2e:	b3 96       	adiw	r30, 0x23	; 35
    2f30:	80 81       	ld	r24, Z
    2f32:	91 81       	ldd	r25, Z+1	; 0x01
    2f34:	a2 81       	ldd	r26, Z+2	; 0x02
    2f36:	b3 81       	ldd	r27, Z+3	; 0x03
    2f38:	89 83       	std	Y+1, r24	; 0x01
    2f3a:	9a 83       	std	Y+2, r25	; 0x02
    2f3c:	ab 83       	std	Y+3, r26	; 0x03
    2f3e:	bc 83       	std	Y+4, r27	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5243
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    2f40:	89 85       	ldd	r24, Y+9	; 0x09
    2f42:	08 2f       	mov	r16, r24
    2f44:	10 e0       	ldi	r17, 0x00	; 0
    2f46:	89 85       	ldd	r24, Y+9	; 0x09
    2f48:	88 2f       	mov	r24, r24
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f4e:	3e 81       	ldd	r19, Y+6	; 0x06
    2f50:	88 0f       	add	r24, r24
    2f52:	99 1f       	adc	r25, r25
    2f54:	88 0f       	add	r24, r24
    2f56:	99 1f       	adc	r25, r25
    2f58:	82 0f       	add	r24, r18
    2f5a:	93 1f       	adc	r25, r19
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	b3 96       	adiw	r30, 0x23	; 35
    2f60:	20 81       	ld	r18, Z
    2f62:	31 81       	ldd	r19, Z+1	; 0x01
    2f64:	42 81       	ldd	r20, Z+2	; 0x02
    2f66:	53 81       	ldd	r21, Z+3	; 0x03
    2f68:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f6c:	ac 85       	ldd	r26, Y+12	; 0x0c
    2f6e:	bd 85       	ldd	r27, Y+13	; 0x0d
    2f70:	80 95       	com	r24
    2f72:	90 95       	com	r25
    2f74:	a0 95       	com	r26
    2f76:	b0 95       	com	r27
    2f78:	ba 01       	movw	r22, r20
    2f7a:	a9 01       	movw	r20, r18
    2f7c:	48 23       	and	r20, r24
    2f7e:	59 23       	and	r21, r25
    2f80:	6a 23       	and	r22, r26
    2f82:	7b 23       	and	r23, r27
    2f84:	2d 81       	ldd	r18, Y+5	; 0x05
    2f86:	3e 81       	ldd	r19, Y+6	; 0x06
    2f88:	c8 01       	movw	r24, r16
    2f8a:	88 0f       	add	r24, r24
    2f8c:	99 1f       	adc	r25, r25
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	82 0f       	add	r24, r18
    2f94:	93 1f       	adc	r25, r19
    2f96:	fc 01       	movw	r30, r24
    2f98:	b3 96       	adiw	r30, 0x23	; 35
    2f9a:	40 83       	st	Z, r20
    2f9c:	51 83       	std	Z+1, r21	; 0x01
    2f9e:	62 83       	std	Z+2, r22	; 0x02
    2fa0:	73 83       	std	Z+3, r23	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5245
        }
        taskEXIT_CRITICAL();
    2fa2:	0f 90       	pop	r0
    2fa4:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5247

        return ulReturn;
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	ab 81       	ldd	r26, Y+3	; 0x03
    2fac:	bc 81       	ldd	r27, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5248
    }
    2fae:	bc 01       	movw	r22, r24
    2fb0:	cd 01       	movw	r24, r26
    2fb2:	2f 96       	adiw	r28, 0x0f	; 15
    2fb4:	0f b6       	in	r0, 0x3f	; 63
    2fb6:	f8 94       	cli
    2fb8:	de bf       	out	0x3e, r29	; 62
    2fba:	0f be       	out	0x3f, r0	; 63
    2fbc:	cd bf       	out	0x3d, r28	; 61
    2fbe:	cf 91       	pop	r28
    2fc0:	df 91       	pop	r29
    2fc2:	1f 91       	pop	r17
    2fc4:	0f 91       	pop	r16
    2fc6:	08 95       	ret

00002fc8 <prvAddCurrentTaskToDelayedList>:
prvAddCurrentTaskToDelayedList():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5265
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    2fc8:	df 93       	push	r29
    2fca:	cf 93       	push	r28
    2fcc:	cd b7       	in	r28, 0x3d	; 61
    2fce:	de b7       	in	r29, 0x3e	; 62
    2fd0:	27 97       	sbiw	r28, 0x07	; 7
    2fd2:	0f b6       	in	r0, 0x3f	; 63
    2fd4:	f8 94       	cli
    2fd6:	de bf       	out	0x3e, r29	; 62
    2fd8:	0f be       	out	0x3f, r0	; 63
    2fda:	cd bf       	out	0x3d, r28	; 61
    2fdc:	9e 83       	std	Y+6, r25	; 0x06
    2fde:	8d 83       	std	Y+5, r24	; 0x05
    2fe0:	6f 83       	std	Y+7, r22	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5267
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    2fe2:	80 91 a9 03 	lds	r24, 0x03A9
    2fe6:	90 91 aa 03 	lds	r25, 0x03AA
    2fea:	9a 83       	std	Y+2, r25	; 0x02
    2fec:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5280
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2fee:	80 91 a5 03 	lds	r24, 0x03A5
    2ff2:	90 91 a6 03 	lds	r25, 0x03A6
    2ff6:	02 96       	adiw	r24, 0x02	; 2
    2ff8:	0e 94 ee 20 	call	0x41dc	; 0x41dc <uxListRemove>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5341
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    2ffc:	29 81       	ldd	r18, Y+1	; 0x01
    2ffe:	3a 81       	ldd	r19, Y+2	; 0x02
    3000:	8d 81       	ldd	r24, Y+5	; 0x05
    3002:	9e 81       	ldd	r25, Y+6	; 0x06
    3004:	82 0f       	add	r24, r18
    3006:	93 1f       	adc	r25, r19
    3008:	9c 83       	std	Y+4, r25	; 0x04
    300a:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5344

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    300c:	e0 91 a5 03 	lds	r30, 0x03A5
    3010:	f0 91 a6 03 	lds	r31, 0x03A6
    3014:	8b 81       	ldd	r24, Y+3	; 0x03
    3016:	9c 81       	ldd	r25, Y+4	; 0x04
    3018:	93 83       	std	Z+3, r25	; 0x03
    301a:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5346

            if( xTimeToWake < xConstTickCount )
    301c:	2b 81       	ldd	r18, Y+3	; 0x03
    301e:	3c 81       	ldd	r19, Y+4	; 0x04
    3020:	89 81       	ldd	r24, Y+1	; 0x01
    3022:	9a 81       	ldd	r25, Y+2	; 0x02
    3024:	28 17       	cp	r18, r24
    3026:	39 07       	cpc	r19, r25
    3028:	70 f4       	brcc	.+28     	; 0x3046 <prvAddCurrentTaskToDelayedList+0x7e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5349
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    302a:	80 91 ef 03 	lds	r24, 0x03EF
    302e:	90 91 f0 03 	lds	r25, 0x03F0
    3032:	20 91 a5 03 	lds	r18, 0x03A5
    3036:	30 91 a6 03 	lds	r19, 0x03A6
    303a:	2e 5f       	subi	r18, 0xFE	; 254
    303c:	3f 4f       	sbci	r19, 0xFF	; 255
    303e:	b9 01       	movw	r22, r18
    3040:	0e 94 82 20 	call	0x4104	; 0x4104 <vListInsert>
    3044:	1e c0       	rjmp	.+60     	; 0x3082 <prvAddCurrentTaskToDelayedList+0xba>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5354
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3046:	40 91 ed 03 	lds	r20, 0x03ED
    304a:	50 91 ee 03 	lds	r21, 0x03EE
    304e:	80 91 a5 03 	lds	r24, 0x03A5
    3052:	90 91 a6 03 	lds	r25, 0x03A6
    3056:	9c 01       	movw	r18, r24
    3058:	2e 5f       	subi	r18, 0xFE	; 254
    305a:	3f 4f       	sbci	r19, 0xFF	; 255
    305c:	ca 01       	movw	r24, r20
    305e:	b9 01       	movw	r22, r18
    3060:	0e 94 82 20 	call	0x4104	; 0x4104 <vListInsert>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5359

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    3064:	20 91 b2 03 	lds	r18, 0x03B2
    3068:	30 91 b3 03 	lds	r19, 0x03B3
    306c:	8b 81       	ldd	r24, Y+3	; 0x03
    306e:	9c 81       	ldd	r25, Y+4	; 0x04
    3070:	82 17       	cp	r24, r18
    3072:	93 07       	cpc	r25, r19
    3074:	30 f4       	brcc	.+12     	; 0x3082 <prvAddCurrentTaskToDelayedList+0xba>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5361
                {
                    xNextTaskUnblockTime = xTimeToWake;
    3076:	8b 81       	ldd	r24, Y+3	; 0x03
    3078:	9c 81       	ldd	r25, Y+4	; 0x04
    307a:	90 93 b3 03 	sts	0x03B3, r25
    307e:	80 93 b2 03 	sts	0x03B2, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/tasks.c:5373

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    3082:	27 96       	adiw	r28, 0x07	; 7
    3084:	0f b6       	in	r0, 0x3f	; 63
    3086:	f8 94       	cli
    3088:	de bf       	out	0x3e, r29	; 62
    308a:	0f be       	out	0x3f, r0	; 63
    308c:	cd bf       	out	0x3d, r28	; 61
    308e:	cf 91       	pop	r28
    3090:	df 91       	pop	r29
    3092:	08 95       	ret

00003094 <xQueueGenericReset>:
xQueueGenericReset():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:266
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	00 d0       	rcall	.+0      	; 0x309a <xQueueGenericReset+0x6>
    309a:	00 d0       	rcall	.+0      	; 0x309c <xQueueGenericReset+0x8>
    309c:	0f 92       	push	r0
    309e:	cd b7       	in	r28, 0x3d	; 61
    30a0:	de b7       	in	r29, 0x3e	; 62
    30a2:	9c 83       	std	Y+4, r25	; 0x04
    30a4:	8b 83       	std	Y+3, r24	; 0x03
    30a6:	6d 83       	std	Y+5, r22	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:267
    Queue_t * const pxQueue = xQueue;
    30a8:	8b 81       	ldd	r24, Y+3	; 0x03
    30aa:	9c 81       	ldd	r25, Y+4	; 0x04
    30ac:	9a 83       	std	Y+2, r25	; 0x02
    30ae:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:271

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    30b0:	0f b6       	in	r0, 0x3f	; 63
    30b2:	f8 94       	cli
    30b4:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:273
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    30b6:	e9 81       	ldd	r30, Y+1	; 0x01
    30b8:	fa 81       	ldd	r31, Y+2	; 0x02
    30ba:	40 81       	ld	r20, Z
    30bc:	51 81       	ldd	r21, Z+1	; 0x01
    30be:	e9 81       	ldd	r30, Y+1	; 0x01
    30c0:	fa 81       	ldd	r31, Y+2	; 0x02
    30c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    30c4:	28 2f       	mov	r18, r24
    30c6:	30 e0       	ldi	r19, 0x00	; 0
    30c8:	e9 81       	ldd	r30, Y+1	; 0x01
    30ca:	fa 81       	ldd	r31, Y+2	; 0x02
    30cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    30ce:	88 2f       	mov	r24, r24
    30d0:	90 e0       	ldi	r25, 0x00	; 0
    30d2:	bc 01       	movw	r22, r24
    30d4:	26 9f       	mul	r18, r22
    30d6:	c0 01       	movw	r24, r0
    30d8:	27 9f       	mul	r18, r23
    30da:	90 0d       	add	r25, r0
    30dc:	36 9f       	mul	r19, r22
    30de:	90 0d       	add	r25, r0
    30e0:	11 24       	eor	r1, r1
    30e2:	84 0f       	add	r24, r20
    30e4:	95 1f       	adc	r25, r21
    30e6:	e9 81       	ldd	r30, Y+1	; 0x01
    30e8:	fa 81       	ldd	r31, Y+2	; 0x02
    30ea:	95 83       	std	Z+5, r25	; 0x05
    30ec:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:274
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    30ee:	e9 81       	ldd	r30, Y+1	; 0x01
    30f0:	fa 81       	ldd	r31, Y+2	; 0x02
    30f2:	12 8e       	std	Z+26, r1	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:275
        pxQueue->pcWriteTo = pxQueue->pcHead;
    30f4:	e9 81       	ldd	r30, Y+1	; 0x01
    30f6:	fa 81       	ldd	r31, Y+2	; 0x02
    30f8:	80 81       	ld	r24, Z
    30fa:	91 81       	ldd	r25, Z+1	; 0x01
    30fc:	e9 81       	ldd	r30, Y+1	; 0x01
    30fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3100:	93 83       	std	Z+3, r25	; 0x03
    3102:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:276
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3104:	e9 81       	ldd	r30, Y+1	; 0x01
    3106:	fa 81       	ldd	r31, Y+2	; 0x02
    3108:	40 81       	ld	r20, Z
    310a:	51 81       	ldd	r21, Z+1	; 0x01
    310c:	e9 81       	ldd	r30, Y+1	; 0x01
    310e:	fa 81       	ldd	r31, Y+2	; 0x02
    3110:	83 8d       	ldd	r24, Z+27	; 0x1b
    3112:	88 2f       	mov	r24, r24
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	9c 01       	movw	r18, r24
    3118:	21 50       	subi	r18, 0x01	; 1
    311a:	30 40       	sbci	r19, 0x00	; 0
    311c:	e9 81       	ldd	r30, Y+1	; 0x01
    311e:	fa 81       	ldd	r31, Y+2	; 0x02
    3120:	84 8d       	ldd	r24, Z+28	; 0x1c
    3122:	88 2f       	mov	r24, r24
    3124:	90 e0       	ldi	r25, 0x00	; 0
    3126:	bc 01       	movw	r22, r24
    3128:	26 9f       	mul	r18, r22
    312a:	c0 01       	movw	r24, r0
    312c:	27 9f       	mul	r18, r23
    312e:	90 0d       	add	r25, r0
    3130:	36 9f       	mul	r19, r22
    3132:	90 0d       	add	r25, r0
    3134:	11 24       	eor	r1, r1
    3136:	84 0f       	add	r24, r20
    3138:	95 1f       	adc	r25, r21
    313a:	e9 81       	ldd	r30, Y+1	; 0x01
    313c:	fa 81       	ldd	r31, Y+2	; 0x02
    313e:	97 83       	std	Z+7, r25	; 0x07
    3140:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:277
        pxQueue->cRxLock = queueUNLOCKED;
    3142:	e9 81       	ldd	r30, Y+1	; 0x01
    3144:	fa 81       	ldd	r31, Y+2	; 0x02
    3146:	8f ef       	ldi	r24, 0xFF	; 255
    3148:	85 8f       	std	Z+29, r24	; 0x1d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:278
        pxQueue->cTxLock = queueUNLOCKED;
    314a:	e9 81       	ldd	r30, Y+1	; 0x01
    314c:	fa 81       	ldd	r31, Y+2	; 0x02
    314e:	8f ef       	ldi	r24, 0xFF	; 255
    3150:	86 8f       	std	Z+30, r24	; 0x1e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:280

        if( xNewQueue == pdFALSE )
    3152:	8d 81       	ldd	r24, Y+5	; 0x05
    3154:	88 23       	and	r24, r24
    3156:	79 f4       	brne	.+30     	; 0x3176 <xQueueGenericReset+0xe2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:287
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3158:	e9 81       	ldd	r30, Y+1	; 0x01
    315a:	fa 81       	ldd	r31, Y+2	; 0x02
    315c:	80 85       	ldd	r24, Z+8	; 0x08
    315e:	88 23       	and	r24, r24
    3160:	a1 f0       	breq	.+40     	; 0x318a <xQueueGenericReset+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:289
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3162:	89 81       	ldd	r24, Y+1	; 0x01
    3164:	9a 81       	ldd	r25, Y+2	; 0x02
    3166:	08 96       	adiw	r24, 0x08	; 8
    3168:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    316c:	88 23       	and	r24, r24
    316e:	69 f0       	breq	.+26     	; 0x318a <xQueueGenericReset+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:291
                {
                    queueYIELD_IF_USING_PREEMPTION();
    3170:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    3174:	0a c0       	rjmp	.+20     	; 0x318a <xQueueGenericReset+0xf6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:306
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3176:	89 81       	ldd	r24, Y+1	; 0x01
    3178:	9a 81       	ldd	r25, Y+2	; 0x02
    317a:	08 96       	adiw	r24, 0x08	; 8
    317c:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:307
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3180:	89 81       	ldd	r24, Y+1	; 0x01
    3182:	9a 81       	ldd	r25, Y+2	; 0x02
    3184:	41 96       	adiw	r24, 0x11	; 17
    3186:	0e 94 04 20 	call	0x4008	; 0x4008 <vListInitialise>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:310
        }
    }
    taskEXIT_CRITICAL();
    318a:	0f 90       	pop	r0
    318c:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:314

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
    318e:	81 e0       	ldi	r24, 0x01	; 1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:315
}
    3190:	0f 90       	pop	r0
    3192:	0f 90       	pop	r0
    3194:	0f 90       	pop	r0
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	cf 91       	pop	r28
    319c:	df 91       	pop	r29
    319e:	08 95       	ret

000031a0 <xQueueGenericCreateStatic>:
xQueueGenericCreateStatic():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:325
    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
                                             const UBaseType_t uxItemSize,
                                             uint8_t * pucQueueStorage,
                                             StaticQueue_t * pxStaticQueue,
                                             const uint8_t ucQueueType )
    {
    31a0:	0f 93       	push	r16
    31a2:	1f 93       	push	r17
    31a4:	df 93       	push	r29
    31a6:	cf 93       	push	r28
    31a8:	cd b7       	in	r28, 0x3d	; 61
    31aa:	de b7       	in	r29, 0x3e	; 62
    31ac:	29 97       	sbiw	r28, 0x09	; 9
    31ae:	0f b6       	in	r0, 0x3f	; 63
    31b0:	f8 94       	cli
    31b2:	de bf       	out	0x3e, r29	; 62
    31b4:	0f be       	out	0x3f, r0	; 63
    31b6:	cd bf       	out	0x3d, r28	; 61
    31b8:	8b 83       	std	Y+3, r24	; 0x03
    31ba:	6c 83       	std	Y+4, r22	; 0x04
    31bc:	5e 83       	std	Y+6, r21	; 0x06
    31be:	4d 83       	std	Y+5, r20	; 0x05
    31c0:	38 87       	std	Y+8, r19	; 0x08
    31c2:	2f 83       	std	Y+7, r18	; 0x07
    31c4:	09 87       	std	Y+9, r16	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:353
        #endif /* configASSERT_DEFINED */

        /* The address of a statically allocated queue was passed in, use it.
         * The address of a statically allocated storage area was also passed in
         * but is already set. */
        pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    31c6:	8f 81       	ldd	r24, Y+7	; 0x07
    31c8:	98 85       	ldd	r25, Y+8	; 0x08
    31ca:	9a 83       	std	Y+2, r25	; 0x02
    31cc:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:355

        if( pxNewQueue != NULL )
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	9a 81       	ldd	r25, Y+2	; 0x02
    31d2:	00 97       	sbiw	r24, 0x00	; 0
    31d4:	59 f0       	breq	.+22     	; 0x31ec <xQueueGenericCreateStatic+0x4c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:366
                     * later deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
                }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    31d6:	2d 81       	ldd	r18, Y+5	; 0x05
    31d8:	3e 81       	ldd	r19, Y+6	; 0x06
    31da:	e9 81       	ldd	r30, Y+1	; 0x01
    31dc:	fa 81       	ldd	r31, Y+2	; 0x02
    31de:	8b 81       	ldd	r24, Y+3	; 0x03
    31e0:	6c 81       	ldd	r22, Y+4	; 0x04
    31e2:	a9 01       	movw	r20, r18
    31e4:	29 85       	ldd	r18, Y+9	; 0x09
    31e6:	8f 01       	movw	r16, r30
    31e8:	0e 94 03 19 	call	0x3206	; 0x3206 <prvInitialiseNewQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:374
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    31ec:	89 81       	ldd	r24, Y+1	; 0x01
    31ee:	9a 81       	ldd	r25, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:375
    }
    31f0:	29 96       	adiw	r28, 0x09	; 9
    31f2:	0f b6       	in	r0, 0x3f	; 63
    31f4:	f8 94       	cli
    31f6:	de bf       	out	0x3e, r29	; 62
    31f8:	0f be       	out	0x3f, r0	; 63
    31fa:	cd bf       	out	0x3d, r28	; 61
    31fc:	cf 91       	pop	r28
    31fe:	df 91       	pop	r29
    3200:	1f 91       	pop	r17
    3202:	0f 91       	pop	r16
    3204:	08 95       	ret

00003206 <prvInitialiseNewQueue>:
prvInitialiseNewQueue():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:449
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    3206:	0f 93       	push	r16
    3208:	1f 93       	push	r17
    320a:	df 93       	push	r29
    320c:	cf 93       	push	r28
    320e:	cd b7       	in	r28, 0x3d	; 61
    3210:	de b7       	in	r29, 0x3e	; 62
    3212:	27 97       	sbiw	r28, 0x07	; 7
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	de bf       	out	0x3e, r29	; 62
    321a:	0f be       	out	0x3f, r0	; 63
    321c:	cd bf       	out	0x3d, r28	; 61
    321e:	89 83       	std	Y+1, r24	; 0x01
    3220:	6a 83       	std	Y+2, r22	; 0x02
    3222:	5c 83       	std	Y+4, r21	; 0x04
    3224:	4b 83       	std	Y+3, r20	; 0x03
    3226:	2d 83       	std	Y+5, r18	; 0x05
    3228:	1f 83       	std	Y+7, r17	; 0x07
    322a:	0e 83       	std	Y+6, r16	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:454
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    322c:	8a 81       	ldd	r24, Y+2	; 0x02
    322e:	88 23       	and	r24, r24
    3230:	39 f4       	brne	.+14     	; 0x3240 <prvInitialiseNewQueue+0x3a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:460
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3232:	8e 81       	ldd	r24, Y+6	; 0x06
    3234:	9f 81       	ldd	r25, Y+7	; 0x07
    3236:	ee 81       	ldd	r30, Y+6	; 0x06
    3238:	ff 81       	ldd	r31, Y+7	; 0x07
    323a:	91 83       	std	Z+1, r25	; 0x01
    323c:	80 83       	st	Z, r24
    323e:	06 c0       	rjmp	.+12     	; 0x324c <prvInitialiseNewQueue+0x46>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:465
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3240:	8b 81       	ldd	r24, Y+3	; 0x03
    3242:	9c 81       	ldd	r25, Y+4	; 0x04
    3244:	ee 81       	ldd	r30, Y+6	; 0x06
    3246:	ff 81       	ldd	r31, Y+7	; 0x07
    3248:	91 83       	std	Z+1, r25	; 0x01
    324a:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:470
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    324c:	ee 81       	ldd	r30, Y+6	; 0x06
    324e:	ff 81       	ldd	r31, Y+7	; 0x07
    3250:	89 81       	ldd	r24, Y+1	; 0x01
    3252:	83 8f       	std	Z+27, r24	; 0x1b
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:471
    pxNewQueue->uxItemSize = uxItemSize;
    3254:	ee 81       	ldd	r30, Y+6	; 0x06
    3256:	ff 81       	ldd	r31, Y+7	; 0x07
    3258:	8a 81       	ldd	r24, Y+2	; 0x02
    325a:	84 8f       	std	Z+28, r24	; 0x1c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:472
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    325c:	8e 81       	ldd	r24, Y+6	; 0x06
    325e:	9f 81       	ldd	r25, Y+7	; 0x07
    3260:	61 e0       	ldi	r22, 0x01	; 1
    3262:	0e 94 4a 18 	call	0x3094	; 0x3094 <xQueueGenericReset>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:487
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    3266:	27 96       	adiw	r28, 0x07	; 7
    3268:	0f b6       	in	r0, 0x3f	; 63
    326a:	f8 94       	cli
    326c:	de bf       	out	0x3e, r29	; 62
    326e:	0f be       	out	0x3f, r0	; 63
    3270:	cd bf       	out	0x3d, r28	; 61
    3272:	cf 91       	pop	r28
    3274:	df 91       	pop	r29
    3276:	1f 91       	pop	r17
    3278:	0f 91       	pop	r16
    327a:	08 95       	ret

0000327c <prvInitialiseMutex>:
prvInitialiseMutex():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:493
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
    327c:	df 93       	push	r29
    327e:	cf 93       	push	r28
    3280:	00 d0       	rcall	.+0      	; 0x3282 <prvInitialiseMutex+0x6>
    3282:	cd b7       	in	r28, 0x3d	; 61
    3284:	de b7       	in	r29, 0x3e	; 62
    3286:	9a 83       	std	Y+2, r25	; 0x02
    3288:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:494
        if( pxNewQueue != NULL )
    328a:	89 81       	ldd	r24, Y+1	; 0x01
    328c:	9a 81       	ldd	r25, Y+2	; 0x02
    328e:	00 97       	sbiw	r24, 0x00	; 0
    3290:	a1 f0       	breq	.+40     	; 0x32ba <prvInitialiseMutex+0x3e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:500
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    3292:	e9 81       	ldd	r30, Y+1	; 0x01
    3294:	fa 81       	ldd	r31, Y+2	; 0x02
    3296:	15 82       	std	Z+5, r1	; 0x05
    3298:	14 82       	std	Z+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:501
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    329a:	e9 81       	ldd	r30, Y+1	; 0x01
    329c:	fa 81       	ldd	r31, Y+2	; 0x02
    329e:	11 82       	std	Z+1, r1	; 0x01
    32a0:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:504

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    32a2:	e9 81       	ldd	r30, Y+1	; 0x01
    32a4:	fa 81       	ldd	r31, Y+2	; 0x02
    32a6:	16 82       	std	Z+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:509

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    32a8:	89 81       	ldd	r24, Y+1	; 0x01
    32aa:	9a 81       	ldd	r25, Y+2	; 0x02
    32ac:	60 e0       	ldi	r22, 0x00	; 0
    32ae:	70 e0       	ldi	r23, 0x00	; 0
    32b0:	40 e0       	ldi	r20, 0x00	; 0
    32b2:	50 e0       	ldi	r21, 0x00	; 0
    32b4:	20 e0       	ldi	r18, 0x00	; 0
    32b6:	0e 94 8e 19 	call	0x331c	; 0x331c <xQueueGenericSend>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:515
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
    32ba:	0f 90       	pop	r0
    32bc:	0f 90       	pop	r0
    32be:	cf 91       	pop	r28
    32c0:	df 91       	pop	r29
    32c2:	08 95       	ret

000032c4 <xQueueCreateMutexStatic>:
xQueueCreateMutexStatic():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:540

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
                                           StaticQueue_t * pxStaticQueue )
    {
    32c4:	0f 93       	push	r16
    32c6:	df 93       	push	r29
    32c8:	cf 93       	push	r28
    32ca:	cd b7       	in	r28, 0x3d	; 61
    32cc:	de b7       	in	r29, 0x3e	; 62
    32ce:	27 97       	sbiw	r28, 0x07	; 7
    32d0:	0f b6       	in	r0, 0x3f	; 63
    32d2:	f8 94       	cli
    32d4:	de bf       	out	0x3e, r29	; 62
    32d6:	0f be       	out	0x3f, r0	; 63
    32d8:	cd bf       	out	0x3d, r28	; 61
    32da:	8d 83       	std	Y+5, r24	; 0x05
    32dc:	7f 83       	std	Y+7, r23	; 0x07
    32de:	6e 83       	std	Y+6, r22	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:542
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	8a 83       	std	Y+2, r24	; 0x02
    32e4:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:548

        /* Prevent compiler warnings about unused parameters if
         * configUSE_TRACE_FACILITY does not equal 1. */
        ( void ) ucQueueType;

        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
    32e6:	2e 81       	ldd	r18, Y+6	; 0x06
    32e8:	3f 81       	ldd	r19, Y+7	; 0x07
    32ea:	8a 81       	ldd	r24, Y+2	; 0x02
    32ec:	69 81       	ldd	r22, Y+1	; 0x01
    32ee:	40 e0       	ldi	r20, 0x00	; 0
    32f0:	50 e0       	ldi	r21, 0x00	; 0
    32f2:	0d 81       	ldd	r16, Y+5	; 0x05
    32f4:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <xQueueGenericCreateStatic>
    32f8:	9c 83       	std	Y+4, r25	; 0x04
    32fa:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:549
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    32fc:	8b 81       	ldd	r24, Y+3	; 0x03
    32fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3300:	0e 94 3e 19 	call	0x327c	; 0x327c <prvInitialiseMutex>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:551

        return xNewQueue;
    3304:	8b 81       	ldd	r24, Y+3	; 0x03
    3306:	9c 81       	ldd	r25, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:552
    }
    3308:	27 96       	adiw	r28, 0x07	; 7
    330a:	0f b6       	in	r0, 0x3f	; 63
    330c:	f8 94       	cli
    330e:	de bf       	out	0x3e, r29	; 62
    3310:	0f be       	out	0x3f, r0	; 63
    3312:	cd bf       	out	0x3d, r28	; 61
    3314:	cf 91       	pop	r28
    3316:	df 91       	pop	r29
    3318:	0f 91       	pop	r16
    331a:	08 95       	ret

0000331c <xQueueGenericSend>:
xQueueGenericSend():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:775

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    331c:	df 93       	push	r29
    331e:	cf 93       	push	r28
    3320:	cd b7       	in	r28, 0x3d	; 61
    3322:	de b7       	in	r29, 0x3e	; 62
    3324:	2f 97       	sbiw	r28, 0x0f	; 15
    3326:	0f b6       	in	r0, 0x3f	; 63
    3328:	f8 94       	cli
    332a:	de bf       	out	0x3e, r29	; 62
    332c:	0f be       	out	0x3f, r0	; 63
    332e:	cd bf       	out	0x3d, r28	; 61
    3330:	99 87       	std	Y+9, r25	; 0x09
    3332:	88 87       	std	Y+8, r24	; 0x08
    3334:	7b 87       	std	Y+11, r23	; 0x0b
    3336:	6a 87       	std	Y+10, r22	; 0x0a
    3338:	5d 87       	std	Y+13, r21	; 0x0d
    333a:	4c 87       	std	Y+12, r20	; 0x0c
    333c:	2e 87       	std	Y+14, r18	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:776
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    333e:	1c 82       	std	Y+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:778
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3340:	88 85       	ldd	r24, Y+8	; 0x08
    3342:	99 85       	ldd	r25, Y+9	; 0x09
    3344:	9a 83       	std	Y+2, r25	; 0x02
    3346:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:794
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3348:	0f b6       	in	r0, 0x3f	; 63
    334a:	f8 94       	cli
    334c:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:800
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    334e:	e9 81       	ldd	r30, Y+1	; 0x01
    3350:	fa 81       	ldd	r31, Y+2	; 0x02
    3352:	92 8d       	ldd	r25, Z+26	; 0x1a
    3354:	e9 81       	ldd	r30, Y+1	; 0x01
    3356:	fa 81       	ldd	r31, Y+2	; 0x02
    3358:	83 8d       	ldd	r24, Z+27	; 0x1b
    335a:	98 17       	cp	r25, r24
    335c:	18 f0       	brcs	.+6      	; 0x3364 <xQueueGenericSend+0x48>
    335e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3360:	82 30       	cpi	r24, 0x02	; 2
    3362:	11 f5       	brne	.+68     	; 0x33a8 <xQueueGenericSend+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:866
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3364:	89 81       	ldd	r24, Y+1	; 0x01
    3366:	9a 81       	ldd	r25, Y+2	; 0x02
    3368:	2a 85       	ldd	r18, Y+10	; 0x0a
    336a:	3b 85       	ldd	r19, Y+11	; 0x0b
    336c:	b9 01       	movw	r22, r18
    336e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3370:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <prvCopyDataToQueue>
    3374:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:870

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3376:	e9 81       	ldd	r30, Y+1	; 0x01
    3378:	fa 81       	ldd	r31, Y+2	; 0x02
    337a:	81 89       	ldd	r24, Z+17	; 0x11
    337c:	88 23       	and	r24, r24
    337e:	51 f0       	breq	.+20     	; 0x3394 <xQueueGenericSend+0x78>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:872
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3380:	89 81       	ldd	r24, Y+1	; 0x01
    3382:	9a 81       	ldd	r25, Y+2	; 0x02
    3384:	41 96       	adiw	r24, 0x11	; 17
    3386:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    338a:	88 23       	and	r24, r24
    338c:	41 f0       	breq	.+16     	; 0x339e <xQueueGenericSend+0x82>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:878
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    338e:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    3392:	05 c0       	rjmp	.+10     	; 0x339e <xQueueGenericSend+0x82>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:885
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	88 23       	and	r24, r24
    3398:	11 f0       	breq	.+4      	; 0x339e <xQueueGenericSend+0x82>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:891
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    339a:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:900
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    339e:	0f 90       	pop	r0
    33a0:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:901
                return pdPASS;
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	8f 87       	std	Y+15, r24	; 0x0f
    33a6:	5c c0       	rjmp	.+184    	; 0x3460 <xQueueGenericSend+0x144>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:905
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    33a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    33aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    33ac:	00 97       	sbiw	r24, 0x00	; 0
    33ae:	21 f4       	brne	.+8      	; 0x33b8 <xQueueGenericSend+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:909
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    33b0:	0f 90       	pop	r0
    33b2:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:914

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    33b4:	1f 86       	std	Y+15, r1	; 0x0f
    33b6:	54 c0       	rjmp	.+168    	; 0x3460 <xQueueGenericSend+0x144>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:916
                }
                else if( xEntryTimeSet == pdFALSE )
    33b8:	8c 81       	ldd	r24, Y+4	; 0x04
    33ba:	88 23       	and	r24, r24
    33bc:	31 f4       	brne	.+12     	; 0x33ca <xQueueGenericSend+0xae>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:920
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    33be:	ce 01       	movw	r24, r28
    33c0:	05 96       	adiw	r24, 0x05	; 5
    33c2:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskInternalSetTimeOutState>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:921
                    xEntryTimeSet = pdTRUE;
    33c6:	81 e0       	ldi	r24, 0x01	; 1
    33c8:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:930
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    33ca:	0f 90       	pop	r0
    33cc:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:935

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    33ce:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:936
        prvLockQueue( pxQueue );
    33d2:	0f b6       	in	r0, 0x3f	; 63
    33d4:	f8 94       	cli
    33d6:	0f 92       	push	r0
    33d8:	e9 81       	ldd	r30, Y+1	; 0x01
    33da:	fa 81       	ldd	r31, Y+2	; 0x02
    33dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    33de:	8f 3f       	cpi	r24, 0xFF	; 255
    33e0:	19 f4       	brne	.+6      	; 0x33e8 <xQueueGenericSend+0xcc>
    33e2:	e9 81       	ldd	r30, Y+1	; 0x01
    33e4:	fa 81       	ldd	r31, Y+2	; 0x02
    33e6:	15 8e       	std	Z+29, r1	; 0x1d
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    33ee:	8f 3f       	cpi	r24, 0xFF	; 255
    33f0:	19 f4       	brne	.+6      	; 0x33f8 <xQueueGenericSend+0xdc>
    33f2:	e9 81       	ldd	r30, Y+1	; 0x01
    33f4:	fa 81       	ldd	r31, Y+2	; 0x02
    33f6:	16 8e       	std	Z+30, r1	; 0x1e
    33f8:	0f 90       	pop	r0
    33fa:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:939

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    33fc:	ce 01       	movw	r24, r28
    33fe:	05 96       	adiw	r24, 0x05	; 5
    3400:	9e 01       	movw	r18, r28
    3402:	24 5f       	subi	r18, 0xF4	; 244
    3404:	3f 4f       	sbci	r19, 0xFF	; 255
    3406:	b9 01       	movw	r22, r18
    3408:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <xTaskCheckForTimeOut>
    340c:	88 23       	and	r24, r24
    340e:	09 f5       	brne	.+66     	; 0x3452 <xQueueGenericSend+0x136>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:941
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3410:	89 81       	ldd	r24, Y+1	; 0x01
    3412:	9a 81       	ldd	r25, Y+2	; 0x02
    3414:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvIsQueueFull>
    3418:	88 23       	and	r24, r24
    341a:	a1 f0       	breq	.+40     	; 0x3444 <xQueueGenericSend+0x128>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:944
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    341c:	89 81       	ldd	r24, Y+1	; 0x01
    341e:	9a 81       	ldd	r25, Y+2	; 0x02
    3420:	08 96       	adiw	r24, 0x08	; 8
    3422:	2c 85       	ldd	r18, Y+12	; 0x0c
    3424:	3d 85       	ldd	r19, Y+13	; 0x0d
    3426:	b9 01       	movw	r22, r18
    3428:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <vTaskPlaceOnEventList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:951
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    342c:	89 81       	ldd	r24, Y+1	; 0x01
    342e:	9a 81       	ldd	r25, Y+2	; 0x02
    3430:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:958
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    3434:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    3438:	88 23       	and	r24, r24
    343a:	09 f0       	breq	.+2      	; 0x343e <xQueueGenericSend+0x122>
    343c:	85 cf       	rjmp	.-246    	; 0x3348 <xQueueGenericSend+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:960
                {
                    portYIELD_WITHIN_API();
    343e:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    3442:	82 cf       	rjmp	.-252    	; 0x3348 <xQueueGenericSend+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:966
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    3444:	89 81       	ldd	r24, Y+1	; 0x01
    3446:	9a 81       	ldd	r25, Y+2	; 0x02
    3448:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:967
                ( void ) xTaskResumeAll();
    344c:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    3450:	7b cf       	rjmp	.-266    	; 0x3348 <xQueueGenericSend+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:973
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    3452:	89 81       	ldd	r24, Y+1	; 0x01
    3454:	9a 81       	ldd	r25, Y+2	; 0x02
    3456:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:974
            ( void ) xTaskResumeAll();
    345a:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:977

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    345e:	1f 86       	std	Y+15, r1	; 0x0f
    3460:	8f 85       	ldd	r24, Y+15	; 0x0f
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:980
        }
    } /*lint -restore */
}
    3462:	2f 96       	adiw	r28, 0x0f	; 15
    3464:	0f b6       	in	r0, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	de bf       	out	0x3e, r29	; 62
    346a:	0f be       	out	0x3f, r0	; 63
    346c:	cd bf       	out	0x3d, r28	; 61
    346e:	cf 91       	pop	r28
    3470:	df 91       	pop	r29
    3472:	08 95       	ret

00003474 <xQueueGenericSendFromISR>:
xQueueGenericSendFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:987

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    3474:	df 93       	push	r29
    3476:	cf 93       	push	r28
    3478:	cd b7       	in	r28, 0x3d	; 61
    347a:	de b7       	in	r29, 0x3e	; 62
    347c:	2d 97       	sbiw	r28, 0x0d	; 13
    347e:	0f b6       	in	r0, 0x3f	; 63
    3480:	f8 94       	cli
    3482:	de bf       	out	0x3e, r29	; 62
    3484:	0f be       	out	0x3f, r0	; 63
    3486:	cd bf       	out	0x3d, r28	; 61
    3488:	98 87       	std	Y+8, r25	; 0x08
    348a:	8f 83       	std	Y+7, r24	; 0x07
    348c:	7a 87       	std	Y+10, r23	; 0x0a
    348e:	69 87       	std	Y+9, r22	; 0x09
    3490:	5c 87       	std	Y+12, r21	; 0x0c
    3492:	4b 87       	std	Y+11, r20	; 0x0b
    3494:	2d 87       	std	Y+13, r18	; 0x0d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:990
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3496:	8f 81       	ldd	r24, Y+7	; 0x07
    3498:	98 85       	ldd	r25, Y+8	; 0x08
    349a:	9c 83       	std	Y+4, r25	; 0x04
    349c:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1017
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    349e:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1019
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    34a0:	eb 81       	ldd	r30, Y+3	; 0x03
    34a2:	fc 81       	ldd	r31, Y+4	; 0x04
    34a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    34a6:	eb 81       	ldd	r30, Y+3	; 0x03
    34a8:	fc 81       	ldd	r31, Y+4	; 0x04
    34aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    34ac:	98 17       	cp	r25, r24
    34ae:	18 f0       	brcs	.+6      	; 0x34b6 <xQueueGenericSendFromISR+0x42>
    34b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    34b2:	82 30       	cpi	r24, 0x02	; 2
    34b4:	81 f5       	brne	.+96     	; 0x3516 <xQueueGenericSendFromISR+0xa2>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1021
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    34b6:	eb 81       	ldd	r30, Y+3	; 0x03
    34b8:	fc 81       	ldd	r31, Y+4	; 0x04
    34ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    34bc:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1022
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    34be:	eb 81       	ldd	r30, Y+3	; 0x03
    34c0:	fc 81       	ldd	r31, Y+4	; 0x04
    34c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    34c4:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1031
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    34c6:	8b 81       	ldd	r24, Y+3	; 0x03
    34c8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ca:	29 85       	ldd	r18, Y+9	; 0x09
    34cc:	3a 85       	ldd	r19, Y+10	; 0x0a
    34ce:	b9 01       	movw	r22, r18
    34d0:	4d 85       	ldd	r20, Y+13	; 0x0d
    34d2:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <prvCopyDataToQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1035

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    34d6:	8a 81       	ldd	r24, Y+2	; 0x02
    34d8:	8f 3f       	cpi	r24, 0xFF	; 255
    34da:	a9 f4       	brne	.+42     	; 0x3506 <xQueueGenericSendFromISR+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1097
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34dc:	eb 81       	ldd	r30, Y+3	; 0x03
    34de:	fc 81       	ldd	r31, Y+4	; 0x04
    34e0:	81 89       	ldd	r24, Z+17	; 0x11
    34e2:	88 23       	and	r24, r24
    34e4:	a9 f0       	breq	.+42     	; 0x3510 <xQueueGenericSendFromISR+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1099
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    34e6:	8b 81       	ldd	r24, Y+3	; 0x03
    34e8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ea:	41 96       	adiw	r24, 0x11	; 17
    34ec:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    34f0:	88 23       	and	r24, r24
    34f2:	71 f0       	breq	.+28     	; 0x3510 <xQueueGenericSendFromISR+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1103
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    34f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    34f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    34f8:	00 97       	sbiw	r24, 0x00	; 0
    34fa:	51 f0       	breq	.+20     	; 0x3510 <xQueueGenericSendFromISR+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1105
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    34fc:	eb 85       	ldd	r30, Y+11	; 0x0b
    34fe:	fc 85       	ldd	r31, Y+12	; 0x0c
    3500:	81 e0       	ldi	r24, 0x01	; 1
    3502:	80 83       	st	Z, r24
    3504:	05 c0       	rjmp	.+10     	; 0x3510 <xQueueGenericSendFromISR+0x9c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1133
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3506:	8a 81       	ldd	r24, Y+2	; 0x02
    3508:	8f 5f       	subi	r24, 0xFF	; 255
    350a:	eb 81       	ldd	r30, Y+3	; 0x03
    350c:	fc 81       	ldd	r31, Y+4	; 0x04
    350e:	86 8f       	std	Z+30, r24	; 0x1e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1136
            }

            xReturn = pdPASS;
    3510:	81 e0       	ldi	r24, 0x01	; 1
    3512:	8e 83       	std	Y+6, r24	; 0x06
    3514:	01 c0       	rjmp	.+2      	; 0x3518 <xQueueGenericSendFromISR+0xa4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1141
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3516:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1146
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3518:	8e 81       	ldd	r24, Y+6	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1147
}
    351a:	2d 96       	adiw	r28, 0x0d	; 13
    351c:	0f b6       	in	r0, 0x3f	; 63
    351e:	f8 94       	cli
    3520:	de bf       	out	0x3e, r29	; 62
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	cd bf       	out	0x3d, r28	; 61
    3526:	cf 91       	pop	r28
    3528:	df 91       	pop	r29
    352a:	08 95       	ret

0000352c <xQueueGiveFromISR>:
xQueueGiveFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1152
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    352c:	df 93       	push	r29
    352e:	cf 93       	push	r28
    3530:	cd b7       	in	r28, 0x3d	; 61
    3532:	de b7       	in	r29, 0x3e	; 62
    3534:	2a 97       	sbiw	r28, 0x0a	; 10
    3536:	0f b6       	in	r0, 0x3f	; 63
    3538:	f8 94       	cli
    353a:	de bf       	out	0x3e, r29	; 62
    353c:	0f be       	out	0x3f, r0	; 63
    353e:	cd bf       	out	0x3d, r28	; 61
    3540:	98 87       	std	Y+8, r25	; 0x08
    3542:	8f 83       	std	Y+7, r24	; 0x07
    3544:	7a 87       	std	Y+10, r23	; 0x0a
    3546:	69 87       	std	Y+9, r22	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1155
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3548:	8f 81       	ldd	r24, Y+7	; 0x07
    354a:	98 85       	ldd	r25, Y+8	; 0x08
    354c:	9c 83       	std	Y+4, r25	; 0x04
    354e:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1190
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3550:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1192
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3552:	eb 81       	ldd	r30, Y+3	; 0x03
    3554:	fc 81       	ldd	r31, Y+4	; 0x04
    3556:	82 8d       	ldd	r24, Z+26	; 0x1a
    3558:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1197

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    355a:	eb 81       	ldd	r30, Y+3	; 0x03
    355c:	fc 81       	ldd	r31, Y+4	; 0x04
    355e:	93 8d       	ldd	r25, Z+27	; 0x1b
    3560:	8a 81       	ldd	r24, Y+2	; 0x02
    3562:	89 17       	cp	r24, r25
    3564:	48 f5       	brcc	.+82     	; 0x35b8 <xQueueGiveFromISR+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1199
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3566:	eb 81       	ldd	r30, Y+3	; 0x03
    3568:	fc 81       	ldd	r31, Y+4	; 0x04
    356a:	86 8d       	ldd	r24, Z+30	; 0x1e
    356c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1209
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    356e:	8a 81       	ldd	r24, Y+2	; 0x02
    3570:	8f 5f       	subi	r24, 0xFF	; 255
    3572:	eb 81       	ldd	r30, Y+3	; 0x03
    3574:	fc 81       	ldd	r31, Y+4	; 0x04
    3576:	82 8f       	std	Z+26, r24	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1213

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3578:	89 81       	ldd	r24, Y+1	; 0x01
    357a:	8f 3f       	cpi	r24, 0xFF	; 255
    357c:	a9 f4       	brne	.+42     	; 0x35a8 <xQueueGiveFromISR+0x7c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1268
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    357e:	eb 81       	ldd	r30, Y+3	; 0x03
    3580:	fc 81       	ldd	r31, Y+4	; 0x04
    3582:	81 89       	ldd	r24, Z+17	; 0x11
    3584:	88 23       	and	r24, r24
    3586:	a9 f0       	breq	.+42     	; 0x35b2 <xQueueGiveFromISR+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1270
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3588:	8b 81       	ldd	r24, Y+3	; 0x03
    358a:	9c 81       	ldd	r25, Y+4	; 0x04
    358c:	41 96       	adiw	r24, 0x11	; 17
    358e:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3592:	88 23       	and	r24, r24
    3594:	71 f0       	breq	.+28     	; 0x35b2 <xQueueGiveFromISR+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1274
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    3596:	89 85       	ldd	r24, Y+9	; 0x09
    3598:	9a 85       	ldd	r25, Y+10	; 0x0a
    359a:	00 97       	sbiw	r24, 0x00	; 0
    359c:	51 f0       	breq	.+20     	; 0x35b2 <xQueueGiveFromISR+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1276
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    359e:	e9 85       	ldd	r30, Y+9	; 0x09
    35a0:	fa 85       	ldd	r31, Y+10	; 0x0a
    35a2:	81 e0       	ldi	r24, 0x01	; 1
    35a4:	80 83       	st	Z, r24
    35a6:	05 c0       	rjmp	.+10     	; 0x35b2 <xQueueGiveFromISR+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1301
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	8f 5f       	subi	r24, 0xFF	; 255
    35ac:	eb 81       	ldd	r30, Y+3	; 0x03
    35ae:	fc 81       	ldd	r31, Y+4	; 0x04
    35b0:	86 8f       	std	Z+30, r24	; 0x1e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1304
            }

            xReturn = pdPASS;
    35b2:	81 e0       	ldi	r24, 0x01	; 1
    35b4:	8e 83       	std	Y+6, r24	; 0x06
    35b6:	01 c0       	rjmp	.+2      	; 0x35ba <xQueueGiveFromISR+0x8e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1309
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    35b8:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1314
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    35ba:	8e 81       	ldd	r24, Y+6	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1315
}
    35bc:	2a 96       	adiw	r28, 0x0a	; 10
    35be:	0f b6       	in	r0, 0x3f	; 63
    35c0:	f8 94       	cli
    35c2:	de bf       	out	0x3e, r29	; 62
    35c4:	0f be       	out	0x3f, r0	; 63
    35c6:	cd bf       	out	0x3d, r28	; 61
    35c8:	cf 91       	pop	r28
    35ca:	df 91       	pop	r29
    35cc:	08 95       	ret

000035ce <xQueueReceive>:
xQueueReceive():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1321
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    35ce:	df 93       	push	r29
    35d0:	cf 93       	push	r28
    35d2:	cd b7       	in	r28, 0x3d	; 61
    35d4:	de b7       	in	r29, 0x3e	; 62
    35d6:	2e 97       	sbiw	r28, 0x0e	; 14
    35d8:	0f b6       	in	r0, 0x3f	; 63
    35da:	f8 94       	cli
    35dc:	de bf       	out	0x3e, r29	; 62
    35de:	0f be       	out	0x3f, r0	; 63
    35e0:	cd bf       	out	0x3d, r28	; 61
    35e2:	99 87       	std	Y+9, r25	; 0x09
    35e4:	88 87       	std	Y+8, r24	; 0x08
    35e6:	7b 87       	std	Y+11, r23	; 0x0b
    35e8:	6a 87       	std	Y+10, r22	; 0x0a
    35ea:	5d 87       	std	Y+13, r21	; 0x0d
    35ec:	4c 87       	std	Y+12, r20	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1322
    BaseType_t xEntryTimeSet = pdFALSE;
    35ee:	1c 82       	std	Y+4, r1	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1324
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    35f0:	88 85       	ldd	r24, Y+8	; 0x08
    35f2:	99 85       	ldd	r25, Y+9	; 0x09
    35f4:	9b 83       	std	Y+3, r25	; 0x03
    35f6:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1345
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    35f8:	0f b6       	in	r0, 0x3f	; 63
    35fa:	f8 94       	cli
    35fc:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1347
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    35fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3600:	fb 81       	ldd	r31, Y+3	; 0x03
    3602:	82 8d       	ldd	r24, Z+26	; 0x1a
    3604:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1351

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3606:	89 81       	ldd	r24, Y+1	; 0x01
    3608:	88 23       	and	r24, r24
    360a:	f9 f0       	breq	.+62     	; 0x364a <xQueueReceive+0x7c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1354
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    360c:	8a 81       	ldd	r24, Y+2	; 0x02
    360e:	9b 81       	ldd	r25, Y+3	; 0x03
    3610:	2a 85       	ldd	r18, Y+10	; 0x0a
    3612:	3b 85       	ldd	r19, Y+11	; 0x0b
    3614:	b9 01       	movw	r22, r18
    3616:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvCopyDataFromQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1356
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	81 50       	subi	r24, 0x01	; 1
    361e:	ea 81       	ldd	r30, Y+2	; 0x02
    3620:	fb 81       	ldd	r31, Y+3	; 0x03
    3622:	82 8f       	std	Z+26, r24	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1361

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3624:	ea 81       	ldd	r30, Y+2	; 0x02
    3626:	fb 81       	ldd	r31, Y+3	; 0x03
    3628:	80 85       	ldd	r24, Z+8	; 0x08
    362a:	88 23       	and	r24, r24
    362c:	49 f0       	breq	.+18     	; 0x3640 <xQueueReceive+0x72>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1363
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    362e:	8a 81       	ldd	r24, Y+2	; 0x02
    3630:	9b 81       	ldd	r25, Y+3	; 0x03
    3632:	08 96       	adiw	r24, 0x08	; 8
    3634:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3638:	88 23       	and	r24, r24
    363a:	11 f0       	breq	.+4      	; 0x3640 <xQueueReceive+0x72>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1365
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    363c:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1377
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3640:	0f 90       	pop	r0
    3642:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1378
                return pdPASS;
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	8e 87       	std	Y+14, r24	; 0x0e
    3648:	63 c0       	rjmp	.+198    	; 0x3710 <xQueueReceive+0x142>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1382
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    364a:	8c 85       	ldd	r24, Y+12	; 0x0c
    364c:	9d 85       	ldd	r25, Y+13	; 0x0d
    364e:	00 97       	sbiw	r24, 0x00	; 0
    3650:	21 f4       	brne	.+8      	; 0x365a <xQueueReceive+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1386
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3652:	0f 90       	pop	r0
    3654:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1388
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3656:	1e 86       	std	Y+14, r1	; 0x0e
    3658:	5b c0       	rjmp	.+182    	; 0x3710 <xQueueReceive+0x142>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1390
                }
                else if( xEntryTimeSet == pdFALSE )
    365a:	8c 81       	ldd	r24, Y+4	; 0x04
    365c:	88 23       	and	r24, r24
    365e:	31 f4       	brne	.+12     	; 0x366c <xQueueReceive+0x9e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1394
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3660:	ce 01       	movw	r24, r28
    3662:	05 96       	adiw	r24, 0x05	; 5
    3664:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskInternalSetTimeOutState>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1395
                    xEntryTimeSet = pdTRUE;
    3668:	81 e0       	ldi	r24, 0x01	; 1
    366a:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1404
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    366c:	0f 90       	pop	r0
    366e:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1409

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3670:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1410
        prvLockQueue( pxQueue );
    3674:	0f b6       	in	r0, 0x3f	; 63
    3676:	f8 94       	cli
    3678:	0f 92       	push	r0
    367a:	ea 81       	ldd	r30, Y+2	; 0x02
    367c:	fb 81       	ldd	r31, Y+3	; 0x03
    367e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3680:	8f 3f       	cpi	r24, 0xFF	; 255
    3682:	19 f4       	brne	.+6      	; 0x368a <xQueueReceive+0xbc>
    3684:	ea 81       	ldd	r30, Y+2	; 0x02
    3686:	fb 81       	ldd	r31, Y+3	; 0x03
    3688:	15 8e       	std	Z+29, r1	; 0x1d
    368a:	ea 81       	ldd	r30, Y+2	; 0x02
    368c:	fb 81       	ldd	r31, Y+3	; 0x03
    368e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3690:	8f 3f       	cpi	r24, 0xFF	; 255
    3692:	19 f4       	brne	.+6      	; 0x369a <xQueueReceive+0xcc>
    3694:	ea 81       	ldd	r30, Y+2	; 0x02
    3696:	fb 81       	ldd	r31, Y+3	; 0x03
    3698:	16 8e       	std	Z+30, r1	; 0x1e
    369a:	0f 90       	pop	r0
    369c:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1413

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    369e:	ce 01       	movw	r24, r28
    36a0:	05 96       	adiw	r24, 0x05	; 5
    36a2:	9e 01       	movw	r18, r28
    36a4:	24 5f       	subi	r18, 0xF4	; 244
    36a6:	3f 4f       	sbci	r19, 0xFF	; 255
    36a8:	b9 01       	movw	r22, r18
    36aa:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <xTaskCheckForTimeOut>
    36ae:	88 23       	and	r24, r24
    36b0:	09 f5       	brne	.+66     	; 0x36f4 <xQueueReceive+0x126>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1417
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36b2:	8a 81       	ldd	r24, Y+2	; 0x02
    36b4:	9b 81       	ldd	r25, Y+3	; 0x03
    36b6:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    36ba:	88 23       	and	r24, r24
    36bc:	a1 f0       	breq	.+40     	; 0x36e6 <xQueueReceive+0x118>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1420
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    36be:	8a 81       	ldd	r24, Y+2	; 0x02
    36c0:	9b 81       	ldd	r25, Y+3	; 0x03
    36c2:	41 96       	adiw	r24, 0x11	; 17
    36c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    36c6:	3d 85       	ldd	r19, Y+13	; 0x0d
    36c8:	b9 01       	movw	r22, r18
    36ca:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <vTaskPlaceOnEventList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1421
                prvUnlockQueue( pxQueue );
    36ce:	8a 81       	ldd	r24, Y+2	; 0x02
    36d0:	9b 81       	ldd	r25, Y+3	; 0x03
    36d2:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1423

                if( xTaskResumeAll() == pdFALSE )
    36d6:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    36da:	88 23       	and	r24, r24
    36dc:	09 f0       	breq	.+2      	; 0x36e0 <xQueueReceive+0x112>
    36de:	8c cf       	rjmp	.-232    	; 0x35f8 <xQueueReceive+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1425
                {
                    portYIELD_WITHIN_API();
    36e0:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    36e4:	89 cf       	rjmp	.-238    	; 0x35f8 <xQueueReceive+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1436
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    36e6:	8a 81       	ldd	r24, Y+2	; 0x02
    36e8:	9b 81       	ldd	r25, Y+3	; 0x03
    36ea:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1437
                ( void ) xTaskResumeAll();
    36ee:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    36f2:	82 cf       	rjmp	.-252    	; 0x35f8 <xQueueReceive+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1444
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    36f4:	8a 81       	ldd	r24, Y+2	; 0x02
    36f6:	9b 81       	ldd	r25, Y+3	; 0x03
    36f8:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1445
            ( void ) xTaskResumeAll();
    36fc:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1447

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3700:	8a 81       	ldd	r24, Y+2	; 0x02
    3702:	9b 81       	ldd	r25, Y+3	; 0x03
    3704:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    3708:	88 23       	and	r24, r24
    370a:	09 f4       	brne	.+2      	; 0x370e <xQueueReceive+0x140>
    370c:	75 cf       	rjmp	.-278    	; 0x35f8 <xQueueReceive+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1450
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    370e:	1e 86       	std	Y+14, r1	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1457
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3710:	8e 85       	ldd	r24, Y+14	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1458
}
    3712:	2e 96       	adiw	r28, 0x0e	; 14
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	de bf       	out	0x3e, r29	; 62
    371a:	0f be       	out	0x3f, r0	; 63
    371c:	cd bf       	out	0x3d, r28	; 61
    371e:	cf 91       	pop	r28
    3720:	df 91       	pop	r29
    3722:	08 95       	ret

00003724 <xQueueSemaphoreTake>:
xQueueSemaphoreTake():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1463
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    3724:	df 93       	push	r29
    3726:	cf 93       	push	r28
    3728:	cd b7       	in	r28, 0x3d	; 61
    372a:	de b7       	in	r29, 0x3e	; 62
    372c:	2e 97       	sbiw	r28, 0x0e	; 14
    372e:	0f b6       	in	r0, 0x3f	; 63
    3730:	f8 94       	cli
    3732:	de bf       	out	0x3e, r29	; 62
    3734:	0f be       	out	0x3f, r0	; 63
    3736:	cd bf       	out	0x3d, r28	; 61
    3738:	9b 87       	std	Y+11, r25	; 0x0b
    373a:	8a 87       	std	Y+10, r24	; 0x0a
    373c:	7d 87       	std	Y+13, r23	; 0x0d
    373e:	6c 87       	std	Y+12, r22	; 0x0c
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1464
    BaseType_t xEntryTimeSet = pdFALSE;
    3740:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1466
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3742:	8a 85       	ldd	r24, Y+10	; 0x0a
    3744:	9b 85       	ldd	r25, Y+11	; 0x0b
    3746:	9d 83       	std	Y+5, r25	; 0x05
    3748:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1469

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    374a:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1491
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    374c:	0f b6       	in	r0, 0x3f	; 63
    374e:	f8 94       	cli
    3750:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1495
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3752:	ec 81       	ldd	r30, Y+4	; 0x04
    3754:	fd 81       	ldd	r31, Y+5	; 0x05
    3756:	82 8d       	ldd	r24, Z+26	; 0x1a
    3758:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1499

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    375a:	8a 81       	ldd	r24, Y+2	; 0x02
    375c:	88 23       	and	r24, r24
    375e:	21 f1       	breq	.+72     	; 0x37a8 <xQueueSemaphoreTake+0x84>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1505
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3760:	8a 81       	ldd	r24, Y+2	; 0x02
    3762:	81 50       	subi	r24, 0x01	; 1
    3764:	ec 81       	ldd	r30, Y+4	; 0x04
    3766:	fd 81       	ldd	r31, Y+5	; 0x05
    3768:	82 8f       	std	Z+26, r24	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1509

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    376a:	ec 81       	ldd	r30, Y+4	; 0x04
    376c:	fd 81       	ldd	r31, Y+5	; 0x05
    376e:	80 81       	ld	r24, Z
    3770:	91 81       	ldd	r25, Z+1	; 0x01
    3772:	00 97       	sbiw	r24, 0x00	; 0
    3774:	31 f4       	brne	.+12     	; 0x3782 <xQueueSemaphoreTake+0x5e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1513
                        {
                            /* Record the information required to implement
                             * priority inheritance should it become necessary. */
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    3776:	0e 94 fe 11 	call	0x23fc	; 0x23fc <pvTaskIncrementMutexHeldCount>
    377a:	ec 81       	ldd	r30, Y+4	; 0x04
    377c:	fd 81       	ldd	r31, Y+5	; 0x05
    377e:	95 83       	std	Z+5, r25	; 0x05
    3780:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1524
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3782:	ec 81       	ldd	r30, Y+4	; 0x04
    3784:	fd 81       	ldd	r31, Y+5	; 0x05
    3786:	80 85       	ldd	r24, Z+8	; 0x08
    3788:	88 23       	and	r24, r24
    378a:	49 f0       	breq	.+18     	; 0x379e <xQueueSemaphoreTake+0x7a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1526
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    378c:	8c 81       	ldd	r24, Y+4	; 0x04
    378e:	9d 81       	ldd	r25, Y+5	; 0x05
    3790:	08 96       	adiw	r24, 0x08	; 8
    3792:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3796:	88 23       	and	r24, r24
    3798:	11 f0       	breq	.+4      	; 0x379e <xQueueSemaphoreTake+0x7a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1528
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    379a:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1540
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    379e:	0f 90       	pop	r0
    37a0:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1541
                return pdPASS;
    37a2:	81 e0       	ldi	r24, 0x01	; 1
    37a4:	8e 87       	std	Y+14, r24	; 0x0e
    37a6:	89 c0       	rjmp	.+274    	; 0x38ba <xQueueSemaphoreTake+0x196>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1545
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    37a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    37aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    37ac:	00 97       	sbiw	r24, 0x00	; 0
    37ae:	21 f4       	brne	.+8      	; 0x37b8 <xQueueSemaphoreTake+0x94>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1558
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    37b0:	0f 90       	pop	r0
    37b2:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1560
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    37b4:	1e 86       	std	Y+14, r1	; 0x0e
    37b6:	81 c0       	rjmp	.+258    	; 0x38ba <xQueueSemaphoreTake+0x196>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1562
                }
                else if( xEntryTimeSet == pdFALSE )
    37b8:	8e 81       	ldd	r24, Y+6	; 0x06
    37ba:	88 23       	and	r24, r24
    37bc:	31 f4       	brne	.+12     	; 0x37ca <xQueueSemaphoreTake+0xa6>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1566
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    37be:	ce 01       	movw	r24, r28
    37c0:	07 96       	adiw	r24, 0x07	; 7
    37c2:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskInternalSetTimeOutState>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1567
                    xEntryTimeSet = pdTRUE;
    37c6:	81 e0       	ldi	r24, 0x01	; 1
    37c8:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1576
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    37ca:	0f 90       	pop	r0
    37cc:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1581

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    37ce:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1582
        prvLockQueue( pxQueue );
    37d2:	0f b6       	in	r0, 0x3f	; 63
    37d4:	f8 94       	cli
    37d6:	0f 92       	push	r0
    37d8:	ec 81       	ldd	r30, Y+4	; 0x04
    37da:	fd 81       	ldd	r31, Y+5	; 0x05
    37dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    37de:	8f 3f       	cpi	r24, 0xFF	; 255
    37e0:	19 f4       	brne	.+6      	; 0x37e8 <xQueueSemaphoreTake+0xc4>
    37e2:	ec 81       	ldd	r30, Y+4	; 0x04
    37e4:	fd 81       	ldd	r31, Y+5	; 0x05
    37e6:	15 8e       	std	Z+29, r1	; 0x1d
    37e8:	ec 81       	ldd	r30, Y+4	; 0x04
    37ea:	fd 81       	ldd	r31, Y+5	; 0x05
    37ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    37ee:	8f 3f       	cpi	r24, 0xFF	; 255
    37f0:	19 f4       	brne	.+6      	; 0x37f8 <xQueueSemaphoreTake+0xd4>
    37f2:	ec 81       	ldd	r30, Y+4	; 0x04
    37f4:	fd 81       	ldd	r31, Y+5	; 0x05
    37f6:	16 8e       	std	Z+30, r1	; 0x1e
    37f8:	0f 90       	pop	r0
    37fa:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1585

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    37fc:	ce 01       	movw	r24, r28
    37fe:	07 96       	adiw	r24, 0x07	; 7
    3800:	9e 01       	movw	r18, r28
    3802:	24 5f       	subi	r18, 0xF4	; 244
    3804:	3f 4f       	sbci	r19, 0xFF	; 255
    3806:	b9 01       	movw	r22, r18
    3808:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <xTaskCheckForTimeOut>
    380c:	88 23       	and	r24, r24
    380e:	99 f5       	brne	.+102    	; 0x3876 <xQueueSemaphoreTake+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1591
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3810:	8c 81       	ldd	r24, Y+4	; 0x04
    3812:	9d 81       	ldd	r25, Y+5	; 0x05
    3814:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    3818:	88 23       	and	r24, r24
    381a:	31 f1       	breq	.+76     	; 0x3868 <xQueueSemaphoreTake+0x144>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1597
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                    {
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    381c:	ec 81       	ldd	r30, Y+4	; 0x04
    381e:	fd 81       	ldd	r31, Y+5	; 0x05
    3820:	80 81       	ld	r24, Z
    3822:	91 81       	ldd	r25, Z+1	; 0x01
    3824:	00 97       	sbiw	r24, 0x00	; 0
    3826:	61 f4       	brne	.+24     	; 0x3840 <xQueueSemaphoreTake+0x11c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1599
                        {
                            taskENTER_CRITICAL();
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	f8 94       	cli
    382c:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1601
                            {
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    382e:	ec 81       	ldd	r30, Y+4	; 0x04
    3830:	fd 81       	ldd	r31, Y+5	; 0x05
    3832:	84 81       	ldd	r24, Z+4	; 0x04
    3834:	95 81       	ldd	r25, Z+5	; 0x05
    3836:	0e 94 32 10 	call	0x2064	; 0x2064 <xTaskPriorityInherit>
    383a:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1603
                            }
                            taskEXIT_CRITICAL();
    383c:	0f 90       	pop	r0
    383e:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1612
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3840:	8c 81       	ldd	r24, Y+4	; 0x04
    3842:	9d 81       	ldd	r25, Y+5	; 0x05
    3844:	41 96       	adiw	r24, 0x11	; 17
    3846:	2c 85       	ldd	r18, Y+12	; 0x0c
    3848:	3d 85       	ldd	r19, Y+13	; 0x0d
    384a:	b9 01       	movw	r22, r18
    384c:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <vTaskPlaceOnEventList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1613
                prvUnlockQueue( pxQueue );
    3850:	8c 81       	ldd	r24, Y+4	; 0x04
    3852:	9d 81       	ldd	r25, Y+5	; 0x05
    3854:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1615

                if( xTaskResumeAll() == pdFALSE )
    3858:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    385c:	88 23       	and	r24, r24
    385e:	09 f0       	breq	.+2      	; 0x3862 <xQueueSemaphoreTake+0x13e>
    3860:	75 cf       	rjmp	.-278    	; 0x374c <xQueueSemaphoreTake+0x28>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1617
                {
                    portYIELD_WITHIN_API();
    3862:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    3866:	72 cf       	rjmp	.-284    	; 0x374c <xQueueSemaphoreTake+0x28>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1628
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    3868:	8c 81       	ldd	r24, Y+4	; 0x04
    386a:	9d 81       	ldd	r25, Y+5	; 0x05
    386c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1629
                ( void ) xTaskResumeAll();
    3870:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    3874:	6b cf       	rjmp	.-298    	; 0x374c <xQueueSemaphoreTake+0x28>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1635
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3876:	8c 81       	ldd	r24, Y+4	; 0x04
    3878:	9d 81       	ldd	r25, Y+5	; 0x05
    387a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1636
            ( void ) xTaskResumeAll();
    387e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1642

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3882:	8c 81       	ldd	r24, Y+4	; 0x04
    3884:	9d 81       	ldd	r25, Y+5	; 0x05
    3886:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    388a:	88 23       	and	r24, r24
    388c:	09 f4       	brne	.+2      	; 0x3890 <xQueueSemaphoreTake+0x16c>
    388e:	5e cf       	rjmp	.-324    	; 0x374c <xQueueSemaphoreTake+0x28>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1649
                #if ( configUSE_MUTEXES == 1 )
                    {
                        /* xInheritanceOccurred could only have be set if
                         * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                         * test the mutex type again to check it is actually a mutex. */
                        if( xInheritanceOccurred != pdFALSE )
    3890:	8b 81       	ldd	r24, Y+3	; 0x03
    3892:	88 23       	and	r24, r24
    3894:	89 f0       	breq	.+34     	; 0x38b8 <xQueueSemaphoreTake+0x194>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1651
                        {
                            taskENTER_CRITICAL();
    3896:	0f b6       	in	r0, 0x3f	; 63
    3898:	f8 94       	cli
    389a:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1660
                                /* This task blocking on the mutex caused another
                                 * task to inherit this task's priority.  Now this task
                                 * has timed out the priority should be disinherited
                                 * again, but only as low as the next highest priority
                                 * task that is waiting for the same mutex. */
                                uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    389c:	8c 81       	ldd	r24, Y+4	; 0x04
    389e:	9d 81       	ldd	r25, Y+5	; 0x05
    38a0:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvGetDisinheritPriorityAfterTimeout>
    38a4:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1661
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    38a6:	ec 81       	ldd	r30, Y+4	; 0x04
    38a8:	fd 81       	ldd	r31, Y+5	; 0x05
    38aa:	84 81       	ldd	r24, Z+4	; 0x04
    38ac:	95 81       	ldd	r25, Z+5	; 0x05
    38ae:	69 81       	ldd	r22, Y+1	; 0x01
    38b0:	0e 94 42 11 	call	0x2284	; 0x2284 <vTaskPriorityDisinheritAfterTimeout>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1663
                            }
                            taskEXIT_CRITICAL();
    38b4:	0f 90       	pop	r0
    38b6:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1669
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    38b8:	1e 86       	std	Y+14, r1	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1676
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    38ba:	8e 85       	ldd	r24, Y+14	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1677
}
    38bc:	2e 96       	adiw	r28, 0x0e	; 14
    38be:	0f b6       	in	r0, 0x3f	; 63
    38c0:	f8 94       	cli
    38c2:	de bf       	out	0x3e, r29	; 62
    38c4:	0f be       	out	0x3f, r0	; 63
    38c6:	cd bf       	out	0x3d, r28	; 61
    38c8:	cf 91       	pop	r28
    38ca:	df 91       	pop	r29
    38cc:	08 95       	ret

000038ce <xQueuePeek>:
xQueuePeek():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1683
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    38ce:	df 93       	push	r29
    38d0:	cf 93       	push	r28
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62
    38d6:	60 97       	sbiw	r28, 0x10	; 16
    38d8:	0f b6       	in	r0, 0x3f	; 63
    38da:	f8 94       	cli
    38dc:	de bf       	out	0x3e, r29	; 62
    38de:	0f be       	out	0x3f, r0	; 63
    38e0:	cd bf       	out	0x3d, r28	; 61
    38e2:	9b 87       	std	Y+11, r25	; 0x0b
    38e4:	8a 87       	std	Y+10, r24	; 0x0a
    38e6:	7d 87       	std	Y+13, r23	; 0x0d
    38e8:	6c 87       	std	Y+12, r22	; 0x0c
    38ea:	5f 87       	std	Y+15, r21	; 0x0f
    38ec:	4e 87       	std	Y+14, r20	; 0x0e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1684
    BaseType_t xEntryTimeSet = pdFALSE;
    38ee:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1687
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    38f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    38f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    38f4:	9b 83       	std	Y+3, r25	; 0x03
    38f6:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1708
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1710
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    38fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3900:	fb 81       	ldd	r31, Y+3	; 0x03
    3902:	82 8d       	ldd	r24, Z+26	; 0x1a
    3904:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1714

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3906:	89 81       	ldd	r24, Y+1	; 0x01
    3908:	88 23       	and	r24, r24
    390a:	31 f1       	breq	.+76     	; 0x3958 <xQueuePeek+0x8a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1719
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    390c:	ea 81       	ldd	r30, Y+2	; 0x02
    390e:	fb 81       	ldd	r31, Y+3	; 0x03
    3910:	86 81       	ldd	r24, Z+6	; 0x06
    3912:	97 81       	ldd	r25, Z+7	; 0x07
    3914:	9d 83       	std	Y+5, r25	; 0x05
    3916:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1721

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3918:	8a 81       	ldd	r24, Y+2	; 0x02
    391a:	9b 81       	ldd	r25, Y+3	; 0x03
    391c:	2c 85       	ldd	r18, Y+12	; 0x0c
    391e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3920:	b9 01       	movw	r22, r18
    3922:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvCopyDataFromQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1725
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3926:	ea 81       	ldd	r30, Y+2	; 0x02
    3928:	fb 81       	ldd	r31, Y+3	; 0x03
    392a:	8c 81       	ldd	r24, Y+4	; 0x04
    392c:	9d 81       	ldd	r25, Y+5	; 0x05
    392e:	97 83       	std	Z+7, r25	; 0x07
    3930:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1729

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3932:	ea 81       	ldd	r30, Y+2	; 0x02
    3934:	fb 81       	ldd	r31, Y+3	; 0x03
    3936:	81 89       	ldd	r24, Z+17	; 0x11
    3938:	88 23       	and	r24, r24
    393a:	49 f0       	breq	.+18     	; 0x394e <xQueuePeek+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1731
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    393c:	8a 81       	ldd	r24, Y+2	; 0x02
    393e:	9b 81       	ldd	r25, Y+3	; 0x03
    3940:	41 96       	adiw	r24, 0x11	; 17
    3942:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3946:	88 23       	and	r24, r24
    3948:	11 f0       	breq	.+4      	; 0x394e <xQueuePeek+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1734
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    394a:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1746
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    394e:	0f 90       	pop	r0
    3950:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1747
                return pdPASS;
    3952:	81 e0       	ldi	r24, 0x01	; 1
    3954:	88 8b       	std	Y+16, r24	; 0x10
    3956:	63 c0       	rjmp	.+198    	; 0x3a1e <xQueuePeek+0x150>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1751
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3958:	8e 85       	ldd	r24, Y+14	; 0x0e
    395a:	9f 85       	ldd	r25, Y+15	; 0x0f
    395c:	00 97       	sbiw	r24, 0x00	; 0
    395e:	21 f4       	brne	.+8      	; 0x3968 <xQueuePeek+0x9a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1755
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3960:	0f 90       	pop	r0
    3962:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1757
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3964:	18 8a       	std	Y+16, r1	; 0x10
    3966:	5b c0       	rjmp	.+182    	; 0x3a1e <xQueuePeek+0x150>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1759
                }
                else if( xEntryTimeSet == pdFALSE )
    3968:	8e 81       	ldd	r24, Y+6	; 0x06
    396a:	88 23       	and	r24, r24
    396c:	31 f4       	brne	.+12     	; 0x397a <xQueuePeek+0xac>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1764
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    396e:	ce 01       	movw	r24, r28
    3970:	07 96       	adiw	r24, 0x07	; 7
    3972:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskInternalSetTimeOutState>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1765
                    xEntryTimeSet = pdTRUE;
    3976:	81 e0       	ldi	r24, 0x01	; 1
    3978:	8e 83       	std	Y+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1774
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    397a:	0f 90       	pop	r0
    397c:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1779

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    397e:	0e 94 b7 0a 	call	0x156e	; 0x156e <vTaskSuspendAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1780
        prvLockQueue( pxQueue );
    3982:	0f b6       	in	r0, 0x3f	; 63
    3984:	f8 94       	cli
    3986:	0f 92       	push	r0
    3988:	ea 81       	ldd	r30, Y+2	; 0x02
    398a:	fb 81       	ldd	r31, Y+3	; 0x03
    398c:	85 8d       	ldd	r24, Z+29	; 0x1d
    398e:	8f 3f       	cpi	r24, 0xFF	; 255
    3990:	19 f4       	brne	.+6      	; 0x3998 <xQueuePeek+0xca>
    3992:	ea 81       	ldd	r30, Y+2	; 0x02
    3994:	fb 81       	ldd	r31, Y+3	; 0x03
    3996:	15 8e       	std	Z+29, r1	; 0x1d
    3998:	ea 81       	ldd	r30, Y+2	; 0x02
    399a:	fb 81       	ldd	r31, Y+3	; 0x03
    399c:	86 8d       	ldd	r24, Z+30	; 0x1e
    399e:	8f 3f       	cpi	r24, 0xFF	; 255
    39a0:	19 f4       	brne	.+6      	; 0x39a8 <xQueuePeek+0xda>
    39a2:	ea 81       	ldd	r30, Y+2	; 0x02
    39a4:	fb 81       	ldd	r31, Y+3	; 0x03
    39a6:	16 8e       	std	Z+30, r1	; 0x1e
    39a8:	0f 90       	pop	r0
    39aa:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1783

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    39ac:	ce 01       	movw	r24, r28
    39ae:	07 96       	adiw	r24, 0x07	; 7
    39b0:	9e 01       	movw	r18, r28
    39b2:	22 5f       	subi	r18, 0xF2	; 242
    39b4:	3f 4f       	sbci	r19, 0xFF	; 255
    39b6:	b9 01       	movw	r22, r18
    39b8:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <xTaskCheckForTimeOut>
    39bc:	88 23       	and	r24, r24
    39be:	09 f5       	brne	.+66     	; 0x3a02 <xQueuePeek+0x134>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1787
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    39c0:	8a 81       	ldd	r24, Y+2	; 0x02
    39c2:	9b 81       	ldd	r25, Y+3	; 0x03
    39c4:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    39c8:	88 23       	and	r24, r24
    39ca:	a1 f0       	breq	.+40     	; 0x39f4 <xQueuePeek+0x126>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1790
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    39cc:	8a 81       	ldd	r24, Y+2	; 0x02
    39ce:	9b 81       	ldd	r25, Y+3	; 0x03
    39d0:	41 96       	adiw	r24, 0x11	; 17
    39d2:	2e 85       	ldd	r18, Y+14	; 0x0e
    39d4:	3f 85       	ldd	r19, Y+15	; 0x0f
    39d6:	b9 01       	movw	r22, r18
    39d8:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <vTaskPlaceOnEventList>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1791
                prvUnlockQueue( pxQueue );
    39dc:	8a 81       	ldd	r24, Y+2	; 0x02
    39de:	9b 81       	ldd	r25, Y+3	; 0x03
    39e0:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1793

                if( xTaskResumeAll() == pdFALSE )
    39e4:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    39e8:	88 23       	and	r24, r24
    39ea:	09 f0       	breq	.+2      	; 0x39ee <xQueuePeek+0x120>
    39ec:	85 cf       	rjmp	.-246    	; 0x38f8 <xQueuePeek+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1795
                {
                    portYIELD_WITHIN_API();
    39ee:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <vPortYield>
    39f2:	82 cf       	rjmp	.-252    	; 0x38f8 <xQueuePeek+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1806
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    39f4:	8a 81       	ldd	r24, Y+2	; 0x02
    39f6:	9b 81       	ldd	r25, Y+3	; 0x03
    39f8:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1807
                ( void ) xTaskResumeAll();
    39fc:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
    3a00:	7b cf       	rjmp	.-266    	; 0x38f8 <xQueuePeek+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1814
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3a02:	8a 81       	ldd	r24, Y+2	; 0x02
    3a04:	9b 81       	ldd	r25, Y+3	; 0x03
    3a06:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <prvUnlockQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1815
            ( void ) xTaskResumeAll();
    3a0a:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1817

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a10:	9b 81       	ldd	r25, Y+3	; 0x03
    3a12:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvIsQueueEmpty>
    3a16:	88 23       	and	r24, r24
    3a18:	09 f4       	brne	.+2      	; 0x3a1c <xQueuePeek+0x14e>
    3a1a:	6e cf       	rjmp	.-292    	; 0x38f8 <xQueuePeek+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1820
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3a1c:	18 8a       	std	Y+16, r1	; 0x10
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1827
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3a1e:	88 89       	ldd	r24, Y+16	; 0x10
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1828
}
    3a20:	60 96       	adiw	r28, 0x10	; 16
    3a22:	0f b6       	in	r0, 0x3f	; 63
    3a24:	f8 94       	cli
    3a26:	de bf       	out	0x3e, r29	; 62
    3a28:	0f be       	out	0x3f, r0	; 63
    3a2a:	cd bf       	out	0x3d, r28	; 61
    3a2c:	cf 91       	pop	r28
    3a2e:	df 91       	pop	r29
    3a30:	08 95       	ret

00003a32 <xQueueReceiveFromISR>:
xQueueReceiveFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1834
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3a32:	df 93       	push	r29
    3a34:	cf 93       	push	r28
    3a36:	cd b7       	in	r28, 0x3d	; 61
    3a38:	de b7       	in	r29, 0x3e	; 62
    3a3a:	2c 97       	sbiw	r28, 0x0c	; 12
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	de bf       	out	0x3e, r29	; 62
    3a42:	0f be       	out	0x3f, r0	; 63
    3a44:	cd bf       	out	0x3d, r28	; 61
    3a46:	98 87       	std	Y+8, r25	; 0x08
    3a48:	8f 83       	std	Y+7, r24	; 0x07
    3a4a:	7a 87       	std	Y+10, r23	; 0x0a
    3a4c:	69 87       	std	Y+9, r22	; 0x09
    3a4e:	5c 87       	std	Y+12, r21	; 0x0c
    3a50:	4b 87       	std	Y+11, r20	; 0x0b
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1837
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3a52:	8f 81       	ldd	r24, Y+7	; 0x07
    3a54:	98 85       	ldd	r25, Y+8	; 0x08
    3a56:	9c 83       	std	Y+4, r25	; 0x04
    3a58:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1858
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a5a:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1860
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a60:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a62:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1863

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a64:	8a 81       	ldd	r24, Y+2	; 0x02
    3a66:	88 23       	and	r24, r24
    3a68:	81 f1       	breq	.+96     	; 0x3aca <xQueueReceiveFromISR+0x98>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1865
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a6e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a70:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1869

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3a72:	8b 81       	ldd	r24, Y+3	; 0x03
    3a74:	9c 81       	ldd	r25, Y+4	; 0x04
    3a76:	29 85       	ldd	r18, Y+9	; 0x09
    3a78:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a7a:	b9 01       	movw	r22, r18
    3a7c:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvCopyDataFromQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1870
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3a80:	8a 81       	ldd	r24, Y+2	; 0x02
    3a82:	81 50       	subi	r24, 0x01	; 1
    3a84:	eb 81       	ldd	r30, Y+3	; 0x03
    3a86:	fc 81       	ldd	r31, Y+4	; 0x04
    3a88:	82 8f       	std	Z+26, r24	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1876

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3a8a:	89 81       	ldd	r24, Y+1	; 0x01
    3a8c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a8e:	a9 f4       	brne	.+42     	; 0x3aba <xQueueReceiveFromISR+0x88>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1878
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3a90:	eb 81       	ldd	r30, Y+3	; 0x03
    3a92:	fc 81       	ldd	r31, Y+4	; 0x04
    3a94:	80 85       	ldd	r24, Z+8	; 0x08
    3a96:	88 23       	and	r24, r24
    3a98:	a9 f0       	breq	.+42     	; 0x3ac4 <xQueueReceiveFromISR+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1880
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a9e:	08 96       	adiw	r24, 0x08	; 8
    3aa0:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3aa4:	88 23       	and	r24, r24
    3aa6:	71 f0       	breq	.+28     	; 0x3ac4 <xQueueReceiveFromISR+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1884
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    3aa8:	8b 85       	ldd	r24, Y+11	; 0x0b
    3aaa:	9c 85       	ldd	r25, Y+12	; 0x0c
    3aac:	00 97       	sbiw	r24, 0x00	; 0
    3aae:	51 f0       	breq	.+20     	; 0x3ac4 <xQueueReceiveFromISR+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1886
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    3ab0:	eb 85       	ldd	r30, Y+11	; 0x0b
    3ab2:	fc 85       	ldd	r31, Y+12	; 0x0c
    3ab4:	81 e0       	ldi	r24, 0x01	; 1
    3ab6:	80 83       	st	Z, r24
    3ab8:	05 c0       	rjmp	.+10     	; 0x3ac4 <xQueueReceiveFromISR+0x92>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1909
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3aba:	89 81       	ldd	r24, Y+1	; 0x01
    3abc:	8f 5f       	subi	r24, 0xFF	; 255
    3abe:	eb 81       	ldd	r30, Y+3	; 0x03
    3ac0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ac2:	85 8f       	std	Z+29, r24	; 0x1d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1912
            }

            xReturn = pdPASS;
    3ac4:	81 e0       	ldi	r24, 0x01	; 1
    3ac6:	8e 83       	std	Y+6, r24	; 0x06
    3ac8:	01 c0       	rjmp	.+2      	; 0x3acc <xQueueReceiveFromISR+0x9a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1916
        }
        else
        {
            xReturn = pdFAIL;
    3aca:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1922
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3acc:	8e 81       	ldd	r24, Y+6	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1923
}
    3ace:	2c 96       	adiw	r28, 0x0c	; 12
    3ad0:	0f b6       	in	r0, 0x3f	; 63
    3ad2:	f8 94       	cli
    3ad4:	de bf       	out	0x3e, r29	; 62
    3ad6:	0f be       	out	0x3f, r0	; 63
    3ad8:	cd bf       	out	0x3d, r28	; 61
    3ada:	cf 91       	pop	r28
    3adc:	df 91       	pop	r29
    3ade:	08 95       	ret

00003ae0 <xQueuePeekFromISR>:
xQueuePeekFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1928
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3ae0:	df 93       	push	r29
    3ae2:	cf 93       	push	r28
    3ae4:	cd b7       	in	r28, 0x3d	; 61
    3ae6:	de b7       	in	r29, 0x3e	; 62
    3ae8:	2a 97       	sbiw	r28, 0x0a	; 10
    3aea:	0f b6       	in	r0, 0x3f	; 63
    3aec:	f8 94       	cli
    3aee:	de bf       	out	0x3e, r29	; 62
    3af0:	0f be       	out	0x3f, r0	; 63
    3af2:	cd bf       	out	0x3d, r28	; 61
    3af4:	98 87       	std	Y+8, r25	; 0x08
    3af6:	8f 83       	std	Y+7, r24	; 0x07
    3af8:	7a 87       	std	Y+10, r23	; 0x0a
    3afa:	69 87       	std	Y+9, r22	; 0x09
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1932
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    3afc:	8f 81       	ldd	r24, Y+7	; 0x07
    3afe:	98 85       	ldd	r25, Y+8	; 0x08
    3b00:	9a 83       	std	Y+2, r25	; 0x02
    3b02:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1954
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b04:	1d 82       	std	Y+5, r1	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1957
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b06:	e9 81       	ldd	r30, Y+1	; 0x01
    3b08:	fa 81       	ldd	r31, Y+2	; 0x02
    3b0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b0c:	88 23       	and	r24, r24
    3b0e:	b1 f0       	breq	.+44     	; 0x3b3c <xQueuePeekFromISR+0x5c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1963
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3b10:	e9 81       	ldd	r30, Y+1	; 0x01
    3b12:	fa 81       	ldd	r31, Y+2	; 0x02
    3b14:	86 81       	ldd	r24, Z+6	; 0x06
    3b16:	97 81       	ldd	r25, Z+7	; 0x07
    3b18:	9c 83       	std	Y+4, r25	; 0x04
    3b1a:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1964
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b1c:	89 81       	ldd	r24, Y+1	; 0x01
    3b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b20:	29 85       	ldd	r18, Y+9	; 0x09
    3b22:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b24:	b9 01       	movw	r22, r18
    3b26:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <prvCopyDataFromQueue>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1965
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3b2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b30:	9c 81       	ldd	r25, Y+4	; 0x04
    3b32:	97 83       	std	Z+7, r25	; 0x07
    3b34:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1967

            xReturn = pdPASS;
    3b36:	81 e0       	ldi	r24, 0x01	; 1
    3b38:	8e 83       	std	Y+6, r24	; 0x06
    3b3a:	01 c0       	rjmp	.+2      	; 0x3b3e <xQueuePeekFromISR+0x5e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1971
        }
        else
        {
            xReturn = pdFAIL;
    3b3c:	1e 82       	std	Y+6, r1	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1977
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3b3e:	8e 81       	ldd	r24, Y+6	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1978
}
    3b40:	2a 96       	adiw	r28, 0x0a	; 10
    3b42:	0f b6       	in	r0, 0x3f	; 63
    3b44:	f8 94       	cli
    3b46:	de bf       	out	0x3e, r29	; 62
    3b48:	0f be       	out	0x3f, r0	; 63
    3b4a:	cd bf       	out	0x3d, r28	; 61
    3b4c:	cf 91       	pop	r28
    3b4e:	df 91       	pop	r29
    3b50:	08 95       	ret

00003b52 <uxQueueMessagesWaiting>:
uxQueueMessagesWaiting():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1982
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3b52:	df 93       	push	r29
    3b54:	cf 93       	push	r28
    3b56:	00 d0       	rcall	.+0      	; 0x3b58 <uxQueueMessagesWaiting+0x6>
    3b58:	0f 92       	push	r0
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62
    3b5e:	9b 83       	std	Y+3, r25	; 0x03
    3b60:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1987
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1989
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3b68:	ea 81       	ldd	r30, Y+2	; 0x02
    3b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b6e:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1991
    }
    taskEXIT_CRITICAL();
    3b70:	0f 90       	pop	r0
    3b72:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1993

    return uxReturn;
    3b74:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1994
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3b76:	0f 90       	pop	r0
    3b78:	0f 90       	pop	r0
    3b7a:	0f 90       	pop	r0
    3b7c:	cf 91       	pop	r28
    3b7e:	df 91       	pop	r29
    3b80:	08 95       	ret

00003b82 <uxQueueSpacesAvailable>:
uxQueueSpacesAvailable():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:1998
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3b82:	df 93       	push	r29
    3b84:	cf 93       	push	r28
    3b86:	00 d0       	rcall	.+0      	; 0x3b88 <uxQueueSpacesAvailable+0x6>
    3b88:	00 d0       	rcall	.+0      	; 0x3b8a <uxQueueSpacesAvailable+0x8>
    3b8a:	0f 92       	push	r0
    3b8c:	cd b7       	in	r28, 0x3d	; 61
    3b8e:	de b7       	in	r29, 0x3e	; 62
    3b90:	9d 83       	std	Y+5, r25	; 0x05
    3b92:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2000
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3b94:	8c 81       	ldd	r24, Y+4	; 0x04
    3b96:	9d 81       	ldd	r25, Y+5	; 0x05
    3b98:	9a 83       	std	Y+2, r25	; 0x02
    3b9a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2004

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    3b9c:	0f b6       	in	r0, 0x3f	; 63
    3b9e:	f8 94       	cli
    3ba0:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2006
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3ba2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba6:	93 8d       	ldd	r25, Z+27	; 0x1b
    3ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    3baa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bac:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bae:	29 2f       	mov	r18, r25
    3bb0:	28 1b       	sub	r18, r24
    3bb2:	82 2f       	mov	r24, r18
    3bb4:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2008
    }
    taskEXIT_CRITICAL();
    3bb6:	0f 90       	pop	r0
    3bb8:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2010

    return uxReturn;
    3bba:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2011
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bbc:	0f 90       	pop	r0
    3bbe:	0f 90       	pop	r0
    3bc0:	0f 90       	pop	r0
    3bc2:	0f 90       	pop	r0
    3bc4:	0f 90       	pop	r0
    3bc6:	cf 91       	pop	r28
    3bc8:	df 91       	pop	r29
    3bca:	08 95       	ret

00003bcc <uxQueueMessagesWaitingFromISR>:
uxQueueMessagesWaitingFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2015
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3bcc:	df 93       	push	r29
    3bce:	cf 93       	push	r28
    3bd0:	00 d0       	rcall	.+0      	; 0x3bd2 <uxQueueMessagesWaitingFromISR+0x6>
    3bd2:	00 d0       	rcall	.+0      	; 0x3bd4 <uxQueueMessagesWaitingFromISR+0x8>
    3bd4:	0f 92       	push	r0
    3bd6:	cd b7       	in	r28, 0x3d	; 61
    3bd8:	de b7       	in	r29, 0x3e	; 62
    3bda:	9d 83       	std	Y+5, r25	; 0x05
    3bdc:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2017
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    3bde:	8c 81       	ldd	r24, Y+4	; 0x04
    3be0:	9d 81       	ldd	r25, Y+5	; 0x05
    3be2:	9a 83       	std	Y+2, r25	; 0x02
    3be4:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2020

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    3be6:	e9 81       	ldd	r30, Y+1	; 0x01
    3be8:	fa 81       	ldd	r31, Y+2	; 0x02
    3bea:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bec:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2022

    return uxReturn;
    3bee:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2023
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bf0:	0f 90       	pop	r0
    3bf2:	0f 90       	pop	r0
    3bf4:	0f 90       	pop	r0
    3bf6:	0f 90       	pop	r0
    3bf8:	0f 90       	pop	r0
    3bfa:	cf 91       	pop	r28
    3bfc:	df 91       	pop	r29
    3bfe:	08 95       	ret

00003c00 <vQueueDelete>:
vQueueDelete():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2027
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3c00:	df 93       	push	r29
    3c02:	cf 93       	push	r28
    3c04:	00 d0       	rcall	.+0      	; 0x3c06 <vQueueDelete+0x6>
    3c06:	00 d0       	rcall	.+0      	; 0x3c08 <vQueueDelete+0x8>
    3c08:	cd b7       	in	r28, 0x3d	; 61
    3c0a:	de b7       	in	r29, 0x3e	; 62
    3c0c:	9c 83       	std	Y+4, r25	; 0x04
    3c0e:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2028
    Queue_t * const pxQueue = xQueue;
    3c10:	8b 81       	ldd	r24, Y+3	; 0x03
    3c12:	9c 81       	ldd	r25, Y+4	; 0x04
    3c14:	9a 83       	std	Y+2, r25	; 0x02
    3c16:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2065
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3c18:	0f 90       	pop	r0
    3c1a:	0f 90       	pop	r0
    3c1c:	0f 90       	pop	r0
    3c1e:	0f 90       	pop	r0
    3c20:	cf 91       	pop	r28
    3c22:	df 91       	pop	r29
    3c24:	08 95       	ret

00003c26 <prvGetDisinheritPriorityAfterTimeout>:
prvGetDisinheritPriorityAfterTimeout():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2102
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
    3c26:	df 93       	push	r29
    3c28:	cf 93       	push	r28
    3c2a:	00 d0       	rcall	.+0      	; 0x3c2c <prvGetDisinheritPriorityAfterTimeout+0x6>
    3c2c:	0f 92       	push	r0
    3c2e:	cd b7       	in	r28, 0x3d	; 61
    3c30:	de b7       	in	r29, 0x3e	; 62
    3c32:	9b 83       	std	Y+3, r25	; 0x03
    3c34:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2111
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    3c36:	ea 81       	ldd	r30, Y+2	; 0x02
    3c38:	fb 81       	ldd	r31, Y+3	; 0x03
    3c3a:	81 89       	ldd	r24, Z+17	; 0x11
    3c3c:	88 23       	and	r24, r24
    3c3e:	61 f0       	breq	.+24     	; 0x3c58 <prvGetDisinheritPriorityAfterTimeout+0x32>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2113
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    3c40:	ea 81       	ldd	r30, Y+2	; 0x02
    3c42:	fb 81       	ldd	r31, Y+3	; 0x03
    3c44:	06 88       	ldd	r0, Z+22	; 0x16
    3c46:	f7 89       	ldd	r31, Z+23	; 0x17
    3c48:	e0 2d       	mov	r30, r0
    3c4a:	80 81       	ld	r24, Z
    3c4c:	91 81       	ldd	r25, Z+1	; 0x01
    3c4e:	98 2f       	mov	r25, r24
    3c50:	84 e0       	ldi	r24, 0x04	; 4
    3c52:	89 1b       	sub	r24, r25
    3c54:	89 83       	std	Y+1, r24	; 0x01
    3c56:	01 c0       	rjmp	.+2      	; 0x3c5a <prvGetDisinheritPriorityAfterTimeout+0x34>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2117
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    3c58:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2120
        }

        return uxHighestPriorityOfWaitingTasks;
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2121
    }
    3c5c:	0f 90       	pop	r0
    3c5e:	0f 90       	pop	r0
    3c60:	0f 90       	pop	r0
    3c62:	cf 91       	pop	r28
    3c64:	df 91       	pop	r29
    3c66:	08 95       	ret

00003c68 <prvCopyDataToQueue>:
prvCopyDataToQueue():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2129
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    3c68:	df 93       	push	r29
    3c6a:	cf 93       	push	r28
    3c6c:	cd b7       	in	r28, 0x3d	; 61
    3c6e:	de b7       	in	r29, 0x3e	; 62
    3c70:	27 97       	sbiw	r28, 0x07	; 7
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	9c 83       	std	Y+4, r25	; 0x04
    3c7e:	8b 83       	std	Y+3, r24	; 0x03
    3c80:	7e 83       	std	Y+6, r23	; 0x06
    3c82:	6d 83       	std	Y+5, r22	; 0x05
    3c84:	4f 83       	std	Y+7, r20	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2130
    BaseType_t xReturn = pdFALSE;
    3c86:	1a 82       	std	Y+2, r1	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2135
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3c88:	eb 81       	ldd	r30, Y+3	; 0x03
    3c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c8e:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2137

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3c90:	eb 81       	ldd	r30, Y+3	; 0x03
    3c92:	fc 81       	ldd	r31, Y+4	; 0x04
    3c94:	84 8d       	ldd	r24, Z+28	; 0x1c
    3c96:	88 23       	and	r24, r24
    3c98:	99 f4       	brne	.+38     	; 0x3cc0 <prvCopyDataToQueue+0x58>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2141
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c9e:	80 81       	ld	r24, Z
    3ca0:	91 81       	ldd	r25, Z+1	; 0x01
    3ca2:	00 97       	sbiw	r24, 0x00	; 0
    3ca4:	09 f0       	breq	.+2      	; 0x3ca8 <prvCopyDataToQueue+0x40>
    3ca6:	89 c0       	rjmp	.+274    	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2144
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    3ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    3caa:	fc 81       	ldd	r31, Y+4	; 0x04
    3cac:	84 81       	ldd	r24, Z+4	; 0x04
    3cae:	95 81       	ldd	r25, Z+5	; 0x05
    3cb0:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <xTaskPriorityDisinherit>
    3cb4:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2145
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
    3cb6:	eb 81       	ldd	r30, Y+3	; 0x03
    3cb8:	fc 81       	ldd	r31, Y+4	; 0x04
    3cba:	15 82       	std	Z+5, r1	; 0x05
    3cbc:	14 82       	std	Z+4, r1	; 0x04
    3cbe:	7d c0       	rjmp	.+250    	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2154
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3cc2:	88 23       	and	r24, r24
    3cc4:	99 f5       	brne	.+102    	; 0x3d2c <prvCopyDataToQueue+0xc4>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2156
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    3cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    3cca:	62 81       	ldd	r22, Z+2	; 0x02
    3ccc:	73 81       	ldd	r23, Z+3	; 0x03
    3cce:	eb 81       	ldd	r30, Y+3	; 0x03
    3cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    3cd2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cd4:	48 2f       	mov	r20, r24
    3cd6:	50 e0       	ldi	r21, 0x00	; 0
    3cd8:	2d 81       	ldd	r18, Y+5	; 0x05
    3cda:	3e 81       	ldd	r19, Y+6	; 0x06
    3cdc:	cb 01       	movw	r24, r22
    3cde:	b9 01       	movw	r22, r18
    3ce0:	0e 94 1f 23 	call	0x463e	; 0x463e <memcpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2157
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ce8:	22 81       	ldd	r18, Z+2	; 0x02
    3cea:	33 81       	ldd	r19, Z+3	; 0x03
    3cec:	eb 81       	ldd	r30, Y+3	; 0x03
    3cee:	fc 81       	ldd	r31, Y+4	; 0x04
    3cf0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cf2:	88 2f       	mov	r24, r24
    3cf4:	90 e0       	ldi	r25, 0x00	; 0
    3cf6:	82 0f       	add	r24, r18
    3cf8:	93 1f       	adc	r25, r19
    3cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    3cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    3cfe:	93 83       	std	Z+3, r25	; 0x03
    3d00:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2159

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d02:	eb 81       	ldd	r30, Y+3	; 0x03
    3d04:	fc 81       	ldd	r31, Y+4	; 0x04
    3d06:	22 81       	ldd	r18, Z+2	; 0x02
    3d08:	33 81       	ldd	r19, Z+3	; 0x03
    3d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d0e:	84 81       	ldd	r24, Z+4	; 0x04
    3d10:	95 81       	ldd	r25, Z+5	; 0x05
    3d12:	28 17       	cp	r18, r24
    3d14:	39 07       	cpc	r19, r25
    3d16:	08 f4       	brcc	.+2      	; 0x3d1a <prvCopyDataToQueue+0xb2>
    3d18:	50 c0       	rjmp	.+160    	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2161
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d1e:	80 81       	ld	r24, Z
    3d20:	91 81       	ldd	r25, Z+1	; 0x01
    3d22:	eb 81       	ldd	r30, Y+3	; 0x03
    3d24:	fc 81       	ldd	r31, Y+4	; 0x04
    3d26:	93 83       	std	Z+3, r25	; 0x03
    3d28:	82 83       	std	Z+2, r24	; 0x02
    3d2a:	47 c0       	rjmp	.+142    	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2170
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d30:	66 81       	ldd	r22, Z+6	; 0x06
    3d32:	77 81       	ldd	r23, Z+7	; 0x07
    3d34:	eb 81       	ldd	r30, Y+3	; 0x03
    3d36:	fc 81       	ldd	r31, Y+4	; 0x04
    3d38:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d3a:	48 2f       	mov	r20, r24
    3d3c:	50 e0       	ldi	r21, 0x00	; 0
    3d3e:	2d 81       	ldd	r18, Y+5	; 0x05
    3d40:	3e 81       	ldd	r19, Y+6	; 0x06
    3d42:	cb 01       	movw	r24, r22
    3d44:	b9 01       	movw	r22, r18
    3d46:	0e 94 1f 23 	call	0x463e	; 0x463e <memcpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2171
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3d4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d4e:	26 81       	ldd	r18, Z+6	; 0x06
    3d50:	37 81       	ldd	r19, Z+7	; 0x07
    3d52:	eb 81       	ldd	r30, Y+3	; 0x03
    3d54:	fc 81       	ldd	r31, Y+4	; 0x04
    3d56:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d58:	88 2f       	mov	r24, r24
    3d5a:	90 e0       	ldi	r25, 0x00	; 0
    3d5c:	90 95       	com	r25
    3d5e:	81 95       	neg	r24
    3d60:	9f 4f       	sbci	r25, 0xFF	; 255
    3d62:	82 0f       	add	r24, r18
    3d64:	93 1f       	adc	r25, r19
    3d66:	eb 81       	ldd	r30, Y+3	; 0x03
    3d68:	fc 81       	ldd	r31, Y+4	; 0x04
    3d6a:	97 83       	std	Z+7, r25	; 0x07
    3d6c:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2173

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3d70:	fc 81       	ldd	r31, Y+4	; 0x04
    3d72:	26 81       	ldd	r18, Z+6	; 0x06
    3d74:	37 81       	ldd	r19, Z+7	; 0x07
    3d76:	eb 81       	ldd	r30, Y+3	; 0x03
    3d78:	fc 81       	ldd	r31, Y+4	; 0x04
    3d7a:	80 81       	ld	r24, Z
    3d7c:	91 81       	ldd	r25, Z+1	; 0x01
    3d7e:	28 17       	cp	r18, r24
    3d80:	39 07       	cpc	r19, r25
    3d82:	90 f4       	brcc	.+36     	; 0x3da8 <prvCopyDataToQueue+0x140>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2175
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3d84:	eb 81       	ldd	r30, Y+3	; 0x03
    3d86:	fc 81       	ldd	r31, Y+4	; 0x04
    3d88:	24 81       	ldd	r18, Z+4	; 0x04
    3d8a:	35 81       	ldd	r19, Z+5	; 0x05
    3d8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d90:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d92:	88 2f       	mov	r24, r24
    3d94:	90 e0       	ldi	r25, 0x00	; 0
    3d96:	90 95       	com	r25
    3d98:	81 95       	neg	r24
    3d9a:	9f 4f       	sbci	r25, 0xFF	; 255
    3d9c:	82 0f       	add	r24, r18
    3d9e:	93 1f       	adc	r25, r19
    3da0:	eb 81       	ldd	r30, Y+3	; 0x03
    3da2:	fc 81       	ldd	r31, Y+4	; 0x04
    3da4:	97 83       	std	Z+7, r25	; 0x07
    3da6:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2182
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3da8:	8f 81       	ldd	r24, Y+7	; 0x07
    3daa:	82 30       	cpi	r24, 0x02	; 2
    3dac:	31 f4       	brne	.+12     	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2184
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3dae:	89 81       	ldd	r24, Y+1	; 0x01
    3db0:	88 23       	and	r24, r24
    3db2:	19 f0       	breq	.+6      	; 0x3dba <prvCopyDataToQueue+0x152>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2190
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3db4:	89 81       	ldd	r24, Y+1	; 0x01
    3db6:	81 50       	subi	r24, 0x01	; 1
    3db8:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2203
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3dba:	89 81       	ldd	r24, Y+1	; 0x01
    3dbc:	8f 5f       	subi	r24, 0xFF	; 255
    3dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    3dc2:	82 8f       	std	Z+26, r24	; 0x1a
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2205

    return xReturn;
    3dc4:	8a 81       	ldd	r24, Y+2	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2206
}
    3dc6:	27 96       	adiw	r28, 0x07	; 7
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	de bf       	out	0x3e, r29	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	cd bf       	out	0x3d, r28	; 61
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	08 95       	ret

00003dd8 <prvCopyDataFromQueue>:
prvCopyDataFromQueue():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2211
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3dd8:	df 93       	push	r29
    3dda:	cf 93       	push	r28
    3ddc:	00 d0       	rcall	.+0      	; 0x3dde <prvCopyDataFromQueue+0x6>
    3dde:	00 d0       	rcall	.+0      	; 0x3de0 <prvCopyDataFromQueue+0x8>
    3de0:	cd b7       	in	r28, 0x3d	; 61
    3de2:	de b7       	in	r29, 0x3e	; 62
    3de4:	9a 83       	std	Y+2, r25	; 0x02
    3de6:	89 83       	std	Y+1, r24	; 0x01
    3de8:	7c 83       	std	Y+4, r23	; 0x04
    3dea:	6b 83       	std	Y+3, r22	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2212
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3dec:	e9 81       	ldd	r30, Y+1	; 0x01
    3dee:	fa 81       	ldd	r31, Y+2	; 0x02
    3df0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3df2:	88 23       	and	r24, r24
    3df4:	89 f1       	breq	.+98     	; 0x3e58 <prvCopyDataFromQueue+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2214
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3df6:	e9 81       	ldd	r30, Y+1	; 0x01
    3df8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfa:	26 81       	ldd	r18, Z+6	; 0x06
    3dfc:	37 81       	ldd	r19, Z+7	; 0x07
    3dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    3e00:	fa 81       	ldd	r31, Y+2	; 0x02
    3e02:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e04:	88 2f       	mov	r24, r24
    3e06:	90 e0       	ldi	r25, 0x00	; 0
    3e08:	82 0f       	add	r24, r18
    3e0a:	93 1f       	adc	r25, r19
    3e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e10:	97 83       	std	Z+7, r25	; 0x07
    3e12:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2216

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e14:	e9 81       	ldd	r30, Y+1	; 0x01
    3e16:	fa 81       	ldd	r31, Y+2	; 0x02
    3e18:	26 81       	ldd	r18, Z+6	; 0x06
    3e1a:	37 81       	ldd	r19, Z+7	; 0x07
    3e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e20:	84 81       	ldd	r24, Z+4	; 0x04
    3e22:	95 81       	ldd	r25, Z+5	; 0x05
    3e24:	28 17       	cp	r18, r24
    3e26:	39 07       	cpc	r19, r25
    3e28:	40 f0       	brcs	.+16     	; 0x3e3a <prvCopyDataFromQueue+0x62>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2218
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e2e:	80 81       	ld	r24, Z
    3e30:	91 81       	ldd	r25, Z+1	; 0x01
    3e32:	e9 81       	ldd	r30, Y+1	; 0x01
    3e34:	fa 81       	ldd	r31, Y+2	; 0x02
    3e36:	97 83       	std	Z+7, r25	; 0x07
    3e38:	86 83       	std	Z+6, r24	; 0x06
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2225
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e3e:	46 81       	ldd	r20, Z+6	; 0x06
    3e40:	57 81       	ldd	r21, Z+7	; 0x07
    3e42:	e9 81       	ldd	r30, Y+1	; 0x01
    3e44:	fa 81       	ldd	r31, Y+2	; 0x02
    3e46:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e48:	28 2f       	mov	r18, r24
    3e4a:	30 e0       	ldi	r19, 0x00	; 0
    3e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e50:	ba 01       	movw	r22, r20
    3e52:	a9 01       	movw	r20, r18
    3e54:	0e 94 1f 23 	call	0x463e	; 0x463e <memcpy>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2227
    }
}
    3e58:	0f 90       	pop	r0
    3e5a:	0f 90       	pop	r0
    3e5c:	0f 90       	pop	r0
    3e5e:	0f 90       	pop	r0
    3e60:	cf 91       	pop	r28
    3e62:	df 91       	pop	r29
    3e64:	08 95       	ret

00003e66 <prvUnlockQueue>:
prvUnlockQueue():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2231
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3e66:	df 93       	push	r29
    3e68:	cf 93       	push	r28
    3e6a:	00 d0       	rcall	.+0      	; 0x3e6c <prvUnlockQueue+0x6>
    3e6c:	00 d0       	rcall	.+0      	; 0x3e6e <prvUnlockQueue+0x8>
    3e6e:	cd b7       	in	r28, 0x3d	; 61
    3e70:	de b7       	in	r29, 0x3e	; 62
    3e72:	9c 83       	std	Y+4, r25	; 0x04
    3e74:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2238

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    3e76:	0f b6       	in	r0, 0x3f	; 63
    3e78:	f8 94       	cli
    3e7a:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2240
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e80:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e82:	8a 83       	std	Y+2, r24	; 0x02
    3e84:	11 c0       	rjmp	.+34     	; 0x3ea8 <prvUnlockQueue+0x42>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2291
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e86:	eb 81       	ldd	r30, Y+3	; 0x03
    3e88:	fc 81       	ldd	r31, Y+4	; 0x04
    3e8a:	81 89       	ldd	r24, Z+17	; 0x11
    3e8c:	88 23       	and	r24, r24
    3e8e:	79 f0       	breq	.+30     	; 0x3eae <prvUnlockQueue+0x48>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2293
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e90:	8b 81       	ldd	r24, Y+3	; 0x03
    3e92:	9c 81       	ldd	r25, Y+4	; 0x04
    3e94:	41 96       	adiw	r24, 0x11	; 17
    3e96:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3e9a:	88 23       	and	r24, r24
    3e9c:	11 f0       	breq	.+4      	; 0x3ea2 <prvUnlockQueue+0x3c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2297
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3e9e:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskMissedYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2311
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ea4:	81 50       	subi	r24, 0x01	; 1
    3ea6:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2243
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eaa:	18 16       	cp	r1, r24
    3eac:	64 f3       	brlt	.-40     	; 0x3e86 <prvUnlockQueue+0x20>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2314
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3eae:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb2:	8f ef       	ldi	r24, 0xFF	; 255
    3eb4:	86 8f       	std	Z+30, r24	; 0x1e
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2316
    }
    taskEXIT_CRITICAL();
    3eb6:	0f 90       	pop	r0
    3eb8:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2319

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3eba:	0f b6       	in	r0, 0x3f	; 63
    3ebc:	f8 94       	cli
    3ebe:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2321
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ec6:	89 83       	std	Y+1, r24	; 0x01
    3ec8:	11 c0       	rjmp	.+34     	; 0x3eec <prvUnlockQueue+0x86>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2325

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3eca:	eb 81       	ldd	r30, Y+3	; 0x03
    3ecc:	fc 81       	ldd	r31, Y+4	; 0x04
    3ece:	80 85       	ldd	r24, Z+8	; 0x08
    3ed0:	88 23       	and	r24, r24
    3ed2:	79 f0       	breq	.+30     	; 0x3ef2 <prvUnlockQueue+0x8c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2327
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ed4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed8:	08 96       	adiw	r24, 0x08	; 8
    3eda:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <xTaskRemoveFromEventList>
    3ede:	88 23       	and	r24, r24
    3ee0:	11 f0       	breq	.+4      	; 0x3ee6 <prvUnlockQueue+0x80>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2329
                {
                    vTaskMissedYield();
    3ee2:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vTaskMissedYield>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2336
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    3ee6:	89 81       	ldd	r24, Y+1	; 0x01
    3ee8:	81 50       	subi	r24, 0x01	; 1
    3eea:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2323
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	18 16       	cp	r1, r24
    3ef0:	64 f3       	brlt	.-40     	; 0x3eca <prvUnlockQueue+0x64>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2344
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef6:	8f ef       	ldi	r24, 0xFF	; 255
    3ef8:	85 8f       	std	Z+29, r24	; 0x1d
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2346
    }
    taskEXIT_CRITICAL();
    3efa:	0f 90       	pop	r0
    3efc:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2347
}
    3efe:	0f 90       	pop	r0
    3f00:	0f 90       	pop	r0
    3f02:	0f 90       	pop	r0
    3f04:	0f 90       	pop	r0
    3f06:	cf 91       	pop	r28
    3f08:	df 91       	pop	r29
    3f0a:	08 95       	ret

00003f0c <prvIsQueueEmpty>:
prvIsQueueEmpty():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2351
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3f0c:	df 93       	push	r29
    3f0e:	cf 93       	push	r28
    3f10:	00 d0       	rcall	.+0      	; 0x3f12 <prvIsQueueEmpty+0x6>
    3f12:	0f 92       	push	r0
    3f14:	cd b7       	in	r28, 0x3d	; 61
    3f16:	de b7       	in	r29, 0x3e	; 62
    3f18:	9b 83       	std	Y+3, r25	; 0x03
    3f1a:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2354
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3f1c:	0f b6       	in	r0, 0x3f	; 63
    3f1e:	f8 94       	cli
    3f20:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2356
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3f22:	ea 81       	ldd	r30, Y+2	; 0x02
    3f24:	fb 81       	ldd	r31, Y+3	; 0x03
    3f26:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f28:	88 23       	and	r24, r24
    3f2a:	19 f4       	brne	.+6      	; 0x3f32 <prvIsQueueEmpty+0x26>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2358
        {
            xReturn = pdTRUE;
    3f2c:	81 e0       	ldi	r24, 0x01	; 1
    3f2e:	89 83       	std	Y+1, r24	; 0x01
    3f30:	01 c0       	rjmp	.+2      	; 0x3f34 <prvIsQueueEmpty+0x28>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2362
        }
        else
        {
            xReturn = pdFALSE;
    3f32:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2365
        }
    }
    taskEXIT_CRITICAL();
    3f34:	0f 90       	pop	r0
    3f36:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2367

    return xReturn;
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2368
}
    3f3a:	0f 90       	pop	r0
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	cf 91       	pop	r28
    3f42:	df 91       	pop	r29
    3f44:	08 95       	ret

00003f46 <xQueueIsQueueEmptyFromISR>:
xQueueIsQueueEmptyFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2372
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f46:	df 93       	push	r29
    3f48:	cf 93       	push	r28
    3f4a:	00 d0       	rcall	.+0      	; 0x3f4c <xQueueIsQueueEmptyFromISR+0x6>
    3f4c:	00 d0       	rcall	.+0      	; 0x3f4e <xQueueIsQueueEmptyFromISR+0x8>
    3f4e:	0f 92       	push	r0
    3f50:	cd b7       	in	r28, 0x3d	; 61
    3f52:	de b7       	in	r29, 0x3e	; 62
    3f54:	9d 83       	std	Y+5, r25	; 0x05
    3f56:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2374
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    3f58:	8c 81       	ldd	r24, Y+4	; 0x04
    3f5a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f5c:	9a 83       	std	Y+2, r25	; 0x02
    3f5e:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2378

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3f60:	e9 81       	ldd	r30, Y+1	; 0x01
    3f62:	fa 81       	ldd	r31, Y+2	; 0x02
    3f64:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f66:	88 23       	and	r24, r24
    3f68:	19 f4       	brne	.+6      	; 0x3f70 <xQueueIsQueueEmptyFromISR+0x2a>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2380
    {
        xReturn = pdTRUE;
    3f6a:	81 e0       	ldi	r24, 0x01	; 1
    3f6c:	8b 83       	std	Y+3, r24	; 0x03
    3f6e:	01 c0       	rjmp	.+2      	; 0x3f72 <xQueueIsQueueEmptyFromISR+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2384
    }
    else
    {
        xReturn = pdFALSE;
    3f70:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2387
    }

    return xReturn;
    3f72:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2388
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3f74:	0f 90       	pop	r0
    3f76:	0f 90       	pop	r0
    3f78:	0f 90       	pop	r0
    3f7a:	0f 90       	pop	r0
    3f7c:	0f 90       	pop	r0
    3f7e:	cf 91       	pop	r28
    3f80:	df 91       	pop	r29
    3f82:	08 95       	ret

00003f84 <prvIsQueueFull>:
prvIsQueueFull():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2392
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    3f84:	df 93       	push	r29
    3f86:	cf 93       	push	r28
    3f88:	00 d0       	rcall	.+0      	; 0x3f8a <prvIsQueueFull+0x6>
    3f8a:	0f 92       	push	r0
    3f8c:	cd b7       	in	r28, 0x3d	; 61
    3f8e:	de b7       	in	r29, 0x3e	; 62
    3f90:	9b 83       	std	Y+3, r25	; 0x03
    3f92:	8a 83       	std	Y+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2395
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3f94:	0f b6       	in	r0, 0x3f	; 63
    3f96:	f8 94       	cli
    3f98:	0f 92       	push	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2397
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3f9a:	ea 81       	ldd	r30, Y+2	; 0x02
    3f9c:	fb 81       	ldd	r31, Y+3	; 0x03
    3f9e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fa0:	ea 81       	ldd	r30, Y+2	; 0x02
    3fa2:	fb 81       	ldd	r31, Y+3	; 0x03
    3fa4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fa6:	98 17       	cp	r25, r24
    3fa8:	19 f4       	brne	.+6      	; 0x3fb0 <prvIsQueueFull+0x2c>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2399
        {
            xReturn = pdTRUE;
    3faa:	81 e0       	ldi	r24, 0x01	; 1
    3fac:	89 83       	std	Y+1, r24	; 0x01
    3fae:	01 c0       	rjmp	.+2      	; 0x3fb2 <prvIsQueueFull+0x2e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2403
        }
        else
        {
            xReturn = pdFALSE;
    3fb0:	19 82       	std	Y+1, r1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2406
        }
    }
    taskEXIT_CRITICAL();
    3fb2:	0f 90       	pop	r0
    3fb4:	0f be       	out	0x3f, r0	; 63
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2408

    return xReturn;
    3fb6:	89 81       	ldd	r24, Y+1	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2409
}
    3fb8:	0f 90       	pop	r0
    3fba:	0f 90       	pop	r0
    3fbc:	0f 90       	pop	r0
    3fbe:	cf 91       	pop	r28
    3fc0:	df 91       	pop	r29
    3fc2:	08 95       	ret

00003fc4 <xQueueIsQueueFullFromISR>:
xQueueIsQueueFullFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2413
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3fc4:	df 93       	push	r29
    3fc6:	cf 93       	push	r28
    3fc8:	00 d0       	rcall	.+0      	; 0x3fca <xQueueIsQueueFullFromISR+0x6>
    3fca:	00 d0       	rcall	.+0      	; 0x3fcc <xQueueIsQueueFullFromISR+0x8>
    3fcc:	0f 92       	push	r0
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    3fd2:	9d 83       	std	Y+5, r25	; 0x05
    3fd4:	8c 83       	std	Y+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2415
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    3fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd8:	9d 81       	ldd	r25, Y+5	; 0x05
    3fda:	9a 83       	std	Y+2, r25	; 0x02
    3fdc:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2419

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fde:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe2:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fe4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fea:	98 17       	cp	r25, r24
    3fec:	19 f4       	brne	.+6      	; 0x3ff4 <xQueueIsQueueFullFromISR+0x30>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2421
    {
        xReturn = pdTRUE;
    3fee:	81 e0       	ldi	r24, 0x01	; 1
    3ff0:	8b 83       	std	Y+3, r24	; 0x03
    3ff2:	01 c0       	rjmp	.+2      	; 0x3ff6 <xQueueIsQueueFullFromISR+0x32>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2425
    }
    else
    {
        xReturn = pdFALSE;
    3ff4:	1b 82       	std	Y+3, r1	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2428
    }

    return xReturn;
    3ff6:	8b 81       	ldd	r24, Y+3	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/queue.c:2429
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	0f 90       	pop	r0
    3ffe:	0f 90       	pop	r0
    4000:	0f 90       	pop	r0
    4002:	cf 91       	pop	r28
    4004:	df 91       	pop	r29
    4006:	08 95       	ret

00004008 <vListInitialise>:
vListInitialise():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:49
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    4008:	df 93       	push	r29
    400a:	cf 93       	push	r28
    400c:	00 d0       	rcall	.+0      	; 0x400e <vListInitialise+0x6>
    400e:	cd b7       	in	r28, 0x3d	; 61
    4010:	de b7       	in	r29, 0x3e	; 62
    4012:	9a 83       	std	Y+2, r25	; 0x02
    4014:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:53
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4016:	89 81       	ldd	r24, Y+1	; 0x01
    4018:	9a 81       	ldd	r25, Y+2	; 0x02
    401a:	03 96       	adiw	r24, 0x03	; 3
    401c:	e9 81       	ldd	r30, Y+1	; 0x01
    401e:	fa 81       	ldd	r31, Y+2	; 0x02
    4020:	92 83       	std	Z+2, r25	; 0x02
    4022:	81 83       	std	Z+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:57

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    4024:	e9 81       	ldd	r30, Y+1	; 0x01
    4026:	fa 81       	ldd	r31, Y+2	; 0x02
    4028:	8f ef       	ldi	r24, 0xFF	; 255
    402a:	9f ef       	ldi	r25, 0xFF	; 255
    402c:	94 83       	std	Z+4, r25	; 0x04
    402e:	83 83       	std	Z+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:61

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4030:	89 81       	ldd	r24, Y+1	; 0x01
    4032:	9a 81       	ldd	r25, Y+2	; 0x02
    4034:	03 96       	adiw	r24, 0x03	; 3
    4036:	e9 81       	ldd	r30, Y+1	; 0x01
    4038:	fa 81       	ldd	r31, Y+2	; 0x02
    403a:	96 83       	std	Z+6, r25	; 0x06
    403c:	85 83       	std	Z+5, r24	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:62
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	9a 81       	ldd	r25, Y+2	; 0x02
    4042:	03 96       	adiw	r24, 0x03	; 3
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	90 87       	std	Z+8, r25	; 0x08
    404a:	87 83       	std	Z+7, r24	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:64

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    404c:	e9 81       	ldd	r30, Y+1	; 0x01
    404e:	fa 81       	ldd	r31, Y+2	; 0x02
    4050:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:70

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    4052:	0f 90       	pop	r0
    4054:	0f 90       	pop	r0
    4056:	cf 91       	pop	r28
    4058:	df 91       	pop	r29
    405a:	08 95       	ret

0000405c <vListInitialiseItem>:
vListInitialiseItem():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:74
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    405c:	df 93       	push	r29
    405e:	cf 93       	push	r28
    4060:	00 d0       	rcall	.+0      	; 0x4062 <vListInitialiseItem+0x6>
    4062:	cd b7       	in	r28, 0x3d	; 61
    4064:	de b7       	in	r29, 0x3e	; 62
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:76
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    406a:	e9 81       	ldd	r30, Y+1	; 0x01
    406c:	fa 81       	ldd	r31, Y+2	; 0x02
    406e:	11 86       	std	Z+9, r1	; 0x09
    4070:	10 86       	std	Z+8, r1	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:82

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    4072:	0f 90       	pop	r0
    4074:	0f 90       	pop	r0
    4076:	cf 91       	pop	r28
    4078:	df 91       	pop	r29
    407a:	08 95       	ret

0000407c <vListInsertEnd>:
vListInsertEnd():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:87
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    407c:	df 93       	push	r29
    407e:	cf 93       	push	r28
    4080:	00 d0       	rcall	.+0      	; 0x4082 <vListInsertEnd+0x6>
    4082:	00 d0       	rcall	.+0      	; 0x4084 <vListInsertEnd+0x8>
    4084:	00 d0       	rcall	.+0      	; 0x4086 <vListInsertEnd+0xa>
    4086:	cd b7       	in	r28, 0x3d	; 61
    4088:	de b7       	in	r29, 0x3e	; 62
    408a:	9c 83       	std	Y+4, r25	; 0x04
    408c:	8b 83       	std	Y+3, r24	; 0x03
    408e:	7e 83       	std	Y+6, r23	; 0x06
    4090:	6d 83       	std	Y+5, r22	; 0x05
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:88
    ListItem_t * const pxIndex = pxList->pxIndex;
    4092:	eb 81       	ldd	r30, Y+3	; 0x03
    4094:	fc 81       	ldd	r31, Y+4	; 0x04
    4096:	81 81       	ldd	r24, Z+1	; 0x01
    4098:	92 81       	ldd	r25, Z+2	; 0x02
    409a:	9a 83       	std	Y+2, r25	; 0x02
    409c:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:99
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    409e:	ed 81       	ldd	r30, Y+5	; 0x05
    40a0:	fe 81       	ldd	r31, Y+6	; 0x06
    40a2:	89 81       	ldd	r24, Y+1	; 0x01
    40a4:	9a 81       	ldd	r25, Y+2	; 0x02
    40a6:	93 83       	std	Z+3, r25	; 0x03
    40a8:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:100
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    40aa:	e9 81       	ldd	r30, Y+1	; 0x01
    40ac:	fa 81       	ldd	r31, Y+2	; 0x02
    40ae:	84 81       	ldd	r24, Z+4	; 0x04
    40b0:	95 81       	ldd	r25, Z+5	; 0x05
    40b2:	ed 81       	ldd	r30, Y+5	; 0x05
    40b4:	fe 81       	ldd	r31, Y+6	; 0x06
    40b6:	95 83       	std	Z+5, r25	; 0x05
    40b8:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:105

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    40ba:	e9 81       	ldd	r30, Y+1	; 0x01
    40bc:	fa 81       	ldd	r31, Y+2	; 0x02
    40be:	04 80       	ldd	r0, Z+4	; 0x04
    40c0:	f5 81       	ldd	r31, Z+5	; 0x05
    40c2:	e0 2d       	mov	r30, r0
    40c4:	8d 81       	ldd	r24, Y+5	; 0x05
    40c6:	9e 81       	ldd	r25, Y+6	; 0x06
    40c8:	93 83       	std	Z+3, r25	; 0x03
    40ca:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:106
    pxIndex->pxPrevious = pxNewListItem;
    40cc:	e9 81       	ldd	r30, Y+1	; 0x01
    40ce:	fa 81       	ldd	r31, Y+2	; 0x02
    40d0:	8d 81       	ldd	r24, Y+5	; 0x05
    40d2:	9e 81       	ldd	r25, Y+6	; 0x06
    40d4:	95 83       	std	Z+5, r25	; 0x05
    40d6:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:109

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    40d8:	ed 81       	ldd	r30, Y+5	; 0x05
    40da:	fe 81       	ldd	r31, Y+6	; 0x06
    40dc:	8b 81       	ldd	r24, Y+3	; 0x03
    40de:	9c 81       	ldd	r25, Y+4	; 0x04
    40e0:	91 87       	std	Z+9, r25	; 0x09
    40e2:	80 87       	std	Z+8, r24	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:111

    ( pxList->uxNumberOfItems )++;
    40e4:	eb 81       	ldd	r30, Y+3	; 0x03
    40e6:	fc 81       	ldd	r31, Y+4	; 0x04
    40e8:	80 81       	ld	r24, Z
    40ea:	8f 5f       	subi	r24, 0xFF	; 255
    40ec:	eb 81       	ldd	r30, Y+3	; 0x03
    40ee:	fc 81       	ldd	r31, Y+4	; 0x04
    40f0:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:112
}
    40f2:	26 96       	adiw	r28, 0x06	; 6
    40f4:	0f b6       	in	r0, 0x3f	; 63
    40f6:	f8 94       	cli
    40f8:	de bf       	out	0x3e, r29	; 62
    40fa:	0f be       	out	0x3f, r0	; 63
    40fc:	cd bf       	out	0x3d, r28	; 61
    40fe:	cf 91       	pop	r28
    4100:	df 91       	pop	r29
    4102:	08 95       	ret

00004104 <vListInsert>:
vListInsert():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:117
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    4104:	df 93       	push	r29
    4106:	cf 93       	push	r28
    4108:	cd b7       	in	r28, 0x3d	; 61
    410a:	de b7       	in	r29, 0x3e	; 62
    410c:	28 97       	sbiw	r28, 0x08	; 8
    410e:	0f b6       	in	r0, 0x3f	; 63
    4110:	f8 94       	cli
    4112:	de bf       	out	0x3e, r29	; 62
    4114:	0f be       	out	0x3f, r0	; 63
    4116:	cd bf       	out	0x3d, r28	; 61
    4118:	9e 83       	std	Y+6, r25	; 0x06
    411a:	8d 83       	std	Y+5, r24	; 0x05
    411c:	78 87       	std	Y+8, r23	; 0x08
    411e:	6f 83       	std	Y+7, r22	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:119
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    4120:	ef 81       	ldd	r30, Y+7	; 0x07
    4122:	f8 85       	ldd	r31, Y+8	; 0x08
    4124:	80 81       	ld	r24, Z
    4126:	91 81       	ldd	r25, Z+1	; 0x01
    4128:	9a 83       	std	Y+2, r25	; 0x02
    412a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:135
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    412c:	89 81       	ldd	r24, Y+1	; 0x01
    412e:	9a 81       	ldd	r25, Y+2	; 0x02
    4130:	2f ef       	ldi	r18, 0xFF	; 255
    4132:	8f 3f       	cpi	r24, 0xFF	; 255
    4134:	92 07       	cpc	r25, r18
    4136:	39 f4       	brne	.+14     	; 0x4146 <vListInsert+0x42>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:137
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    4138:	ed 81       	ldd	r30, Y+5	; 0x05
    413a:	fe 81       	ldd	r31, Y+6	; 0x06
    413c:	87 81       	ldd	r24, Z+7	; 0x07
    413e:	90 85       	ldd	r25, Z+8	; 0x08
    4140:	9c 83       	std	Y+4, r25	; 0x04
    4142:	8b 83       	std	Y+3, r24	; 0x03
    4144:	18 c0       	rjmp	.+48     	; 0x4176 <vListInsert+0x72>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:163
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    4146:	8d 81       	ldd	r24, Y+5	; 0x05
    4148:	9e 81       	ldd	r25, Y+6	; 0x06
    414a:	03 96       	adiw	r24, 0x03	; 3
    414c:	9c 83       	std	Y+4, r25	; 0x04
    414e:	8b 83       	std	Y+3, r24	; 0x03
    4150:	06 c0       	rjmp	.+12     	; 0x415e <vListInsert+0x5a>
    4152:	eb 81       	ldd	r30, Y+3	; 0x03
    4154:	fc 81       	ldd	r31, Y+4	; 0x04
    4156:	82 81       	ldd	r24, Z+2	; 0x02
    4158:	93 81       	ldd	r25, Z+3	; 0x03
    415a:	9c 83       	std	Y+4, r25	; 0x04
    415c:	8b 83       	std	Y+3, r24	; 0x03
    415e:	eb 81       	ldd	r30, Y+3	; 0x03
    4160:	fc 81       	ldd	r31, Y+4	; 0x04
    4162:	02 80       	ldd	r0, Z+2	; 0x02
    4164:	f3 81       	ldd	r31, Z+3	; 0x03
    4166:	e0 2d       	mov	r30, r0
    4168:	20 81       	ld	r18, Z
    416a:	31 81       	ldd	r19, Z+1	; 0x01
    416c:	89 81       	ldd	r24, Y+1	; 0x01
    416e:	9a 81       	ldd	r25, Y+2	; 0x02
    4170:	82 17       	cp	r24, r18
    4172:	93 07       	cpc	r25, r19
    4174:	70 f7       	brcc	.-36     	; 0x4152 <vListInsert+0x4e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:170
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    4176:	eb 81       	ldd	r30, Y+3	; 0x03
    4178:	fc 81       	ldd	r31, Y+4	; 0x04
    417a:	82 81       	ldd	r24, Z+2	; 0x02
    417c:	93 81       	ldd	r25, Z+3	; 0x03
    417e:	ef 81       	ldd	r30, Y+7	; 0x07
    4180:	f8 85       	ldd	r31, Y+8	; 0x08
    4182:	93 83       	std	Z+3, r25	; 0x03
    4184:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:171
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    4186:	ef 81       	ldd	r30, Y+7	; 0x07
    4188:	f8 85       	ldd	r31, Y+8	; 0x08
    418a:	02 80       	ldd	r0, Z+2	; 0x02
    418c:	f3 81       	ldd	r31, Z+3	; 0x03
    418e:	e0 2d       	mov	r30, r0
    4190:	8f 81       	ldd	r24, Y+7	; 0x07
    4192:	98 85       	ldd	r25, Y+8	; 0x08
    4194:	95 83       	std	Z+5, r25	; 0x05
    4196:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:172
    pxNewListItem->pxPrevious = pxIterator;
    4198:	ef 81       	ldd	r30, Y+7	; 0x07
    419a:	f8 85       	ldd	r31, Y+8	; 0x08
    419c:	8b 81       	ldd	r24, Y+3	; 0x03
    419e:	9c 81       	ldd	r25, Y+4	; 0x04
    41a0:	95 83       	std	Z+5, r25	; 0x05
    41a2:	84 83       	std	Z+4, r24	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:173
    pxIterator->pxNext = pxNewListItem;
    41a4:	eb 81       	ldd	r30, Y+3	; 0x03
    41a6:	fc 81       	ldd	r31, Y+4	; 0x04
    41a8:	8f 81       	ldd	r24, Y+7	; 0x07
    41aa:	98 85       	ldd	r25, Y+8	; 0x08
    41ac:	93 83       	std	Z+3, r25	; 0x03
    41ae:	82 83       	std	Z+2, r24	; 0x02
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:177

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    41b0:	ef 81       	ldd	r30, Y+7	; 0x07
    41b2:	f8 85       	ldd	r31, Y+8	; 0x08
    41b4:	8d 81       	ldd	r24, Y+5	; 0x05
    41b6:	9e 81       	ldd	r25, Y+6	; 0x06
    41b8:	91 87       	std	Z+9, r25	; 0x09
    41ba:	80 87       	std	Z+8, r24	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:179

    ( pxList->uxNumberOfItems )++;
    41bc:	ed 81       	ldd	r30, Y+5	; 0x05
    41be:	fe 81       	ldd	r31, Y+6	; 0x06
    41c0:	80 81       	ld	r24, Z
    41c2:	8f 5f       	subi	r24, 0xFF	; 255
    41c4:	ed 81       	ldd	r30, Y+5	; 0x05
    41c6:	fe 81       	ldd	r31, Y+6	; 0x06
    41c8:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:180
}
    41ca:	28 96       	adiw	r28, 0x08	; 8
    41cc:	0f b6       	in	r0, 0x3f	; 63
    41ce:	f8 94       	cli
    41d0:	de bf       	out	0x3e, r29	; 62
    41d2:	0f be       	out	0x3f, r0	; 63
    41d4:	cd bf       	out	0x3d, r28	; 61
    41d6:	cf 91       	pop	r28
    41d8:	df 91       	pop	r29
    41da:	08 95       	ret

000041dc <uxListRemove>:
uxListRemove():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:184
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    41dc:	df 93       	push	r29
    41de:	cf 93       	push	r28
    41e0:	00 d0       	rcall	.+0      	; 0x41e2 <uxListRemove+0x6>
    41e2:	00 d0       	rcall	.+0      	; 0x41e4 <uxListRemove+0x8>
    41e4:	cd b7       	in	r28, 0x3d	; 61
    41e6:	de b7       	in	r29, 0x3e	; 62
    41e8:	9c 83       	std	Y+4, r25	; 0x04
    41ea:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:187
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    41ec:	eb 81       	ldd	r30, Y+3	; 0x03
    41ee:	fc 81       	ldd	r31, Y+4	; 0x04
    41f0:	80 85       	ldd	r24, Z+8	; 0x08
    41f2:	91 85       	ldd	r25, Z+9	; 0x09
    41f4:	9a 83       	std	Y+2, r25	; 0x02
    41f6:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:189

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    41f8:	eb 81       	ldd	r30, Y+3	; 0x03
    41fa:	fc 81       	ldd	r31, Y+4	; 0x04
    41fc:	a2 81       	ldd	r26, Z+2	; 0x02
    41fe:	b3 81       	ldd	r27, Z+3	; 0x03
    4200:	eb 81       	ldd	r30, Y+3	; 0x03
    4202:	fc 81       	ldd	r31, Y+4	; 0x04
    4204:	84 81       	ldd	r24, Z+4	; 0x04
    4206:	95 81       	ldd	r25, Z+5	; 0x05
    4208:	15 96       	adiw	r26, 0x05	; 5
    420a:	9c 93       	st	X, r25
    420c:	8e 93       	st	-X, r24
    420e:	14 97       	sbiw	r26, 0x04	; 4
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:190
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4210:	eb 81       	ldd	r30, Y+3	; 0x03
    4212:	fc 81       	ldd	r31, Y+4	; 0x04
    4214:	a4 81       	ldd	r26, Z+4	; 0x04
    4216:	b5 81       	ldd	r27, Z+5	; 0x05
    4218:	eb 81       	ldd	r30, Y+3	; 0x03
    421a:	fc 81       	ldd	r31, Y+4	; 0x04
    421c:	82 81       	ldd	r24, Z+2	; 0x02
    421e:	93 81       	ldd	r25, Z+3	; 0x03
    4220:	13 96       	adiw	r26, 0x03	; 3
    4222:	9c 93       	st	X, r25
    4224:	8e 93       	st	-X, r24
    4226:	12 97       	sbiw	r26, 0x02	; 2
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:196

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    4228:	e9 81       	ldd	r30, Y+1	; 0x01
    422a:	fa 81       	ldd	r31, Y+2	; 0x02
    422c:	21 81       	ldd	r18, Z+1	; 0x01
    422e:	32 81       	ldd	r19, Z+2	; 0x02
    4230:	8b 81       	ldd	r24, Y+3	; 0x03
    4232:	9c 81       	ldd	r25, Y+4	; 0x04
    4234:	28 17       	cp	r18, r24
    4236:	39 07       	cpc	r19, r25
    4238:	41 f4       	brne	.+16     	; 0x424a <uxListRemove+0x6e>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:198
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    423a:	eb 81       	ldd	r30, Y+3	; 0x03
    423c:	fc 81       	ldd	r31, Y+4	; 0x04
    423e:	84 81       	ldd	r24, Z+4	; 0x04
    4240:	95 81       	ldd	r25, Z+5	; 0x05
    4242:	e9 81       	ldd	r30, Y+1	; 0x01
    4244:	fa 81       	ldd	r31, Y+2	; 0x02
    4246:	92 83       	std	Z+2, r25	; 0x02
    4248:	81 83       	std	Z+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:205
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    424a:	eb 81       	ldd	r30, Y+3	; 0x03
    424c:	fc 81       	ldd	r31, Y+4	; 0x04
    424e:	11 86       	std	Z+9, r1	; 0x09
    4250:	10 86       	std	Z+8, r1	; 0x08
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:206
    ( pxList->uxNumberOfItems )--;
    4252:	e9 81       	ldd	r30, Y+1	; 0x01
    4254:	fa 81       	ldd	r31, Y+2	; 0x02
    4256:	80 81       	ld	r24, Z
    4258:	81 50       	subi	r24, 0x01	; 1
    425a:	e9 81       	ldd	r30, Y+1	; 0x01
    425c:	fa 81       	ldd	r31, Y+2	; 0x02
    425e:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:208

    return pxList->uxNumberOfItems;
    4260:	e9 81       	ldd	r30, Y+1	; 0x01
    4262:	fa 81       	ldd	r31, Y+2	; 0x02
    4264:	80 81       	ld	r24, Z
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/Source/list.c:209
}
    4266:	0f 90       	pop	r0
    4268:	0f 90       	pop	r0
    426a:	0f 90       	pop	r0
    426c:	0f 90       	pop	r0
    426e:	cf 91       	pop	r28
    4270:	df 91       	pop	r29
    4272:	08 95       	ret

00004274 <pxPortInitialiseStack>:
pxPortInitialiseStack():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:317
 */
static void prvSetupTimerInterrupt (void);
/*-----------------------------------------------------------*/

StackType_t* pxPortInitialiseStack (StackType_t * pxTopOfStack,
	TaskFunction_t pxCode, void * pvParameters) {
    4274:	df 93       	push	r29
    4276:	cf 93       	push	r28
    4278:	cd b7       	in	r28, 0x3d	; 61
    427a:	de b7       	in	r29, 0x3e	; 62
    427c:	28 97       	sbiw	r28, 0x08	; 8
    427e:	0f b6       	in	r0, 0x3f	; 63
    4280:	f8 94       	cli
    4282:	de bf       	out	0x3e, r29	; 62
    4284:	0f be       	out	0x3f, r0	; 63
    4286:	cd bf       	out	0x3d, r28	; 61
    4288:	9c 83       	std	Y+4, r25	; 0x04
    428a:	8b 83       	std	Y+3, r24	; 0x03
    428c:	7e 83       	std	Y+6, r23	; 0x06
    428e:	6d 83       	std	Y+5, r22	; 0x05
    4290:	58 87       	std	Y+8, r21	; 0x08
    4292:	4f 83       	std	Y+7, r20	; 0x07
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:324
	/* Simulate how the stack would look after a call to vPortYield() generated by
	 the compiler. */

	/* The start of the task code will be popped off the stack last, so place
	 it on first. */
	usAddress = (uint16_t) pxCode;
    4294:	8d 81       	ldd	r24, Y+5	; 0x05
    4296:	9e 81       	ldd	r25, Y+6	; 0x06
    4298:	9a 83       	std	Y+2, r25	; 0x02
    429a:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:325
	*pxTopOfStack = (StackType_t) (usAddress & (uint16_t) 0x00ff);
    429c:	89 81       	ldd	r24, Y+1	; 0x01
    429e:	eb 81       	ldd	r30, Y+3	; 0x03
    42a0:	fc 81       	ldd	r31, Y+4	; 0x04
    42a2:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:326
	pxTopOfStack--;
    42a4:	8b 81       	ldd	r24, Y+3	; 0x03
    42a6:	9c 81       	ldd	r25, Y+4	; 0x04
    42a8:	01 97       	sbiw	r24, 0x01	; 1
    42aa:	9c 83       	std	Y+4, r25	; 0x04
    42ac:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:328

	usAddress >>= 8;
    42ae:	89 81       	ldd	r24, Y+1	; 0x01
    42b0:	9a 81       	ldd	r25, Y+2	; 0x02
    42b2:	89 2f       	mov	r24, r25
    42b4:	99 27       	eor	r25, r25
    42b6:	9a 83       	std	Y+2, r25	; 0x02
    42b8:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:329
	*pxTopOfStack = (StackType_t) (usAddress & (uint16_t) 0x00ff);
    42ba:	89 81       	ldd	r24, Y+1	; 0x01
    42bc:	eb 81       	ldd	r30, Y+3	; 0x03
    42be:	fc 81       	ldd	r31, Y+4	; 0x04
    42c0:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:330
	pxTopOfStack--;
    42c2:	8b 81       	ldd	r24, Y+3	; 0x03
    42c4:	9c 81       	ldd	r25, Y+4	; 0x04
    42c6:	01 97       	sbiw	r24, 0x01	; 1
    42c8:	9c 83       	std	Y+4, r25	; 0x04
    42ca:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:337

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	 portSAVE_CONTEXT places the flags on the stack immediately after r0
	 to ensure the interrupts get disabled as soon as possible, and so ensuring
	 the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = (StackType_t) 0x00; /* R0 */
    42cc:	eb 81       	ldd	r30, Y+3	; 0x03
    42ce:	fc 81       	ldd	r31, Y+4	; 0x04
    42d0:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:338
	pxTopOfStack--;
    42d2:	8b 81       	ldd	r24, Y+3	; 0x03
    42d4:	9c 81       	ldd	r25, Y+4	; 0x04
    42d6:	01 97       	sbiw	r24, 0x01	; 1
    42d8:	9c 83       	std	Y+4, r25	; 0x04
    42da:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:339
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    42dc:	eb 81       	ldd	r30, Y+3	; 0x03
    42de:	fc 81       	ldd	r31, Y+4	; 0x04
    42e0:	80 e8       	ldi	r24, 0x80	; 128
    42e2:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:340
	pxTopOfStack--;
    42e4:	8b 81       	ldd	r24, Y+3	; 0x03
    42e6:	9c 81       	ldd	r25, Y+4	; 0x04
    42e8:	01 97       	sbiw	r24, 0x01	; 1
    42ea:	9c 83       	std	Y+4, r25	; 0x04
    42ec:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:343

	/* Now the remaining registers. The compiler expects R1 to be 0. */
	*pxTopOfStack = (StackType_t) 0x00; /* R1 */
    42ee:	eb 81       	ldd	r30, Y+3	; 0x03
    42f0:	fc 81       	ldd	r31, Y+4	; 0x04
    42f2:	10 82       	st	Z, r1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:346

	/* Leave R2 - R23 untouched */
	pxTopOfStack -= 23;
    42f4:	8b 81       	ldd	r24, Y+3	; 0x03
    42f6:	9c 81       	ldd	r25, Y+4	; 0x04
    42f8:	47 97       	sbiw	r24, 0x17	; 23
    42fa:	9c 83       	std	Y+4, r25	; 0x04
    42fc:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:349

	/* Place the parameter on the stack in the expected location. (r24:r25) */
	usAddress = (uint16_t) pvParameters;
    42fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4300:	98 85       	ldd	r25, Y+8	; 0x08
    4302:	9a 83       	std	Y+2, r25	; 0x02
    4304:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:350
	*pxTopOfStack = (StackType_t) (usAddress & (uint16_t) 0x00ff);
    4306:	89 81       	ldd	r24, Y+1	; 0x01
    4308:	eb 81       	ldd	r30, Y+3	; 0x03
    430a:	fc 81       	ldd	r31, Y+4	; 0x04
    430c:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:351
	pxTopOfStack--;
    430e:	8b 81       	ldd	r24, Y+3	; 0x03
    4310:	9c 81       	ldd	r25, Y+4	; 0x04
    4312:	01 97       	sbiw	r24, 0x01	; 1
    4314:	9c 83       	std	Y+4, r25	; 0x04
    4316:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:353

	usAddress >>= 8;
    4318:	89 81       	ldd	r24, Y+1	; 0x01
    431a:	9a 81       	ldd	r25, Y+2	; 0x02
    431c:	89 2f       	mov	r24, r25
    431e:	99 27       	eor	r25, r25
    4320:	9a 83       	std	Y+2, r25	; 0x02
    4322:	89 83       	std	Y+1, r24	; 0x01
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:354
	*pxTopOfStack = (StackType_t) (usAddress & (uint16_t) 0x00ff);
    4324:	89 81       	ldd	r24, Y+1	; 0x01
    4326:	eb 81       	ldd	r30, Y+3	; 0x03
    4328:	fc 81       	ldd	r31, Y+4	; 0x04
    432a:	80 83       	st	Z, r24
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:357

	/* Leave register R26 - R31 untouched */
	pxTopOfStack -= 7;
    432c:	8b 81       	ldd	r24, Y+3	; 0x03
    432e:	9c 81       	ldd	r25, Y+4	; 0x04
    4330:	07 97       	sbiw	r24, 0x07	; 7
    4332:	9c 83       	std	Y+4, r25	; 0x04
    4334:	8b 83       	std	Y+3, r24	; 0x03
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:359

	return pxTopOfStack;
    4336:	8b 81       	ldd	r24, Y+3	; 0x03
    4338:	9c 81       	ldd	r25, Y+4	; 0x04
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:360
}
    433a:	28 96       	adiw	r28, 0x08	; 8
    433c:	0f b6       	in	r0, 0x3f	; 63
    433e:	f8 94       	cli
    4340:	de bf       	out	0x3e, r29	; 62
    4342:	0f be       	out	0x3f, r0	; 63
    4344:	cd bf       	out	0x3d, r28	; 61
    4346:	cf 91       	pop	r28
    4348:	df 91       	pop	r29
    434a:	08 95       	ret

0000434c <xPortStartScheduler>:
xPortStartScheduler():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:363
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler (void) {
    434c:	df 93       	push	r29
    434e:	cf 93       	push	r28
    4350:	cd b7       	in	r28, 0x3d	; 61
    4352:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:365
	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();
    4354:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <prvSetupTimerInterrupt>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:368

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    4358:	a0 91 a5 03 	lds	r26, 0x03A5
    435c:	b0 91 a6 03 	lds	r27, 0x03A6
    4360:	cd 91       	ld	r28, X+
    4362:	cd bf       	out	0x3d, r28	; 61
    4364:	dd 91       	ld	r29, X+
    4366:	de bf       	out	0x3e, r29	; 62
    4368:	ff 91       	pop	r31
    436a:	ef 91       	pop	r30
    436c:	df 91       	pop	r29
    436e:	cf 91       	pop	r28
    4370:	bf 91       	pop	r27
    4372:	af 91       	pop	r26
    4374:	9f 91       	pop	r25
    4376:	8f 91       	pop	r24
    4378:	7f 91       	pop	r23
    437a:	6f 91       	pop	r22
    437c:	5f 91       	pop	r21
    437e:	4f 91       	pop	r20
    4380:	3f 91       	pop	r19
    4382:	2f 91       	pop	r18
    4384:	1f 91       	pop	r17
    4386:	0f 91       	pop	r16
    4388:	ff 90       	pop	r15
    438a:	ef 90       	pop	r14
    438c:	df 90       	pop	r13
    438e:	cf 90       	pop	r12
    4390:	bf 90       	pop	r11
    4392:	af 90       	pop	r10
    4394:	9f 90       	pop	r9
    4396:	8f 90       	pop	r8
    4398:	7f 90       	pop	r7
    439a:	6f 90       	pop	r6
    439c:	5f 90       	pop	r5
    439e:	4f 90       	pop	r4
    43a0:	3f 90       	pop	r3
    43a2:	2f 90       	pop	r2
    43a4:	1f 90       	pop	r1
    43a6:	0f 90       	pop	r0
    43a8:	0f be       	out	0x3f, r0	; 63
    43aa:	0f 90       	pop	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:372

	/* Simulate a function call end as generated by the compiler. We will now
	 jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    43ac:	08 95       	ret
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:375

	/* Should not get here. */
	return pdTRUE;
    43ae:	81 e0       	ldi	r24, 0x01	; 1
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:376
}
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <vPortEndScheduler>:
vPortEndScheduler():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:379
/*-----------------------------------------------------------*/

void vPortEndScheduler (void) {
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	cd b7       	in	r28, 0x3d	; 61
    43bc:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:381
	/* It is unlikely that the ATmega port will get stopped. */
}
    43be:	cf 91       	pop	r28
    43c0:	df 91       	pop	r29
    43c2:	08 95       	ret

000043c4 <vPortYield>:
vPortYield():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:390
 * Manual context switch. The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield (void) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield (void) {
	portSAVE_CONTEXT();
    43c4:	0f 92       	push	r0
    43c6:	0f b6       	in	r0, 0x3f	; 63
    43c8:	f8 94       	cli
    43ca:	0f 92       	push	r0
    43cc:	1f 92       	push	r1
    43ce:	11 24       	eor	r1, r1
    43d0:	2f 92       	push	r2
    43d2:	3f 92       	push	r3
    43d4:	4f 92       	push	r4
    43d6:	5f 92       	push	r5
    43d8:	6f 92       	push	r6
    43da:	7f 92       	push	r7
    43dc:	8f 92       	push	r8
    43de:	9f 92       	push	r9
    43e0:	af 92       	push	r10
    43e2:	bf 92       	push	r11
    43e4:	cf 92       	push	r12
    43e6:	df 92       	push	r13
    43e8:	ef 92       	push	r14
    43ea:	ff 92       	push	r15
    43ec:	0f 93       	push	r16
    43ee:	1f 93       	push	r17
    43f0:	2f 93       	push	r18
    43f2:	3f 93       	push	r19
    43f4:	4f 93       	push	r20
    43f6:	5f 93       	push	r21
    43f8:	6f 93       	push	r22
    43fa:	7f 93       	push	r23
    43fc:	8f 93       	push	r24
    43fe:	9f 93       	push	r25
    4400:	af 93       	push	r26
    4402:	bf 93       	push	r27
    4404:	cf 93       	push	r28
    4406:	df 93       	push	r29
    4408:	ef 93       	push	r30
    440a:	ff 93       	push	r31
    440c:	a0 91 a5 03 	lds	r26, 0x03A5
    4410:	b0 91 a6 03 	lds	r27, 0x03A6
    4414:	0d b6       	in	r0, 0x3d	; 61
    4416:	0d 92       	st	X+, r0
    4418:	0e b6       	in	r0, 0x3e	; 62
    441a:	0d 92       	st	X+, r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:391
	vTaskSwitchContext();
    441c:	0e 94 c7 0c 	call	0x198e	; 0x198e <vTaskSwitchContext>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:392
	portRESTORE_CONTEXT();
    4420:	a0 91 a5 03 	lds	r26, 0x03A5
    4424:	b0 91 a6 03 	lds	r27, 0x03A6
    4428:	cd 91       	ld	r28, X+
    442a:	cd bf       	out	0x3d, r28	; 61
    442c:	dd 91       	ld	r29, X+
    442e:	de bf       	out	0x3e, r29	; 62
    4430:	ff 91       	pop	r31
    4432:	ef 91       	pop	r30
    4434:	df 91       	pop	r29
    4436:	cf 91       	pop	r28
    4438:	bf 91       	pop	r27
    443a:	af 91       	pop	r26
    443c:	9f 91       	pop	r25
    443e:	8f 91       	pop	r24
    4440:	7f 91       	pop	r23
    4442:	6f 91       	pop	r22
    4444:	5f 91       	pop	r21
    4446:	4f 91       	pop	r20
    4448:	3f 91       	pop	r19
    444a:	2f 91       	pop	r18
    444c:	1f 91       	pop	r17
    444e:	0f 91       	pop	r16
    4450:	ff 90       	pop	r15
    4452:	ef 90       	pop	r14
    4454:	df 90       	pop	r13
    4456:	cf 90       	pop	r12
    4458:	bf 90       	pop	r11
    445a:	af 90       	pop	r10
    445c:	9f 90       	pop	r9
    445e:	8f 90       	pop	r8
    4460:	7f 90       	pop	r7
    4462:	6f 90       	pop	r6
    4464:	5f 90       	pop	r5
    4466:	4f 90       	pop	r4
    4468:	3f 90       	pop	r3
    446a:	2f 90       	pop	r2
    446c:	1f 90       	pop	r1
    446e:	0f 90       	pop	r0
    4470:	0f be       	out	0x3f, r0	; 63
    4472:	0f 90       	pop	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:394

	__asm__ __volatile__ ( "ret" );
    4474:	08 95       	ret

00004476 <vPortYieldFromISR>:
vPortYieldFromISR():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:404
 * Manual context switch callable from ISRs. The first thing we do is save
 * the registers so we can use a naked attribute.
 */
void vPortYieldFromISR (void) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromISR (void) {
	portSAVE_CONTEXT();
    4476:	0f 92       	push	r0
    4478:	0f b6       	in	r0, 0x3f	; 63
    447a:	f8 94       	cli
    447c:	0f 92       	push	r0
    447e:	1f 92       	push	r1
    4480:	11 24       	eor	r1, r1
    4482:	2f 92       	push	r2
    4484:	3f 92       	push	r3
    4486:	4f 92       	push	r4
    4488:	5f 92       	push	r5
    448a:	6f 92       	push	r6
    448c:	7f 92       	push	r7
    448e:	8f 92       	push	r8
    4490:	9f 92       	push	r9
    4492:	af 92       	push	r10
    4494:	bf 92       	push	r11
    4496:	cf 92       	push	r12
    4498:	df 92       	push	r13
    449a:	ef 92       	push	r14
    449c:	ff 92       	push	r15
    449e:	0f 93       	push	r16
    44a0:	1f 93       	push	r17
    44a2:	2f 93       	push	r18
    44a4:	3f 93       	push	r19
    44a6:	4f 93       	push	r20
    44a8:	5f 93       	push	r21
    44aa:	6f 93       	push	r22
    44ac:	7f 93       	push	r23
    44ae:	8f 93       	push	r24
    44b0:	9f 93       	push	r25
    44b2:	af 93       	push	r26
    44b4:	bf 93       	push	r27
    44b6:	cf 93       	push	r28
    44b8:	df 93       	push	r29
    44ba:	ef 93       	push	r30
    44bc:	ff 93       	push	r31
    44be:	a0 91 a5 03 	lds	r26, 0x03A5
    44c2:	b0 91 a6 03 	lds	r27, 0x03A6
    44c6:	0d b6       	in	r0, 0x3d	; 61
    44c8:	0d 92       	st	X+, r0
    44ca:	0e b6       	in	r0, 0x3e	; 62
    44cc:	0d 92       	st	X+, r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:405
	vTaskSwitchContext();
    44ce:	0e 94 c7 0c 	call	0x198e	; 0x198e <vTaskSwitchContext>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:406
	portRESTORE_CONTEXT();
    44d2:	a0 91 a5 03 	lds	r26, 0x03A5
    44d6:	b0 91 a6 03 	lds	r27, 0x03A6
    44da:	cd 91       	ld	r28, X+
    44dc:	cd bf       	out	0x3d, r28	; 61
    44de:	dd 91       	ld	r29, X+
    44e0:	de bf       	out	0x3e, r29	; 62
    44e2:	ff 91       	pop	r31
    44e4:	ef 91       	pop	r30
    44e6:	df 91       	pop	r29
    44e8:	cf 91       	pop	r28
    44ea:	bf 91       	pop	r27
    44ec:	af 91       	pop	r26
    44ee:	9f 91       	pop	r25
    44f0:	8f 91       	pop	r24
    44f2:	7f 91       	pop	r23
    44f4:	6f 91       	pop	r22
    44f6:	5f 91       	pop	r21
    44f8:	4f 91       	pop	r20
    44fa:	3f 91       	pop	r19
    44fc:	2f 91       	pop	r18
    44fe:	1f 91       	pop	r17
    4500:	0f 91       	pop	r16
    4502:	ff 90       	pop	r15
    4504:	ef 90       	pop	r14
    4506:	df 90       	pop	r13
    4508:	cf 90       	pop	r12
    450a:	bf 90       	pop	r11
    450c:	af 90       	pop	r10
    450e:	9f 90       	pop	r9
    4510:	8f 90       	pop	r8
    4512:	7f 90       	pop	r7
    4514:	6f 90       	pop	r6
    4516:	5f 90       	pop	r5
    4518:	4f 90       	pop	r4
    451a:	3f 90       	pop	r3
    451c:	2f 90       	pop	r2
    451e:	1f 90       	pop	r1
    4520:	0f 90       	pop	r0
    4522:	0f be       	out	0x3f, r0	; 63
    4524:	0f 90       	pop	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:408

	__asm__ __volatile__ ( "reti" );
    4526:	18 95       	reti

00004528 <vPortYieldFromTick>:
vPortYieldFromTick():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:420
 * difference from vPortYield() is the tick count is incremented as the
 * call comes from the tick ISR.
 */
void vPortYieldFromTick (void) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick (void) {
	portSAVE_CONTEXT();
    4528:	0f 92       	push	r0
    452a:	0f b6       	in	r0, 0x3f	; 63
    452c:	f8 94       	cli
    452e:	0f 92       	push	r0
    4530:	1f 92       	push	r1
    4532:	11 24       	eor	r1, r1
    4534:	2f 92       	push	r2
    4536:	3f 92       	push	r3
    4538:	4f 92       	push	r4
    453a:	5f 92       	push	r5
    453c:	6f 92       	push	r6
    453e:	7f 92       	push	r7
    4540:	8f 92       	push	r8
    4542:	9f 92       	push	r9
    4544:	af 92       	push	r10
    4546:	bf 92       	push	r11
    4548:	cf 92       	push	r12
    454a:	df 92       	push	r13
    454c:	ef 92       	push	r14
    454e:	ff 92       	push	r15
    4550:	0f 93       	push	r16
    4552:	1f 93       	push	r17
    4554:	2f 93       	push	r18
    4556:	3f 93       	push	r19
    4558:	4f 93       	push	r20
    455a:	5f 93       	push	r21
    455c:	6f 93       	push	r22
    455e:	7f 93       	push	r23
    4560:	8f 93       	push	r24
    4562:	9f 93       	push	r25
    4564:	af 93       	push	r26
    4566:	bf 93       	push	r27
    4568:	cf 93       	push	r28
    456a:	df 93       	push	r29
    456c:	ef 93       	push	r30
    456e:	ff 93       	push	r31
    4570:	a0 91 a5 03 	lds	r26, 0x03A5
    4574:	b0 91 a6 03 	lds	r27, 0x03A6
    4578:	0d b6       	in	r0, 0x3d	; 61
    457a:	0d 92       	st	X+, r0
    457c:	0e b6       	in	r0, 0x3e	; 62
    457e:	0d 92       	st	X+, r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:421
	if (xTaskIncrementTick() != pdFALSE) {
    4580:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xTaskIncrementTick>
    4584:	88 23       	and	r24, r24
    4586:	11 f0       	breq	.+4      	; 0x458c <vPortYieldFromTick+0x64>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:422
		vTaskSwitchContext();
    4588:	0e 94 c7 0c 	call	0x198e	; 0x198e <vTaskSwitchContext>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:424
	}
	portRESTORE_CONTEXT();
    458c:	a0 91 a5 03 	lds	r26, 0x03A5
    4590:	b0 91 a6 03 	lds	r27, 0x03A6
    4594:	cd 91       	ld	r28, X+
    4596:	cd bf       	out	0x3d, r28	; 61
    4598:	dd 91       	ld	r29, X+
    459a:	de bf       	out	0x3e, r29	; 62
    459c:	ff 91       	pop	r31
    459e:	ef 91       	pop	r30
    45a0:	df 91       	pop	r29
    45a2:	cf 91       	pop	r28
    45a4:	bf 91       	pop	r27
    45a6:	af 91       	pop	r26
    45a8:	9f 91       	pop	r25
    45aa:	8f 91       	pop	r24
    45ac:	7f 91       	pop	r23
    45ae:	6f 91       	pop	r22
    45b0:	5f 91       	pop	r21
    45b2:	4f 91       	pop	r20
    45b4:	3f 91       	pop	r19
    45b6:	2f 91       	pop	r18
    45b8:	1f 91       	pop	r17
    45ba:	0f 91       	pop	r16
    45bc:	ff 90       	pop	r15
    45be:	ef 90       	pop	r14
    45c0:	df 90       	pop	r13
    45c2:	cf 90       	pop	r12
    45c4:	bf 90       	pop	r11
    45c6:	af 90       	pop	r10
    45c8:	9f 90       	pop	r9
    45ca:	8f 90       	pop	r8
    45cc:	7f 90       	pop	r7
    45ce:	6f 90       	pop	r6
    45d0:	5f 90       	pop	r5
    45d2:	4f 90       	pop	r4
    45d4:	3f 90       	pop	r3
    45d6:	2f 90       	pop	r2
    45d8:	1f 90       	pop	r1
    45da:	0f 90       	pop	r0
    45dc:	0f be       	out	0x3f, r0	; 63
    45de:	0f 90       	pop	r0
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:426

	__asm__ __volatile__ ( "ret" );
    45e0:	08 95       	ret

000045e2 <prvSetupTimerInterrupt>:
prvSetupTimerInterrupt():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:447

#elif defined (portUSE_TIMER0)
/*
 * Setup Timer0 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt (void) {
    45e2:	df 93       	push	r29
    45e4:	cf 93       	push	r28
    45e6:	cd b7       	in	r28, 0x3d	; 61
    45e8:	de b7       	in	r29, 0x3e	; 62
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:448
	timer0Init();
    45ea:	0e 94 62 03 	call	0x6c4	; 0x6c4 <timer0Init>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:449
}
    45ee:	cf 91       	pop	r28
    45f0:	df 91       	pop	r29
    45f2:	08 95       	ret

000045f4 <__vector_14>:
__vector_14():
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:469
 */
ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
ISR(portSCHEDULER_ISR) {
	vPortYieldFromTick();
    45f4:	0e 94 94 22 	call	0x4528	; 0x4528 <vPortYieldFromTick>
Z:\Programming_Workspaces\AVR_Studio\AvrRTOSDemo\default/../FreeRTOS/user/port.c:470
	__asm__ __volatile__ ( "reti" );
    45f8:	18 95       	reti

000045fa <__udivmodsi4>:
__udivmodsi4():
    45fa:	a1 e2       	ldi	r26, 0x21	; 33
    45fc:	1a 2e       	mov	r1, r26
    45fe:	aa 1b       	sub	r26, r26
    4600:	bb 1b       	sub	r27, r27
    4602:	fd 01       	movw	r30, r26
    4604:	0d c0       	rjmp	.+26     	; 0x4620 <__udivmodsi4_ep>

00004606 <__udivmodsi4_loop>:
__udivmodsi4_loop():
    4606:	aa 1f       	adc	r26, r26
    4608:	bb 1f       	adc	r27, r27
    460a:	ee 1f       	adc	r30, r30
    460c:	ff 1f       	adc	r31, r31
    460e:	a2 17       	cp	r26, r18
    4610:	b3 07       	cpc	r27, r19
    4612:	e4 07       	cpc	r30, r20
    4614:	f5 07       	cpc	r31, r21
    4616:	20 f0       	brcs	.+8      	; 0x4620 <__udivmodsi4_ep>
    4618:	a2 1b       	sub	r26, r18
    461a:	b3 0b       	sbc	r27, r19
    461c:	e4 0b       	sbc	r30, r20
    461e:	f5 0b       	sbc	r31, r21

00004620 <__udivmodsi4_ep>:
__udivmodsi4_ep():
    4620:	66 1f       	adc	r22, r22
    4622:	77 1f       	adc	r23, r23
    4624:	88 1f       	adc	r24, r24
    4626:	99 1f       	adc	r25, r25
    4628:	1a 94       	dec	r1
    462a:	69 f7       	brne	.-38     	; 0x4606 <__udivmodsi4_loop>
    462c:	60 95       	com	r22
    462e:	70 95       	com	r23
    4630:	80 95       	com	r24
    4632:	90 95       	com	r25
    4634:	9b 01       	movw	r18, r22
    4636:	ac 01       	movw	r20, r24
    4638:	bd 01       	movw	r22, r26
    463a:	cf 01       	movw	r24, r30
    463c:	08 95       	ret

0000463e <memcpy>:
memcpy():
    463e:	fb 01       	movw	r30, r22
    4640:	dc 01       	movw	r26, r24
    4642:	02 c0       	rjmp	.+4      	; 0x4648 <memcpy+0xa>
    4644:	01 90       	ld	r0, Z+
    4646:	0d 92       	st	X+, r0
    4648:	41 50       	subi	r20, 0x01	; 1
    464a:	50 40       	sbci	r21, 0x00	; 0
    464c:	d8 f7       	brcc	.-10     	; 0x4644 <memcpy+0x6>
    464e:	08 95       	ret

00004650 <memset>:
memset():
    4650:	dc 01       	movw	r26, r24
    4652:	01 c0       	rjmp	.+2      	; 0x4656 <memset+0x6>
    4654:	6d 93       	st	X+, r22
    4656:	41 50       	subi	r20, 0x01	; 1
    4658:	50 40       	sbci	r21, 0x00	; 0
    465a:	e0 f7       	brcc	.-8      	; 0x4654 <memset+0x4>
    465c:	08 95       	ret

0000465e <strncpy>:
strncpy():
    465e:	fb 01       	movw	r30, r22
    4660:	dc 01       	movw	r26, r24
    4662:	41 50       	subi	r20, 0x01	; 1
    4664:	50 40       	sbci	r21, 0x00	; 0
    4666:	48 f0       	brcs	.+18     	; 0x467a <strncpy+0x1c>
    4668:	01 90       	ld	r0, Z+
    466a:	0d 92       	st	X+, r0
    466c:	00 20       	and	r0, r0
    466e:	c9 f7       	brne	.-14     	; 0x4662 <strncpy+0x4>
    4670:	01 c0       	rjmp	.+2      	; 0x4674 <strncpy+0x16>
    4672:	1d 92       	st	X+, r1
    4674:	41 50       	subi	r20, 0x01	; 1
    4676:	50 40       	sbci	r21, 0x00	; 0
    4678:	e0 f7       	brcc	.-8      	; 0x4672 <strncpy+0x14>
    467a:	08 95       	ret

0000467c <itoa>:
itoa():
    467c:	fb 01       	movw	r30, r22
    467e:	9f 01       	movw	r18, r30
    4680:	e8 94       	clt
    4682:	42 30       	cpi	r20, 0x02	; 2
    4684:	c4 f0       	brlt	.+48     	; 0x46b6 <itoa+0x3a>
    4686:	45 32       	cpi	r20, 0x25	; 37
    4688:	b4 f4       	brge	.+44     	; 0x46b6 <itoa+0x3a>
    468a:	4a 30       	cpi	r20, 0x0A	; 10
    468c:	29 f4       	brne	.+10     	; 0x4698 <itoa+0x1c>
    468e:	97 fb       	bst	r25, 7
    4690:	1e f4       	brtc	.+6      	; 0x4698 <itoa+0x1c>
    4692:	90 95       	com	r25
    4694:	81 95       	neg	r24
    4696:	9f 4f       	sbci	r25, 0xFF	; 255
    4698:	64 2f       	mov	r22, r20
    469a:	77 27       	eor	r23, r23
    469c:	0e 94 6f 23 	call	0x46de	; 0x46de <__udivmodhi4>
    46a0:	80 5d       	subi	r24, 0xD0	; 208
    46a2:	8a 33       	cpi	r24, 0x3A	; 58
    46a4:	0c f0       	brlt	.+2      	; 0x46a8 <itoa+0x2c>
    46a6:	89 5d       	subi	r24, 0xD9	; 217
    46a8:	81 93       	st	Z+, r24
    46aa:	cb 01       	movw	r24, r22
    46ac:	00 97       	sbiw	r24, 0x00	; 0
    46ae:	a1 f7       	brne	.-24     	; 0x4698 <itoa+0x1c>
    46b0:	16 f4       	brtc	.+4      	; 0x46b6 <itoa+0x3a>
    46b2:	5d e2       	ldi	r21, 0x2D	; 45
    46b4:	51 93       	st	Z+, r21
    46b6:	10 82       	st	Z, r1
    46b8:	c9 01       	movw	r24, r18
    46ba:	0c 94 5f 23 	jmp	0x46be	; 0x46be <strrev>

000046be <strrev>:
strrev():
    46be:	dc 01       	movw	r26, r24
    46c0:	fc 01       	movw	r30, r24
    46c2:	67 2f       	mov	r22, r23
    46c4:	71 91       	ld	r23, Z+
    46c6:	77 23       	and	r23, r23
    46c8:	e1 f7       	brne	.-8      	; 0x46c2 <strrev+0x4>
    46ca:	32 97       	sbiw	r30, 0x02	; 2
    46cc:	04 c0       	rjmp	.+8      	; 0x46d6 <strrev+0x18>
    46ce:	7c 91       	ld	r23, X
    46d0:	6d 93       	st	X+, r22
    46d2:	70 83       	st	Z, r23
    46d4:	62 91       	ld	r22, -Z
    46d6:	ae 17       	cp	r26, r30
    46d8:	bf 07       	cpc	r27, r31
    46da:	c8 f3       	brcs	.-14     	; 0x46ce <strrev+0x10>
    46dc:	08 95       	ret

000046de <__udivmodhi4>:
__udivmodhi4():
    46de:	aa 1b       	sub	r26, r26
    46e0:	bb 1b       	sub	r27, r27
    46e2:	51 e1       	ldi	r21, 0x11	; 17
    46e4:	07 c0       	rjmp	.+14     	; 0x46f4 <__udivmodhi4_ep>

000046e6 <__udivmodhi4_loop>:
__udivmodhi4_loop():
    46e6:	aa 1f       	adc	r26, r26
    46e8:	bb 1f       	adc	r27, r27
    46ea:	a6 17       	cp	r26, r22
    46ec:	b7 07       	cpc	r27, r23
    46ee:	10 f0       	brcs	.+4      	; 0x46f4 <__udivmodhi4_ep>
    46f0:	a6 1b       	sub	r26, r22
    46f2:	b7 0b       	sbc	r27, r23

000046f4 <__udivmodhi4_ep>:
__udivmodhi4_ep():
    46f4:	88 1f       	adc	r24, r24
    46f6:	99 1f       	adc	r25, r25
    46f8:	5a 95       	dec	r21
    46fa:	a9 f7       	brne	.-22     	; 0x46e6 <__udivmodhi4_loop>
    46fc:	80 95       	com	r24
    46fe:	90 95       	com	r25
    4700:	bc 01       	movw	r22, r24
    4702:	cd 01       	movw	r24, r26
    4704:	08 95       	ret

00004706 <_exit>:
_exit():
    4706:	f8 94       	cli

00004708 <__stop_program>:
__stop_program():
    4708:	ff cf       	rjmp	.-2      	; 0x4708 <__stop_program>
